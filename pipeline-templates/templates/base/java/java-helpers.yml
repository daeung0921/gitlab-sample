# ────────────────────────────────────────────────
# fn_mvn_build 함수
#   원격 서버(REMOTE_DEPLOY_HOST)에 SSH 접속하여 Maven 빌드 수행 후 산출물(zip) 다운로드
#
# ▶ 사용 방법:
#   script:
#     - !reference [.fn_mvn_build, script]
#     - fn_mvn_build
#
# ▶ 제어용 환경 변수 목록:
#   - REMOTE_DEPLOY_HOST   (필수) SSH 대상 서버 IP 또는 호스트명
#   - REMOTE_DEPLOY_USER   (필수) SSH 접속 계정
#   - REMOTE_DIR           (필수) 원격 빌드 작업 디렉토리 (/tmp/gitlab-build-$CI_PIPELINE_ID 등)
#   - REMOTE_DEPLOY_PORT   (선택) SSH 포트, 기본값 22
#   - REMOTE_SETTINGS      (선택) 원격 Maven settings.xml 경로
#   - MAVEN_CLI_OPTS       (선택) Maven 옵션, 기본값 "-B"
#                            예: "-B -DskipTests" 또는 "-B -Dmaven.test.skip=true"
#   - BUILD_DIR            (선택) Maven 산출물 디렉토리, 기본값 "target"
#   - ZIP_FILE             (선택) 원격 zip 파일명, 기본값 "build-artifact.zip"
#   - LOCAL_ZIP_OUT        (선택) 로컬에 다운로드할 zip 파일명
#   - CI_PROJECT_DIR       (선택) 로컬 소스 루트 (기본값 ".")
#   - SSH_PRIVATE_KEY      (필수, Runner에 따라) SSH 개인키 (before_script에서 등록)
#
# ▶ 예시 (GitLab CI):
#   variables:
#     REMOTE_DEPLOY_HOST: "13.124.131.170"
#     REMOTE_DEPLOY_USER: "gitlab-runner-user"
#     REMOTE_DIR: "/tmp/gitlab-build-${CI_PIPELINE_ID}"
#     MAVEN_CLI_OPTS: "-B -DskipTests=false"
#   script:
#     - !reference [.fn_mvn_build, script]
#     - fn_mvn_build
# ────────────────────────────────────────────────
.fn_mvn_build:
  script: |
    fn_mvn_build() {
      set -eu

      # ──  환경 변수 초기화 (필요 시 CI/CD 변수로 override 가능) ───────────── 
      maven_cli_opts="${MAVEN_CLI_OPTS:-"-B -V"}"           # 공통 mvn 옵션
      remote_dir="${REMOTE_DIR:?REMOTE_DIR is required}"    # 원격 작업 디렉터리
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      remote_settings="${REMOTE_SETTINGS:-""}"               # settings.xml 경로(옵션)
      src_dir="${CI_PROJECT_DIR:-.}"
      zip_file="${ZIP_FILE:-"build-artifact.zip"}"           # 내려받을 로그 번들명
      local_zip="${LOCAL_ZIP_OUT:-$zip_file}"
      mvn_debug="${MVN_DEBUG:-false}"                       # true면 -e -X
    
      # ── SSH 접속 정보 확인 ─────────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
    
      # ── 내부 헬퍼 함수 ─────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      err() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq() { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }
    
      # ── 소스 동기화 (rsync 우선, 없으면 tar 스트리밍) ─────────────────────────────────────────────
      log "▶ Sync sources to remote: $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir"
      if command -v rsync >/dev/null 2>&1 && \
         ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" 'command -v rsync >/dev/null 2>&1'
      then
        RSYNC_EXCLUDES="--exclude=.git --exclude=.m2 --exclude=target --exclude=node_modules --exclude=.gradle"
        log "Using rsync for efficient incremental sync"
        rsync -az --delete \
          -e "ssh -p $remote_port" \
          --rsync-path="mkdir -p '$remote_dir' && rsync" \
          $RSYNC_EXCLUDES \
          "$src_dir/" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir/"
      else
        log "rsync not available, falling back to tar streaming"
        tar -C "$src_dir" \
            --exclude=".git" --exclude=".m2" --exclude="target" \
            --exclude="node_modules" --exclude=".gradle" \
            -czf - . \
          | ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "mkdir -p '$remote_dir' && tar -xzf - -C '$remote_dir'"
      fi
    
      # ── 원격 빌드 스크립트 생성 ─────────────────────────────────────────────
      remote_script=$(mktemp -t remote_build.XXXXXX)
    
      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      err()  { printf '[ERR]  %s\n' "$*" >&2; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${ZIP_FILE:?ZIP_FILE is required}"
      : "${MVN_OPTS:?MVN_OPTS is required}"
      : "${MVN_DEBUG:?MVN_DEBUG is required}"
      
      ARTIFACT_DIR="$REMOTE_DIR/artifacts"
      LOG_DIR="$REMOTE_DIR/_logs"
      MVN_LOG="$LOG_DIR/mvn.log"
      ENV_LOG="$LOG_DIR/build-env.txt" 
      BUNDLE="$ARTIFACT_DIR/$ZIP_FILE"
      MVN_GOAL="compile"
      
      mkdir -p "$ARTIFACT_DIR" "$LOG_DIR"
      cd "$REMOTE_DIR"
      [ -f pom.xml ] || { err "pom.xml not found in $REMOTE_DIR"; exit 2; }

      command -v mvn >/dev/null 2>&1 || fail "Maven not installed"
      command -v zip >/dev/null 2>&1 || fail "zip not installed" 

      # mvn 체크
      command -v mvn >/dev/null 2>&1 || err "Maven not installed"
      log "Using Maven: $(command -v mvn)"
      log "Options    : $MVN_OPTS"
      log "Debug Mode : $MVN_DEBUG"

      # 환경 수집
      {
        echo "== Build Env =="
        date -u +"%Y-%m-%dT%H:%M:%SZ"
        uname -a || true
        (java -version) 2>&1 || true
        (mvn -v) 2>&1 || true
      } > "$ENV_LOG"
      
      EXTRA_OPTS=""
      if [ "$MVN_DEBUG" = "true" ]; then
        EXTRA_OPTS="$EXTRA_OPTS -e -X -DtrimStackTrace=false"
      fi
      
      # 실제 빌드: compile만 수행
      log "▶ Running: mvn compile"
      if [ -n "${SETTINGS_XML:-}" ]; then
        mvn $MVN_OPTS $EXTRA_OPTS -s "$SETTINGS_XML" compile \
            2>&1 | tee -a "$MVN_LOG"
      else
        mvn $MVN_OPTS $EXTRA_OPTS compile \
            2>&1 | tee -a "$MVN_LOG"
      fi

      status=${PIPESTATUS[0]}

      log "----- mvn.log (full) -----"
      cat "$MVN_LOG" || true
      log "--------------------------"
      
      # 로그 번들링
      rm -f "$BUNDLE"
      (cd "$REMOTE_DIR" && zip -r "$BUNDLE" "_logs" >/dev/null)
 
      
      if [ ! -s "$BUNDLE" ]; then
        err "Logs bundling failed: $BUNDLE"
      else
        ok "Logs bundled successfully: $BUNDLE"
      fi

      if [ "$status" -ne 0 ]; then
        fail "Maven compile failed (exit $status)"
      fi
 
    REMOTE_SH
    
      # ── 원격 실행 ────────────────────────────────────────
      log "▶ Executing remote compile (logs-only): ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$remote_dir")'" \
        "ZIP_FILE='$(shq "$zip_file")'" \
        "MVN_OPTS='$(shq "$maven_cli_opts")'" \
        "MVN_DEBUG='$(shq "$mvn_debug")'" \
        "SETTINGS_XML='$(shq "$remote_settings")'" \
        'export REMOTE_DIR ZIP_FILE MVN_OPTS MVN_DEBUG SETTINGS_XML; sh -s' \
        < "$remote_script"
    
      # ── 로그 번들 다운로드 (zip 또는 tar.gz) ───────────────
      remote_zip="${remote_dir}/artifacts/${zip_file}"
      log "▶ Downloading logs bundle…"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_zip"
      ok "Downloaded: $local_zip"
    
      rm -f "$remote_script" || true
    }

# ────────────────────────────────────────────────
# fn_mvn_test 함수
#   원격 서버(REMOTE_DEPLOY_HOST)에 SSH 접속하여 Maven 테스트 수행 후
#   Surefire + JaCoCo 리포트를 zip 형태로 다운로드
#
# ▶ 사용 방법:
#   script:
#     - !reference [.fn_mvn_test, script]
#     - fn_mvn_test
#
# ▶ 제어용 환경 변수 목록:
#   - REMOTE_DEPLOY_HOST   (필수) SSH 대상 서버 IP 또는 호스트명
#   - REMOTE_DEPLOY_USER   (필수) SSH 접속 계정
#   - REMOTE_DIR           (필수) 원격 작업 디렉토리 (/tmp/gitlab-test-$CI_PIPELINE_ID 등)
#   - REMOTE_DEPLOY_PORT   (선택) SSH 포트, 기본값 22
#   - REMOTE_SETTINGS      (선택) Maven settings.xml 경로
#   - MAVEN_CLI_OPTS       (선택) Maven 옵션, 기본값 "-B"
#   - REPORT_DIR           (선택) Surefire 리포트 경로, 기본값 "target/surefire-reports"
#   - JACOCO_DIR           (선택) JaCoCo 리포트 경로, 기본값 "target/site/jacoco"
#   - ZIP_FILE             (선택) zip 파일명, 기본값 "test-reports.zip"
#   - ARTIFACT_DIR         (선택) 로컬에 저장할 디렉토리, 기본값 "$CI_PROJECT_DIR/artifacts"
#   - SSH_PRIVATE_KEY      (필수, Runner에 따라) SSH 개인키 (before_script에서 등록)
#
# ▶ 예시 (GitLab CI):
#   variables:
#     REMOTE_DEPLOY_HOST: "13.124.131.170"
#     REMOTE_DEPLOY_USER: "gitlab-runner-user"
#     REMOTE_DIR: "/tmp/gitlab-test-${CI_PIPELINE_ID}"
#     MAVEN_CLI_OPTS: "-B"
#   script:
#     - !reference [.fn_mvn_test, script]
#     - fn_mvn_test
# ────────────────────────────────────────────────
.fn_mvn_test:
  script: |
    fn_mvn_test() {
      set -eu

      maven_cli_opts="${MAVEN_CLI_OPTS:-"-B"}"
      report_dir="${REPORT_DIR:-"target/surefire-reports"}"
      jacoco_dir="${JACOCO_DIR:-"target/site/jacoco"}"
      artifact_dir="${ARTIFACT_DIR:-"$CI_PROJECT_DIR/artifacts"}"
      zip_file="${ZIP_FILE:-"test-reports.zip"}"
      remote_dir="${REMOTE_DIR:?REMOTE_DIR is required}"
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      remote_settings="${REMOTE_SETTINGS:-""}"
      src_dir="${CI_PROJECT_DIR:-.}"

      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"

      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq() { printf "%s" "$1" | sed "s/'/'\\\\''/g"; } # shell-safe quoting for SSH (Alpine BusyBox 호환)

      log "▶ Syncing sources to remote: $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir"
      if command -v rsync >/dev/null 2>&1 && \
         ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" 'command -v rsync >/dev/null 2>&1'
      then
        RSYNC_EXCLUDES="--exclude=.git --exclude=.m2 --exclude=target --exclude=node_modules --exclude=.gradle"
        rsync -az --delete \
          -e "ssh -p $remote_port" \
          --rsync-path="mkdir -p '$remote_dir' && rsync" \
          $RSYNC_EXCLUDES \
          "$src_dir/" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir/"
      else
        tar -C "$src_dir" \
            --exclude=".git" --exclude=".m2" --exclude="target" \
            --exclude="node_modules" --exclude=".gradle" \
            -czf - . \
          | ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "mkdir -p '$remote_dir' && tar -xzf - -C '$remote_dir'"
      fi

      remote_script=$(mktemp -t remote_test.XXXXXX)
      log "Created temporary remote test script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${REPORT_DIR:?REPORT_DIR is required}"
      : "${JACOCO_DIR:?JACOCO_DIR is required}"
      : "${ZIP_FILE:?ZIP_FILE is required}"
      : "${MVN_OPTS:?MVN_OPTS is required}"

      mkdir -p "$REMOTE_DIR"
      cd "$REMOTE_DIR"
      [ -f "pom.xml" ] || fail "pom.xml not found"

      command -v mvn >/dev/null 2>&1 || fail "Maven not installed"
      log "Using Maven: $(command -v mvn)"
      log "Options: $MVN_OPTS"

      if [ -n "${SETTINGS_XML:-}" ]; then
        mvn $MVN_OPTS -s "$SETTINGS_XML" test
      else
        mvn $MVN_OPTS test
      fi
      ok "Maven tests completed"

      ARTIFACT_DIR="$REMOTE_DIR/artifacts"
      mkdir -p "$ARTIFACT_DIR"
      rm -f "$ARTIFACT_DIR/$ZIP_FILE"
      zip -r "$ARTIFACT_DIR/$ZIP_FILE" "$REPORT_DIR" "$JACOCO_DIR" >/dev/null 2>&1 || true
      [ -s "$ARTIFACT_DIR/$ZIP_FILE" ] || fail "Report zip creation failed"
      ok "Packaged reports: $ARTIFACT_DIR/$ZIP_FILE"
    REMOTE_SH

      log "▶ Executing remote test via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$remote_dir")'" \
        "REPORT_DIR='$(shq "$report_dir")'" \
        "JACOCO_DIR='$(shq "$jacoco_dir")'" \
        "ZIP_FILE='$(shq "$zip_file")'" \
        "MVN_OPTS='$(shq "$maven_cli_opts")'" \
        "SETTINGS_XML='$(shq "$remote_settings")'" \
        'export REMOTE_DIR REPORT_DIR JACOCO_DIR ZIP_FILE MVN_OPTS SETTINGS_XML; sh -s' \
        < "$remote_script"

      remote_zip="${remote_dir}/artifacts/${zip_file}"
      local_zip="${artifact_dir}/${zip_file}"
      mkdir -p "$artifact_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_zip"
      ok "Reports downloaded successfully: $local_zip"

      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }

# ────────────────────────────────────────────────
# fn_mvn_deploy_snapshot
#   원격 서버에서 mvn clean deploy (snapshot) 실행 후
#   배포 로그 + 산출물(WAR/JAR)을 zip으로 묶어 로컬로 다운로드
#
# ▶ 필요 변수
#   - REMOTE_DEPLOY_HOST   (필수)
#   - REMOTE_DEPLOY_USER   (필수)
#   - REMOTE_DIR           (필수) 예: /tmp/gitlab-deploy-${CI_PIPELINE_ID}
#   - SNAPSHOT_REPO_URL    (필수) 예: https://nexus.../maven-devops-snapshots/
#   - REMOTE_DEPLOY_PORT   (선택, 기본 22)
#   - MAVEN_CLI_OPTS       (선택, 기본 "-B")
#   - REMOTE_SETTINGS      (선택) 원격 settings.xml 경로
#   - CI_PROJECT_DIR       (선택, 기본 .) 로컬 소스 루트
#
# ▶ 결과물
#   - 로컬: artifacts/deploy-snapshot-artifacts.zip
# ────────────────────────────────────────────────
.fn_mvn_deploy_snapshot:
  script: |
    fn_mvn_deploy_snapshot() {
      set -eu

      # ── 환경값 초기화 ─────────────────────────────────────────────
      maven_cli_opts="${MAVEN_CLI_OPTS:-"-B"}"
      remote_dir="${REMOTE_DIR:?REMOTE_DIR is required}"
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      remote_settings="${REMOTE_SETTINGS:-""}"
      src_dir="${CI_PROJECT_DIR:-.}"
      snapshot_repo_url="${SNAPSHOT_REPO_URL:?SNAPSHOT_REPO_URL is required}"
      mvn_debug="${MVN_DEBUG:-false}"   

      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"

      # ── 유틸/로깅 ─────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      # BusyBox/Alpine 호환 shell-quoting
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 1) 소스 동기화 ─────────────────────────────────────────────
      log "▶ Sync sources to remote: $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir"
      if command -v rsync >/dev/null 2>&1 && \
         ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" 'command -v rsync >/dev/null 2>&1'
      then
        RSYNC_EXCLUDES="--exclude=.git --exclude=.m2 --exclude=target --exclude=node_modules --exclude=.gradle"
        rsync -az --delete \
          -e "ssh -p $remote_port" \
          --rsync-path="mkdir -p '$remote_dir' && rsync" \
          $RSYNC_EXCLUDES \
          "$src_dir/" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir/"
      else
        tar -C "$src_dir" \
            --exclude=".git" --exclude=".m2" --exclude="target" \
            --exclude="node_modules" --exclude=".gradle" \
            -czf - . \
          | ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "mkdir -p '$remote_dir' && tar -xzf - -C '$remote_dir'"
      fi

      # ── 2) 원격 스크립트 생성 ─────────────────────────────────────────────
      remote_script=$(mktemp /tmp/remote_deploy.XXXXXX)
      log "Created temporary remote deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      err() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${MVN_OPTS:?MVN_OPTS is required}"
      : "${SNAPSHOT_REPO_URL:?SNAPSHOT_REPO_URL is required}"
      : "${MVN_DEBUG:?MVN_DEBUG is required}"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      DEPLOY_LOG="$ARTIFACTS_DIR/deploy-snapshot-to-registry.log"

      # 준비
      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"
      [ -f "pom.xml" ] || err "pom.xml not found in $REMOTE_DIR"

      # mvn 체크
      command -v mvn >/dev/null 2>&1 || err "Maven not installed"
      log "Using Maven: $(command -v mvn)"
      log "Options    : $MVN_OPTS"
      log "Repo URL   : $SNAPSHOT_REPO_URL"
      log "Debug Mode : $MVN_DEBUG"

      EXTRA_OPTS=""
      if [ "$MVN_DEBUG" = "true" ]; then
        EXTRA_OPTS="$EXTRA_OPTS -e -X -DtrimStackTrace=false"
      fi
      
      # 배포 실행
      log "▶ Maven Deploy Snapshot"
      if [ -n "${SETTINGS_XML:-}" ]; then
        if ! mvn $MVN_OPTS $EXTRA_OPTS -s "$SETTINGS_XML" clean deploy \
              -DaltDeploymentRepository=nexus-snapshots::default::"$SNAPSHOT_REPO_URL" 2>&1 | tee "$DEPLOY_LOG"; then
          err "Maven deploy failed (see $DEPLOY_LOG)"
        fi
      else
        if ! mvn $MVN_OPTS $EXTRA_OPTS clean deploy \
              -DaltDeploymentRepository=nexus-snapshots::default::"$SNAPSHOT_REPO_URL" 2>&1 | tee "$DEPLOY_LOG"; then
          err "Maven deploy failed (see $DEPLOY_LOG)"
        fi
      fi

      log "----- deploy-snapshot-to-registry (full) -----"
      cat "$DEPLOY_LOG" || true
      log "--------------------------------------"

      ok "Maven snapshot deploy finished"

      # 산출물 압축 (WAR/JAR + 로그)
      OUT_ZIP="$ARTIFACTS_DIR/deploy-snapshot-artifacts.zip"
      rm -f "$OUT_ZIP"
      log "▶ Archiving deployed artifacts"

      # zip 실패해도 전체 흐름 중단하지 않기 위해 || true
      # zip -r "$OUT_ZIP" target/*.war target/*.jar "$DEPLOY_LOG" >/dev/null 2>&1 || true # 아티팩트 사이즈가 너무 커서 제외함
      # zip -r "$OUT_ZIP" "$DEPLOY_LOG" >/dev/null 2>&1 || true # 경로보존. *.tar 같은걸 저장하면 -r 옵션 필요 
      zip -j "$OUT_ZIP" "$DEPLOY_LOG" >/dev/null 2>&1 || true # 경로 삭제

      [ -s "$OUT_ZIP" ] || err "No deployment artifacts were archived"

      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      # ── 3) 원격 배포 실행 (환경변수 안전 전달) ─────────────────────────────────────────────
      log "▶ Executing remote deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$remote_dir")'" \
        "MVN_OPTS='$(shq "$maven_cli_opts")'" \
        "SNAPSHOT_REPO_URL='$(shq "$snapshot_repo_url")'" \
        "SETTINGS_XML='$(shq "$remote_settings")'" \
        "MVN_DEBUG='$(shq "$mvn_debug")'" \
        'export REMOTE_DIR MVN_OPTS SNAPSHOT_REPO_URL SETTINGS_XML MVN_DEBUG; sh -s' \
        < "$remote_script"

      # ── 4) 산출물 다운로드 ─────────────────────────────────────────────
      remote_zip="${remote_dir}/artifacts/deploy-snapshot-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      log "▶ Downloading artifact: $remote_zip -> $local_dir/"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_dir/"

      ok "Done: $local_dir/$(basename "$remote_zip")"

      # ── 5) 임시 파일 정리 ─────────────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }

# ────────────────────────────────────────────────
# fn_mvn_deploy_release
#   Git 태그(COMMIT_TAG)로 버전 설정 후,
#   원격에서 Maven Release 배포 → zip 산출물 scp 회수
#
# ▶ 필수 변수
#   - COMMIT_TAG            : 예) v1.2.3  (v 접두어 자동 제거)
#   - RELEASE_REPO_URL      : 예) https://nexus.../repository/maven-devops-releases/
#   - REMOTE_DEPLOY_HOST    : 원격 호스트
#   - REMOTE_DEPLOY_USER    : 원격 계정
#   - REMOTE_DIR            : 원격 작업 디렉토리
#
# ▶ 선택 변수
#   - MAVEN_CLI_OPTS        : 기본 "-B"
#   - REMOTE_DEPLOY_PORT    : 기본 22
#   - REMOTE_SETTINGS       : 원격 settings.xml 경로(인증/미러 등)
#   - CI_PROJECT_DIR        : 로컬 소스 루트(기본 .)
# ────────────────────────────────────────────────
.fn_mvn_deploy_release:
  script: |
    fn_mvn_deploy_release() {
      set -eu

      # ── 필수값 강제 ─────────────────────────────────────────────
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"

      # ── 기본값 ────────────────────────────────────────────────
      maven_cli_opts="${MAVEN_CLI_OPTS:-"-B"}"
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      remote_settings="${REMOTE_SETTINGS:-""}"
      src_dir="${CI_PROJECT_DIR:-.}"
      mvn_debug="${MVN_DEBUG:-false}" 

      # ── 유틸 ─────────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      # Alpine BusyBox 호환, 작은따옴표 안전 이스케이프
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 1) 소스 동기화 (rsync → tar 폴백) ─────────────────────
      log "▶ Sync sources to remote: $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$REMOTE_DIR"
      if command -v rsync >/dev/null 2>&1 && \
         ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" 'command -v rsync >/dev/null 2>&1'
      then
        rsync -az --delete \
          -e "ssh -p $remote_port" \
          --rsync-path="mkdir -p '$REMOTE_DIR' && rsync" \
          --exclude=.git --exclude=.m2 --exclude=target --exclude=node_modules --exclude=.gradle \
          "$src_dir/" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$REMOTE_DIR/"
      else
        tar -C "$src_dir" \
            --exclude=".git" --exclude=".m2" --exclude="target" \
            --exclude="node_modules" --exclude=".gradle" \
            -czf - . \
          | ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "mkdir -p '$REMOTE_DIR' && tar -xzf - -C '$REMOTE_DIR'"
      fi

      # ── 2) 원격 실행 스크립트 생성 ────────────────────────────
      remote_script=$(mktemp /tmp/remote_release.XXXXXX)
      log "Created temporary remote release script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${MVN_OPTS:?MVN_OPTS is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${MVN_DEBUG:?MVN_DEBUG is required}"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      DEPLOY_LOG="$ARTIFACTS_DIR/deploy-release-to-registry.log"

      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"
      [ -f "pom.xml" ] || fail "pom.xml not found in $REMOTE_DIR"

      command -v mvn >/dev/null 2>&1 || fail "Maven not installed"
      log "Using Maven : $(command -v mvn)"
      log "MVN_OPTS   : $MVN_OPTS"
      log "Release URL: $RELEASE_REPO_URL"
      log "COMMIT_TAG : $COMMIT_TAG"
      log "Debug Mode : $MVN_DEBUG"

      EXTRA_OPTS=""
      if [ "$MVN_DEBUG" = "true" ]; then
        EXTRA_OPTS="$EXTRA_OPTS -e -X -DtrimStackTrace=false"
      fi

      # 2-1) pom.xml의 <version> 값을 NEW_VERSION 으로 변경 (태그 → 버전 (v 접두어 제거))
      NEW_VERSION="${COMMIT_TAG#v}"
      [ -n "$NEW_VERSION" ] || fail "Resolved NEW_VERSION is empty"

      log "▶ Setting version to $NEW_VERSION"
      if [ -n "${SETTINGS_XML:-}" ]; then
        mvn $MVN_OPTS $EXTRA_OPTS -s "$SETTINGS_XML" versions:set -DnewVersion="$NEW_VERSION" -DgenerateBackupPoms=false 2>&1 | tee -a "$DEPLOY_LOG"
      else
        mvn $MVN_OPTS $EXTRA_OPTS versions:set -DnewVersion="$NEW_VERSION" -DgenerateBackupPoms=false 2>&1 | tee -a "$DEPLOY_LOG"
      fi

      # 2-2) Release Deploy  
      log "▶ Maven Deploy Release"
      if [ -n "${SETTINGS_XML:-}" ]; then
        mvn $MVN_OPTS $EXTRA_OPTS -s "$SETTINGS_XML" clean deploy \
          -DaltDeploymentRepository="nexus-releases::${RELEASE_REPO_URL}" 2>&1 | tee -a "$DEPLOY_LOG"
      else
        mvn $MVN_OPTS $EXTRA_OPTS clean deploy \
          -DaltDeploymentRepository="nexus-releases::${RELEASE_REPO_URL}" 2>&1 | tee -a "$DEPLOY_LOG"
      fi
      ok "Maven release deploy finished"

      # 2-3) 산출물 압축 (WAR/JAR + 로그)
      OUT_ZIP="$ARTIFACTS_DIR/deploy-release-artifacts.zip"
      rm -f "$OUT_ZIP"
      #zip -r "$OUT_ZIP" "$DEPLOY_LOG" >/dev/null 2>&1 || true # 경로보존. *.tar 같은걸 저장하면 -r 옵션 필요 
      zip -j "$OUT_ZIP" "$DEPLOY_LOG" >/dev/null 2>&1 || true # 경로 삭제
      [ -s "$OUT_ZIP" ] || fail "No deployment artifacts were archived"
      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      # ── 3) 원격 실행 (환경 안전 전달) ─────────────────────────
      log "▶ Executing remote release via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "MVN_OPTS='$(shq "$maven_cli_opts")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "SETTINGS_XML='$(shq "$remote_settings")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "MVN_DEBUG='$(shq "$mvn_debug")'" \
        'export REMOTE_DIR MVN_OPTS RELEASE_REPO_URL SETTINGS_XML COMMIT_TAG MVN_DEBUG; sh -s' \
        < "$remote_script"

      # ── 4) 산출물 다운로드 (파일 경로 명시) ────────────────────
      remote_zip="${REMOTE_DIR}/artifacts/deploy-release-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      local_file="$local_dir/$(basename "$remote_zip")"

      log "▶ Downloading artifact: $remote_zip -> $local_file"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_file"
      ok "Done: $local_file"

      # ── 5) 임시 파일 정리 ──────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }

# ────────────────────────────────────────────────
# fn_tomcat_deploy_war
#   Nexus Releases에서 WAR 다운로드 → Tomcat Manager로 배포를
#   "원격 서버(SSH)"에서 수행하고, 로그 zip을 Runner로 회수
#
# ▶ 필수 변수
#   - REMOTE_DEPLOY_HOST      : SSH 대상 (배포 실행 호스트)  ex) 13.124.131.170
#   - REMOTE_DEPLOY_USER      : SSH 계정                     ex) gitlab-runner-user
#   - REMOTE_DIR              : 원격 작업 디렉토리           ex) /tmp/gitlab-prod-${CI_PIPELINE_ID}
#   - RELEASE_REPO_URL        : Nexus Release repo base URL  ex) https://nexus.../repository/maven-devops-releases
#   - GROUP_ID                : GAV groupId                  ex) com.example
#   - ARTIFACT_ID             : GAV artifactId               ex) devops
#   - COMMIT_TAG              : 태그(필수, v1.2.3 형식 가능)
#   - WAS_URL                 : Tomcat Manager가 떠있는 호스트/IP (HTTP 베이스)
#   - NEXUS_USER / NEXUS_PASS : Nexus 다운로드 계정
#   - DEPLOY_USER/DEPLOY_PASS : Tomcat Manager 계정(배포 권한)
#
# ▶ 선택 변수
#   - MAVEN_CLI_OPTS          : 미사용(참고용), 통일성 위해 남김
#   - REMOTE_DEPLOY_PORT      : SSH 포트 (기본 22)
#   - CONTEXT_PATH            : Tomcat context path (기본 /devops)
# ────────────────────────────────────────────────
.fn_tomcat_deploy_war:
  script: |
    fn_tomcat_deploy_war() {
      set -eu

      # ── 필수값 강제 ─────────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"

      # ── 기본값 ────────────────────────────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      context_path="${CONTEXT_PATH:-/devops}"

      # ── 유틸 ─────────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      # Alpine BusyBox 호환, 작은따옴표 안전 이스케이프
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 1) 원격 스크립트 생성 ─────────────────────────────────
      remote_script=$(mktemp /tmp/remote_deploy_prod.XXXXXX)
      log "Created temporary remote prod deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      DEPLOY_LOG="$ARTIFACTS_DIR/deploy-prod.log"

      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"

      # v 접두어 제거한 버전
      VERSION="${COMMIT_TAG#v}"
      [ -n "$VERSION" ] || fail "Resolved VERSION is empty"

      WAR_FILE="${ARTIFACT_ID}-${VERSION}.war"
      # groupId 의 점(.)을 / 로 치환
      WAR_PATH="${GROUP_ID//.//}/${ARTIFACT_ID}/${VERSION}/${WAR_FILE}"

      # RELEASE_REPO_URL 끝 슬래시 제거 후 구성
      BASE="${RELEASE_REPO_URL%/}"
      URL="${BASE}/${WAR_PATH}"

      log "▶ Downloading WAR (artifact): ${ARTIFACT_ID}:${VERSION}"
      # 민감정보는 로그에 직접 출력하지 않음
      if ! curl -fsS --retry 3 -u "$NEXUS_USER:$NEXUS_PASS" -o "$WAR_FILE" "$URL" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Failed to download WAR from $URL"
      fi
      [ -s "$WAR_FILE" ] || fail "Downloaded WAR is empty: $WAR_FILE"

      log "▶ Deploying WAR to Tomcat PROD: http://$WAS_URL (context=$CONTEXT_PATH)"
      # Tomcat Manager text API 사용, update=true
      # ※ 로그에 자격증명 노출되지 않도록 주의 (curl 내부에서만 사용)
      if ! curl -fsS --retry 3 -u "$DEPLOY_USER:$DEPLOY_PASS" \
          -T "$WAR_FILE" \
          "http://$WAS_URL/manager/text/deploy?path=$CONTEXT_PATH&update=true" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Failed to deploy WAR to Tomcat Manager"
      fi

      ok "Tomcat deploy success"

      # 로그만 압축(대형 WAR 회수는 불필요/비효율)
      OUT_ZIP="$ARTIFACTS_DIR/deploy-war-artifacts.zip"
      rm -f "$OUT_ZIP"
      zip -r "$OUT_ZIP" "$DEPLOY_LOG" >/dev/null 2>&1 || true
      [ -s "$OUT_ZIP" ] || fail "No deployment logs were archived"
      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      # ── 2) 원격 실행 (환경 안전 전달) ─────────────────────────
      log "▶ Executing prod deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "DEPLOY_USER='$(shq "$DEPLOY_USER")'" \
        "DEPLOY_PASS='$(shq "$DEPLOY_PASS")'" \
        "CONTEXT_PATH='$(shq "$context_path")'" \
        'export REMOTE_DIR RELEASE_REPO_URL GROUP_ID ARTIFACT_ID COMMIT_TAG WAS_URL NEXUS_USER NEXUS_PASS DEPLOY_USER DEPLOY_PASS CONTEXT_PATH; sh -s' \
        < "$remote_script"

      # ── 3) 산출물 다운로드 (파일 경로 명시) ────────────────────
      remote_zip="${REMOTE_DIR}/artifacts/deploy-war-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      local_file="$local_dir/$(basename "$remote_zip")"

      log "▶ Downloading artifact: $remote_zip -> $local_file"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_file"
      ok "Done: $local_file"

      # ── 4) 임시 파일 정리 ──────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }

# ────────────────────────────────────────────────
# 함수: fn_tomcat_deploy_snapshot_war
#
# 목적:
#   - Nexus Snapshot 리포지토리에서 최신 SNAPSHOT WAR를 찾아
#     Tomcat Manager API(update=true)로 스테이징/개발 서버에 “통배포”한다.
#
# 동작 개요:
#   1) maven-metadata.xml(artifact 루트)에서 가장 최신 SNAPSHOT base 버전 선택 (예: 1.2.4-SNAPSHOT)
#   2) 해당 버전 디렉토리의 maven-metadata.xml에서 snapshotVersions 중 확장자가 war인 최신 항목 선택
#      - timestamped 네이밍(artifactId-1.2.4-20251016.090501-3.war) 지원
#      - 없으면 non-unique 스냅샷(artifactId-1.2.4-SNAPSHOT.war)로 폴백
#   3) WAR 다운로드 후 Tomcat Manager에 update=true로 배포
#   4) 배포 로그를 zip으로 패키징하여 Runner로 회수
#
# 특징:
#   - COMMIT_TAG 불필요 → 브랜치/MR 파이프라인에서 사용 용이
#   - SNAPSHOT_VERSION 변수를 주면 해당 SNAPSHOT(base) 버전 강제 사용 가능 (예: 1.2.4-SNAPSHOT)
#   - timestamped/ non-unique 모두 대응
#
# 필수 변수:
#   REMOTE_DEPLOY_HOST, REMOTE_DEPLOY_USER, REMOTE_DIR,
#   SNAPSHOT_REPO_URL, GROUP_ID, ARTIFACT_ID,
#   WAS_URL, NEXUS_USER, NEXUS_PASS, DEPLOY_USER, DEPLOY_PASS
#
# 선택 변수:
#   REMOTE_DEPLOY_PORT(기본 22), CONTEXT_PATH(기본 /devops),
#   SNAPSHOT_VERSION(강제 base SNAPSHOT, 예: 1.2.4-SNAPSHOT)
#
# 아티팩트:
#   artifacts/deploy-snapshot-war-artifacts.zip
#     └─ deploy-snapshot.log
# ────────────────────────────────────────────────
.fn_tomcat_deploy_snapshot_war:
  script: |
    fn_tomcat_deploy_snapshot_war() {
      set -eu

      # ── 필수값 ───────────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${SNAPSHOT_REPO_URL:?SNAPSHOT_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"

      # ── 기본값 ───────────────────────────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      context_path="${CONTEXT_PATH:-/devops}"

      # ── 유틸 ────────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 원격 실행 스크립트 생성 ─────────────────────────────
      remote_script=$(mktemp /tmp/remote_deploy_snapshot.XXXXXX)
      log "Created temporary snapshot deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${SNAPSHOT_REPO_URL:?SNAPSHOT_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

      # 도구 준비
      for t in curl xmllint zip; do
        if ! need "$t"; then
          if   need apk; then sudo apk add --no-cache $t libxml2-utils || true
          elif need apt-get; then sudo apt-get update -y && sudo apt-get install -y $t || true
          elif need dnf; then sudo dnf install -y $t libxml2 || true
          fi
        fi
      done
      need curl || fail "curl not available"
      need zip  || fail "zip not available"
      need xmllint || fail "xmllint not available"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      DEPLOY_LOG="$ARTIFACTS_DIR/deploy-snapshot-to-was.log"
      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"

      BASE="${SNAPSHOT_REPO_URL%/}/${GROUP_ID//.//}/${ARTIFACT_ID}"

      # 1) base SNAPSHOT 버전 결정 (우선순위: SNAPSHOT_VERSION 변수 → metadata 최신)
      BASE_SNAP="${SNAPSHOT_VERSION:-}"
      if [ -z "$BASE_SNAP" ]; then
        log "Resolve latest SNAPSHOT base version from artifact metadata"
        tmp_meta="$(mktemp)"
        if ! curl -fsS --insecure -u "$NEXUS_USER:$NEXUS_PASS" -o "$tmp_meta" "$BASE/maven-metadata.xml" 2>&1 | tee -a "$DEPLOY_LOG"; then
          fail "Failed to fetch artifact metadata"
        fi
        # versions 목록 중 -SNAPSHOT 로 끝나는 것 중 최댓값 선택
        BASE_SNAP="$(xmllint --xpath "string(//versioning/versions/version[contains(., '-SNAPSHOT')][last()])" "$tmp_meta" 2>>"$DEPLOY_LOG" || true)"
        rm -f "$tmp_meta"
        [ -n "$BASE_SNAP" ] || fail "No SNAPSHOT versions found in metadata"
      fi
      log "BASE_SNAPSHOT=$BASE_SNAP" | tee -a "$DEPLOY_LOG"

      # 2) version 디렉토리 메타에서 timestamped snapshot WAR 탐색
      ver_meta="$(mktemp)"
      if ! curl -fsS --insecure -u "$NEXUS_USER:$NEXUS_PASS" -o "$ver_meta" "$BASE/$BASE_SNAP/maven-metadata.xml" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Failed to fetch version metadata for $BASE_SNAP"
      fi

      # snapshotVersions 섹션에서 extension='war'인 최신 값을 찾는다
      SNAP_NAME="$(xmllint --xpath "string(//snapshotVersions/snapshotVersion[extension='war']/value[last()])" "$ver_meta" 2>>"$DEPLOY_LOG" || true)"
      rm -f "$ver_meta"

      WAR_URL=""
      WAR_FILE=""

      if [ -n "$SNAP_NAME" ]; then
        # timestamped 네이밍 (ex: devops-1.2.4-20251016.090501-3.war)
        WAR_FILE="${ARTIFACT_ID}-${SNAP_NAME}.war"
        WAR_URL="${BASE}/${BASE_SNAP}/${WAR_FILE}"
        log "Resolved timestamped snapshot: $WAR_FILE" | tee -a "$DEPLOY_LOG"
      else
        # non-unique 스냅샷으로 폴백 (ex: devops-1.2.4-SNAPSHOT.war)
        WAR_FILE="${ARTIFACT_ID}-${BASE_SNAP}.war"
        WAR_URL="${BASE}/${BASE_SNAP}/${WAR_FILE}"
        log "No snapshotVersions entry; fallback to non-unique: $WAR_FILE" | tee -a "$DEPLOY_LOG"
      fi

      log "▶ Downloading SNAPSHOT WAR: $WAR_URL"
      if ! curl -fsS --insecure --retry 3 -u "$NEXUS_USER:$NEXUS_PASS" -o "$WAR_FILE" "$WAR_URL" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Failed to download WAR" | tee -a "$DEPLOY_LOG"
      fi
      if [ ! -s "$WAR_FILE" ]; then
        fail "Downloaded WAR is empty" | tee -a "$DEPLOY_LOG"
      fi

      log "▶ Deploying to Tomcat: http://$WAS_URL (context=$CONTEXT_PATH)"
      if ! curl -fsS --insecure --retry 3 -u "$DEPLOY_USER:$DEPLOY_PASS" \
            -T "$WAR_FILE" \
            "http://$WAS_URL/manager/text/deploy?path=$CONTEXT_PATH&update=true" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Tomcat deploy failed" | tee -a "$DEPLOY_LOG"
      fi
      ok "Tomcat snapshot deploy success" | tee -a "$DEPLOY_LOG"

      # 로그 압축
      OUT_ZIP="$ARTIFACTS_DIR/deploy-snapshot-war-artifacts.zip"
      rm -f "$OUT_ZIP"
      zip -j "$OUT_ZIP" "$DEPLOY_LOG" >/dev/null 2>&1 || true
      [ -s "$OUT_ZIP" ] || fail "No deployment logs were archived"
      ok "Packaged: $OUT_ZIP"

    REMOTE_SH

      # ── 원격 실행 ────────────────────────────────────────────
      log "▶ Executing snapshot deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "SNAPSHOT_REPO_URL='$(shq "$SNAPSHOT_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "DEPLOY_USER='$(shq "$DEPLOY_USER")'" \
        "DEPLOY_PASS='$(shq "$DEPLOY_PASS")'" \
        "CONTEXT_PATH='$(shq "$context_path")'" \
        "SNAPSHOT_VERSION='$(shq "${SNAPSHOT_VERSION:-}")'" \
        'export REMOTE_DIR SNAPSHOT_REPO_URL GROUP_ID ARTIFACT_ID WAS_URL NEXUS_USER NEXUS_PASS DEPLOY_USER DEPLOY_PASS CONTEXT_PATH SNAPSHOT_VERSION; sh -s' \
        < "$remote_script"

      # ── 산출물 다운로드 ──────────────────────────────────────
      remote_zip="${REMOTE_DIR}/artifacts/deploy-snapshot-war-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_dir/"
      ok "Done: $local_dir/$(basename "$remote_zip")"

      # ── 정리 ─────────────────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }
 
# ────────────────────────────────────────────────
# fn_tomcat_rollback_war
#   현재 태그(CI_COMMIT_TAG 또는 COMMIT_TAG)의 "직전 릴리즈 버전"을
#   Nexus metadata로 조회 → 원격에서 WAR 다운로드 → Tomcat War 롤백 배포
#
# ▶ 필수 변수
#   - REMOTE_DEPLOY_HOST   : SSH 대상 원격 호스트
#   - REMOTE_DEPLOY_USER   : SSH 계정
#   - REMOTE_DIR           : 원격 작업 디렉토리 (/tmp/gitlab-rollback-${CI_PIPELINE_ID} 등)
#   - RELEASE_REPO_URL     : Nexus Releases base URL (예: https://nexus.../repository/maven-devops-releases)
#   - GROUP_ID             : 예) com.example
#   - ARTIFACT_ID          : 예) devops
#   - COMMIT_TAG           : 현재 배포 태그 (예: v1.2.3)  ※ v 접두어는 원격에서 제거
#   - WAS_URL            : Tomcat Manager 호스트:포트  (예: prod.example.com:8080)
#   - NEXUS_USER / NEXUS_PASS : Nexus 접근 계정
#   - DEPLOY_USER / DEPLOY_PASS : Tomcat Manager 배포 계정
#
# ▶ 선택 변수
#   - REMOTE_DEPLOY_PORT   : 기본 22
#   - CONTEXT_PATH         : 기본 "/devops"
# ────────────────────────────────────────────────
.fn_tomcat_rollback_war:
  script: |
    fn_tomcat_rollback_war() {
      set -eu

      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"

      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      context_path="${CONTEXT_PATH:-/devops}"

      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      remote_script=$(mktemp /tmp/remote_rollback_prod.XXXXXX)
      log "Created temporary remote rollback script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      ROLLBACK_LOG="$ARTIFACTS_DIR/rollback-prod.log"

      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"

      # ── 도구 준비 ─────────────────────────────────────────────────
      need() { command -v "$1" >/dev/null 2>&1; }
      if ! need curl; then
        if   need apk;      then sudo apk add --no-cache curl || true
        elif need apt-get;  then sudo apt-get update -y && sudo apt-get install -y curl || true
        elif need dnf;      then sudo dnf install -y curl || true
        fi
      fi
      if ! need xmllint; then
        if   need apk;      then sudo apk add --no-cache libxml2-utils || true
        elif need apt-get;  then sudo apt-get update -y && sudo apt-get install -y libxml2-utils || true
        elif need dnf;      then sudo dnf install -y libxml2 || true
        fi
      fi
      if ! need zip; then
        if   need apk;      then sudo apk add --no-cache zip || true
        elif need apt-get;  then sudo apt-get update -y && sudo apt-get install -y zip || true
        elif need dnf;      then sudo dnf install -y zip || true
        fi
      fi
      command -v curl >/dev/null 2>&1    || fail "curl not available"
      command -v xmllint >/dev/null 2>&1 || fail "xmllint not available"
      command -v zip >/dev/null 2>&1     || fail "zip not available"

      CUR_VERSION="${COMMIT_TAG#v}"
      [ -n "$CUR_VERSION" ] || fail "Resolved version from COMMIT_TAG is empty"

      META_URL="${RELEASE_REPO_URL%/}/${GROUP_ID//.//}/${ARTIFACT_ID}/maven-metadata.xml"

      # 숫자 비교 (a<b:-1, a==b:0, a>b:1)
      ver_cmp() {
        awk -v A="$1" -v B="$2" '
        function splitv(s, arr,   n,i) {
          n=split(s, arr, ".")
          for(i=1;i<=n;i++) if (arr[i] ~ /^[0-9]+$/) arr[i]+=0; else arr[i]=0
          return n
        }
        BEGIN{
          na=splitv(A, a); nb=splitv(B, b);
          n = (na>nb?na:nb)
          for(i=1;i<=n;i++){
            va = (i<=na)?a[i]:0
            vb = (i<=nb)?b[i]:0
            if (va<vb){print -1; exit}
            if (va>vb){print 1;  exit}
          }
          print 0
        }'
      }

      # prev 버전 해석 함수 (stdout에는 버전 1줄만)
      resolve_prev_version() {
        tmpfile="$(mktemp)"
        versions_tmp="$(mktemp)"
        trap 'rm -f "$tmpfile" "$versions_tmp"' RETURN

        # 로그는 stderr와 파일로만 남김
        log "▶ Fetching metadata: $META_URL" >&2
        if ! curl -fsS -u "$NEXUS_USER:$NEXUS_PASS" "$META_URL" -o "$tmpfile" >>"$ROLLBACK_LOG" 2>&1; then
          return 1
        fi

        if ! xmllint --xpath "//versioning/versions/version" "$tmpfile" 2>>"$ROLLBACK_LOG" \
          | sed -E 's#<version>#\n#g; s#</version>##g' \
          | sed '/^\s*$/d' \
          | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' > "$versions_tmp"; then
          return 1
        fi

        log "Available versions (as-is order):" >&2
        sed 's/^/  - /' "$versions_tmp" >&2

        # 1) 정확 일치 시 직전 항목 선택
        prev=""
        last=""
        found=0
        while IFS= read -r v; do
          [ -n "$v" ] || continue
          if [ "$v" = "$CUR_VERSION" ]; then
            found=1
            [ -n "$last" ] && prev="$last"
            break
          fi
          last="$v"
        done < "$versions_tmp"

        # 2) 매칭 실패 시, CUR_VERSION 보다 작은 값 중 최댓값 선택
        if [ "$found" -ne 1 ] || [ -z "$prev" ]; then
          prev=""
          while IFS= read -r v; do
            [ -n "$v" ] || continue
            cmp_cur="$(ver_cmp "$v" "$CUR_VERSION")"   # v ? cur
            if [ "$cmp_cur" -lt 0 ]; then              # v < cur
              if [ -z "$prev" ]; then
                prev="$v"
              else
                cmp_prev="$(ver_cmp "$v" "$prev")"
                [ "$cmp_prev" -gt 0 ] && prev="$v"     # v > prev
              fi
            fi
          done < "$versions_tmp"
        fi

        [ -n "$prev" ] || return 1
        printf '%s\n' "$prev"   # stdout에는 버전만 1줄
      }

      # ── 재시도 루프: 30초 간격, 최대 5회 ───────────────────────────
      attempt=1
      max_attempts=5
      sleep_secs=30
      RESOLVED_PREV=""

      while [ $attempt -le $max_attempts ]; do
        log "▶ Resolve previous version (attempt $attempt/$max_attempts)"
        RESOLVED_PREV="$(resolve_prev_version 2>>"$ROLLBACK_LOG" | head -n1 | tr -d ' \t\r')"
        if [ -n "$RESOLVED_PREV" ]; then
          # 숫자.점 이외 문자가 섞였는지 방어
          case "$RESOLVED_PREV" in
            ''|*[!0-9.]*)
              log "Resolved previous version looks invalid: '$RESOLVED_PREV'" >&2
              RESOLVED_PREV=""
              ;;
          esac
        fi
        if [ -n "$RESOLVED_PREV" ]; then
          log "▶ Previous version resolved: $RESOLVED_PREV"
          break
        fi
        if [ $attempt -lt $max_attempts ]; then
          log "Previous version not found yet. Retry in ${sleep_secs}s..."
          sleep $sleep_secs
        fi
        attempt=$((attempt+1))
      done

      [ -n "$RESOLVED_PREV" ] || fail "No previous version could be resolved after $max_attempts attempts"

      # ── WAR 다운로드 및 배포 ───────────────────────────────────────
      WAR_FILE="${ARTIFACT_ID}-${RESOLVED_PREV}.war"
      WAR_PATH="${GROUP_ID//.//}/${ARTIFACT_ID}/${RESOLVED_PREV}/${WAR_FILE}"
      BASE="${RELEASE_REPO_URL%/}"
      WAR_URL="${BASE}/${WAR_PATH}"

      log "▶ Downloading WAR: ${ARTIFACT_ID}:${RESOLVED_PREV}"
      if ! curl -fsS --retry 3 -u "$NEXUS_USER:$NEXUS_PASS" -o "$WAR_FILE" "$WAR_URL" >>"$ROLLBACK_LOG" 2>&1; then
        fail "Failed to download WAR from $WAR_URL"
      fi
      [ -s "$WAR_FILE" ] || fail "Downloaded WAR is empty: $WAR_FILE"

      log "▶ Deploying WAR to Tomcat PROD: http://$WAS_URL (context=$CONTEXT_PATH)"
      if ! curl -fsS --retry 3 -u "$DEPLOY_USER:$DEPLOY_PASS" \
          -T "$WAR_FILE" \
          "http://$WAS_URL/manager/text/deploy?path=$CONTEXT_PATH&update=true" >>"$ROLLBACK_LOG" 2>&1; then
        fail "Failed to deploy WAR to Tomcat Manager"
      fi

      ok "Rollback deploy success"

      OUT_ZIP="$ARTIFACTS_DIR/rollback-prod-artifacts.zip"
      rm -f "$OUT_ZIP"
      zip -r "$OUT_ZIP" "$ROLLBACK_LOG" >/dev/null 2>&1 || true
      [ -s "$OUT_ZIP" ] || fail "No rollback logs were archived"
      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      log "▶ Executing rollback via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "DEPLOY_USER='$(shq "$DEPLOY_USER")'" \
        "DEPLOY_PASS='$(shq "$DEPLOY_PASS")'" \
        "CONTEXT_PATH='$(shq "$context_path")'" \
        'export REMOTE_DIR RELEASE_REPO_URL GROUP_ID ARTIFACT_ID COMMIT_TAG WAS_URL NEXUS_USER NEXUS_PASS DEPLOY_USER DEPLOY_PASS CONTEXT_PATH; sh -s' \
        < "$remote_script"

      remote_zip="${REMOTE_DIR}/artifacts/rollback-prod-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_dir/"

      rm -f "$remote_script" || true
      ok "Rollback finished"
    }


# ───────────────────────────────────────────────────────────────────────────────
# 함수: fn_tomcat_diff_deploy
#
# 목적:
#   - 기존 LIVE 심볼릭 링크를 기준으로 이전 버전 디렉터리를 식별하고,
#     새 버전(WAR 기반)을 비교(diff)하여 변경/삭제된 파일만 증분 반영.
#   - Tomcat 서비스의 무중단(or 최소중단) 배포를 수행.
#   - 배포 후 헬스체크(healthcheck) 및 이전 릴리스 보존 정책 적용.
#
# 사용 시나리오:
#   GitLab CI/CD 파이프라인에서, release/deploy 단계에서 호출.
#   신규 WAR 업로드 시, 전체 배포 대신 차분만 적용.
#
# 디렉터리 구조 예시 (/opt/tomcat 기준)
# ├── webapps/
# │   ├── devops -> ../releases/devops/diff-devops-22.3.1-20251021183055   ← LIVE 심볼릭 링크
# │   ├── ROOT/
# │   └── ...
# ├── releases/
# │   └── devops/
# │       ├── diff-devops-22.3.0-20251020175644/
# │       │   ├── WEB-INF/
# │       │   ├── static/
# │       │   └── _logs/
# │       │       ├── changed-files.txt
# │       │       ├── deleted-files.txt
# │       │       ├── diff-base.env
# │       │       └── live-pointer.env       ← CURRENT, PREV 기록
# │       └── diff-devops-22.3.1-20251021183055/    ← 신규 대상
# ├── artifacts/
# │   └── devops/
# │       └── devops-22.3.1/
# │           ├── WEB-INF/
# │           └── static/
# └── logs/
#
# 주요 경로(코드 기본값):
#   WEBAPPS_ROOT   : /opt/tomcat/webapps
#   RELEASES_BASE  : /opt/tomcat/releases
#   ARTIFACTS_BASE : /opt/tomcat/artifacts
#   LIVE_LINK      : <WEBAPPS_ROOT>/<app>
#   TARGET/_logs   : 스냅샷별 로그/메타 저장 위치(배포/복구 시 rsync 제외)
#
# 산출물(원격에 생성):
#   $REMOTE_DIR/artifacts/
#     ├── diff-deploy-artifacts.zip
#     ├── changed-files.txt
#     ├── deleted-files.txt
#     ├── diff-base.env             (BASE_DIR=<직전 운영 스냅샷>)
#     └── live-pointer.env          (CURRENT=<이번 운영>, PREV=<직전 운영>)
#
# 필수 환경변수(외부 래퍼/CI에서 주입):
#   REMOTE_DEPLOY_HOST, REMOTE_DEPLOY_USER, REMOTE_DIR,
#   COMMIT_TAG, CONTEXT_PATH,
#   NEXUS_USER, NEXUS_PASS, RELEASE_REPO_URL, GROUP_ID, ARTIFACT_ID
#
# 내부 스크립트가 요구하는 추가 변수(함수에서 기본값 제공/전달):
#   WEBAPPS_ROOT=/opt/tomcat/webapps
#   RELEASES_BASE=/opt/tomcat/releases
#   ARTIFACTS_BASE=/opt/tomcat/artifacts
#   TOMCAT_SERVICE=tomcat
#   KEEP_RELEASES=15
#   HEALTH_MODE=page | actuator | none
#   HEALTH_URL_OVERRIDE=""
#   HEALTHCHECK_TIMEOUT=60
#   HEALTHCHECK_INTERVAL=2
#   HOT_RELOAD=false
#   DEPLOY_USER=""
#   DEPLOY_PASS=""
#   WAS_URL=127.0.0.1:8080
#
# SSH 접속후 실행되는 REMOTE_SH 의 주요 디렉토리 정리 
#   LIVE_LINK : /opt/tomcat/webapps/<context>
#    - Tomcat이 실제 서비스로 사용하는 경로 (항상 이 링크를 바라봄)
#    - diff 배포 후 여기의 심링크가 TARGET 으로 교체됨
#
#   BASE_DIR : LIVE_LINK 이 가리키는 실제 디렉터리 경로
#    - diff 비교의 기준(old)으로 사용됨
#    - 이전 버전의 배포본
#
#   TARGET : /opt/tomcat/releases/<app>/diff-<app>-<ver>-<ts>
#    - 새로 배포될 버전 (NEW 기준으로 변경/삭제 반영 후 LIVE 로 전환)
#    - 배포 완료 후 LIVE_LINK → TARGET 으로 심링크 변경
#
#   NEW_DIR : /opt/tomcat/artifacts/<app>/<app>-<ver>
#    - Nexus에서 WAR를 받아 unzip한 결과물
#    - diff 비교의 기준(new)으로 사용
#
#   APP_RELEASES_DIR: /opt/tomcat/releases/<app>
#    - 모든 diff-* 스냅샷(TARGET/BASE) 저장소
#    - prune_releases()가 KEEP_RELEASES 기준으로 오래된 버전 정리
#
#   ARTIFACTS_BASE : /opt/tomcat/artifacts
#    - NEW_DIR들이 모여있는 워크 디렉터리
#    - 용량 관리 필요(장기 보존 불필요)
#
#   REMOTE_DIR : /tmp/gitlab-build-$CI_PIPELINE_ID
#    - 원격 임시 작업 디렉터리 (SSH 배포 시 임시 ZIP·로그 보관)
#    - Runner 수집 후 삭제 가능
#
#   _logs (LOG_DIR) : <TARGET>/_logs
#    - diff 결과 및 메타데이터 기록
#     · diff-base.env         : BASE_DIR 정보
#     · changed-files.txt     : 변경 목록
#     · deleted-files.txt     : 삭제 목록
#     · live-pointer.env      : CURRENT / PREV 릴리스 포인터
#    - 첫 배포(비교 대상 없음) 시 생성 생략 가능
#
# 주의사항(코드 반영됨):
#   - 모든 파일 생성/이동/삭제/링크는 sudo 사용.
#   - rsync 비교·복사 시 _logs/** 및 잡파일을 제외하여 노이즈/재배포를 방지.
#   - ln -sT + mv -Tf 조합으로 원자적 전환, 실패 시 rm → mv 폴백 처리.
#   - NEW_DIR 자동 생성 실패 시(다운로드/무결성 에러/디스크 부족) 즉시 실패(fail-fast).
# ───────────────────────────────────────────────────────────────────────────────
.fn_tomcat_diff_deploy2:
  script: |
    fn_tomcat_diff_deploy() {
      set -eu

      # ── 필수 입력 ─────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${ARTIFACT_USER:?ARTIFACT_USER is required}"
      : "${ARTIFACT_GROUP:?ARTIFACT_GROUP is required}"       

      # ── 선택 입력(기본값) ───────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      artifacts_base="${TOMCAT_ARTIFACTS_DIR:-/opt/tomcat/artifacts}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"
      keep_releases="${KEEP_RELEASES:-15}"

      # 헬스체크
      health_mode="${HEALTH_MODE:-page}"           # actuator|page|none
      health_url_override="${HEALTH_URL_OVERRIDE:-}"
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      # Tomcat manager(핫리로드)
      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"
      was_url="${WAS_URL:-127.0.0.1:8080}"

      auto_fetch_on_missing="true"                 # NEW_DIR 없으면 Nexus에서 내려받아 생성

      # GitLab 산출물 파일명(로컬 Runner 수집용)
      deploy_log_name="deploy.log"                 # 산출물로 복사되는 이름

      # [ADD] 프리뷰 필터 모드(선택). "static"|"dynamic"|"none"
      SAFE_FILTER_MODE="${SAFE_FILTER_MODE:-static}"

      # ── 유틸 ─────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      #──────────────────────────── 
      # fetch_base_commit_from_remote_live
      #
      # 목적:
      #   - 원격 서버의 LIVE 심링크 또는 디렉터리가 가리키는 현재 버전의
      #     _logs/commit.log 에서 COMMIT 값을 읽어 BASE_COMMIT 변수로 설정
      #
      # 동작 개요:
      #   1. SSH로 원격 접속하여 LIVE 실경로 확인 (readlink -f)
      #   2. commit.log 존재 시 COMMIT= 값 추출
      #   3. 성공 시 BASE_COMMIT 환경 변수로 export
      #───────────────────────────────────────────── 
      fetch_base_commit_from_remote_live() {
        : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
        : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

        if [ -n "${BASE_COMMIT:-}" ]; then
          log "[INFO] BASE_COMMIT 설정됨 → live 에서 읽기 생략"
          return 0
        fi

        local remote_port="${REMOTE_DEPLOY_PORT:-22}"
        local webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
        local app_name="${CONTEXT_PATH#/}"
        local live_link="${webapps_root%/}/${app_name}"
        local prev_commit=""

        log "[SSH] 원격 LIVE commit.log 조회 중: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"

        prev_commit="$(
          ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
            "LIVE='$live_link';
             if sudo test -L \"\$LIVE\"; then REAL=\$(sudo readlink -f \"\$LIVE\" 2>/dev/null || true);
             elif sudo test -d \"\$LIVE\"; then REAL=\"\$LIVE\"; 
             else REAL=\"\"; fi;
             if [ -n \"\$REAL\" ] && sudo test -f \"\$REAL/_logs/commit.log\"; then
               sudo awk -F= '/^COMMIT=/{print \$2}' \"\$REAL/_logs/commit.log\" | tr -d '\r';
             fi" 2>/dev/null || true
        )"

        if [ -n "$prev_commit" ]; then
          export BASE_COMMIT="$prev_commit"
          log "[OK] BASE_COMMIT(from remote LIVE): $BASE_COMMIT"
        else
          log "[WARN] 원격 LIVE commit.log 없음 → BASE_COMMIT 미설정"
        fi
      }

      
      #######################################################################
      # 함수: build_predicted_list_b64
      # 목적:
      #   - 로컬 git diff 결과를 WAR 내부 배치 경로로 매핑하여
      #     "예상 변경 목록(predicted.list)"을 생성하고 base64로 인코딩한다.
      #   - 생성된 base64 문자열은 전역 변수 PREDICTED_LIST_B64에 담긴다.
      #
      # 동작:
      #   1) HEAD_REF: 현재 커밋(HEAD)
      #   2) BASE_COMMIT: 입력 없으면 HEAD 바로 이전(HEAD~1)
      #   3) git diff --name-status BASE..HEAD
      #   4) 경로 매핑 규칙 (WAR 기준):
      #        - src/main/java/**.java      -> WEB-INF/classes/**.class
      #        - src/main/resources/**      -> WEB-INF/classes/**
      #        - src/main/webapp/**         -> (루트 그대로)
      #
      # 비고:
      #   - 컨테이너에 git이 없거나 .git이 없으면 자동 스킵(배포엔 영향 없음)
      #   - BASE_COMMIT/HEAD_REF 중 하나라도 비면 스킵
      #######################################################################
      build_predicted_list_b64() {
        PREDICTED_LIST_B64=""

        # git 미탑재 또는 .git 없음 → 스킵
        if ! command -v git >/dev/null 2>&1; then
          log "git 미탑재: git diff 기반 예상 목록 생략"
          return 0
        fi
        if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          log ".git 없음: git diff 기반 예상 목록 생략"
          return 0
        fi

        # HEAD(현재 커밋)
        local head_ref
        head_ref="$(git rev-parse --verify HEAD 2>/dev/null || true)"

        # BASE(입력값 우선, 없으면 HEAD~1)
        local base_ref_input base_ref
        base_ref_input="${BASE_COMMIT:-}"
        if [ -n "$base_ref_input" ]; then
          base_ref="$base_ref_input"
        else
          base_ref="$(git rev-parse --verify HEAD~1 2>/dev/null || true)"
        fi

        # 하나라도 비면 스킵
        if [ -z "$head_ref" ] || [ -z "$base_ref" ]; then
          log "git rev-parse 실패: HEAD=$head_ref BASE=$base_ref (예상 목록 생략)"
          return 0
        fi

        # 변경 목록 추출 및 WAR 경로로 매핑
        local tmpd
        tmpd="$(mktemp -d)"
        # shellcheck disable=SC2064
        trap "rm -rf '$tmpd'" EXIT

        git diff --name-status "$base_ref" "$head_ref" > "$tmpd/changed.tab" || true
        : > "$tmpd/predicted.list"

        # name-status 형식: <status>\t<path>
        # status 값은 사용하지 않고 path만으로 매핑
        while IFS=$'\t' read -r _status path || [ -n "${path:-}" ]; do
          case "$path" in
            src/main/java/*)
              # 예: src/main/java/a/b/C.java -> WEB-INF/classes/a/b/C.class
              base="${path#src/main/java/}"
              base="${base%.java}"
              printf 'WEB-INF/classes/%s.class\n' "$base" >> "$tmpd/predicted.list"
              ;;
            src/main/resources/*)
              # 리소스는 classes 루트로 그대로
              rel="${path#src/main/resources/}"
              printf 'WEB-INF/classes/%s\n' "$rel" >> "$tmpd/predicted.list"
              ;;
            src/main/webapp/*)
              # webapp 정적 리소스는 WAR 루트로
              printf '%s\n' "${path#src/main/webapp/}" >> "$tmpd/predicted.list"
              ;;
            *) :;;
          esac
        done < "$tmpd/changed.tab"

        sort -u "$tmpd/predicted.list" -o "$tmpd/predicted.list"

        # base64 인코딩 (GNU/BSD 차이 고려)
        if command -v base64 >/dev/null 2>&1; then
          if base64 --help 2>&1 | grep -q -- '-w'; then
            PREDICTED_LIST_B64="$(base64 -w0 "$tmpd/predicted.list" || true)"
          else
            PREDICTED_LIST_B64="$(base64 < "$tmpd/predicted.list" | tr -d '\n' || true)"
          fi
        fi
      }

      # [ADD-commit.log] 원격 LIVE에서 BASE_COMMIT 확보(있으면 skip)
      fetch_base_commit_from_remote_live
      
      #  로컬 git diff 예측 리스트 생성
      build_predicted_list_b64

      # [ADD-commit.log] 현재 커밋 SHA 계산(원격 commit.log에 기록용)
      if [ -n "${CI_COMMIT_SHA:-}" ]; then
        CURRENT_COMMIT_SHA="$CI_COMMIT_SHA"
      elif command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        CURRENT_COMMIT_SHA="$(git rev-parse --verify HEAD 2>/dev/null || echo "")"
      else
        CURRENT_COMMIT_SHA=""
      fi

      remote_script=$(mktemp /tmp/remote_diff_deploy.XXXXXX)
      log "Created temporary diff deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'

      #!/usr/bin/env bash
      set -eu

      # ───────────────────────────────────────────────
      # 공통 유틸 함수
      # ───────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }
      restorecon_if_available() {
        local p="$1"
        if command -v restorecon >/dev/null 2>&1; then
          sudo restorecon -R "$p" >/dev/null 2>&1 || true
        fi
      }

      # 파일 타입 검사 도우미
      is_link() { sudo test -L "$1"; }
      is_dir()  { sudo test -d "$1"; }
      is_any()  { sudo test -e "$1" || sudo test -L "$1"; }

      # ───────────────────────────────────────────────
      # require_envs()
      # 환경 변수 필수값 확인
      # ───────────────────────────────────────────────
      require_envs() {
        : "${REMOTE_DIR:?REMOTE_DIR is required}"
        : "${COMMIT_TAG:?COMMIT_TAG is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
        : "${WEBAPPS_ROOT:?WEBAPPS_ROOT is required}"
        : "${RELEASES_BASE:?RELEASES_BASE is required}"
        : "${ARTIFACTS_BASE:?ARTIFACTS_BASE is required}"
        : "${TOMCAT_SERVICE:?TOMCAT_SERVICE is required}"
        : "${KEEP_RELEASES:?KEEP_RELEASES is required}"
        : "${HEALTH_MODE:?HEALTH_MODE is required}"
        : "${HC_TIMEOUT:?HC_TIMEOUT is required}"
        : "${HC_INTERVAL:?HC_INTERVAL is required}"
        : "${NEXUS_USER:?NEXUS_USER is required}"
        : "${NEXUS_PASS:?NEXUS_PASS is required}"
        : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
        : "${GROUP_ID:?GROUP_ID is required}"
        : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
        : "${SAFE_FILTER_MODE:-static}"
        : "${CURRENT_COMMIT_SHA:=}"
        : "${BASE_COMMIT:=}"
        : "${ARTIFACT_USER:?ARTIFACT_USER is required}"
        : "${ARTIFACT_GROUP:?ARTIFACT_GROUP is required}"
      }

      # ───────────────────────────────────────────────
      # ensure_tools()
      # 필수 도구 설치 확인 (rsync, unzip 등)
      # ───────────────────────────────────────────────
      ensure_tools() {
        for t in rsync ln readlink zip awk sed grep sort uniq curl unzip mktemp df ls tee realpath base64; do
          if ! need "$t"; then
            if   need apk; then
              sudo apk add --no-cache coreutils "$t" || true
            elif need apt-get; then
              sudo apt-get update -y && sudo apt-get install -y "$t" || true
            elif need dnf; then
              sudo dnf install -y "$t" || true
            fi
          fi
        done
      }

      # ───────────────────────────────────────────────
      # setup_context()
      # 디렉터리 및 배포 경로 설정
      # ───────────────────────────────────────────────
      setup_context() {
        APP_NAME="${CONTEXT_PATH#/}"
        DEPLOY_VERSION="${COMMIT_TAG#v}"

        LIVE_LINK="${WEBAPPS_ROOT%/}/$APP_NAME"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/$APP_NAME"
        NEW_DIR="${ARTIFACTS_BASE%/}/$APP_NAME/$APP_NAME-$DEPLOY_VERSION"

        ART_DIR="$REMOTE_DIR/artifacts"
        OUT_ZIP="$ART_DIR/diff-deploy-artifacts.zip"

        #uid="$(id -u)"; gid="$(id -g)"
        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
        #sudo chown -R "$uid:$gid" "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
      }

      # ───────────────────────────────────────────────
      # maybe_fetch_new_dir()
      # NEW_DIR이 없을 경우 Nexus에서 WAR 자동 다운로드 및 unzip
      # ───────────────────────────────────────────────
      maybe_fetch_new_dir() {
        if [ -d "$NEW_DIR" ]; then
          log "기존 NEW_DIR 사용: $NEW_DIR"
          return
        fi
        log "NEW_DIR 없음 → Nexus에서 자동 생성"
        APP_PATH="${GROUP_ID//.//}/${ARTIFACT_ID}/${DEPLOY_VERSION}"
        NEW_WAR="${ARTIFACT_ID}-${DEPLOY_VERSION}.war"
        NEW_URL="${RELEASE_REPO_URL%/}/${APP_PATH}/${NEW_WAR}"
        TMP_DIR=$(sudo mktemp -d /tmp/${APP_NAME}-${DEPLOY_VERSION}-fetch.XXXXXX)

        sudo curl -fsSL -u "$NEXUS_USER:$NEXUS_PASS" -o "$TMP_DIR/$NEW_WAR" "$NEW_URL"
        sudo unzip -q "$TMP_DIR/$NEW_WAR" -d "$TMP_DIR/unzip"
        sudo test -d "$TMP_DIR/unzip/WEB-INF" || fail "WAR 구조 이상"
        sudo mkdir -p "$(dirname "$NEW_DIR")"
        sudo rm -rf "$NEW_DIR"
        sudo mv "$TMP_DIR/unzip" "$NEW_DIR"
        sudo rm -rf "$TMP_DIR"
        ok "NEW_DIR 생성 완료: $NEW_DIR"
      }

      # ───────────────────────────────────────────────
      # resolve_base_from_live()
      # LIVE 심볼릭 링크에서 BASE_DIR 추출 또는 초기화
      # ───────────────────────────────────────────────
      resolve_base_from_live() {
        prev_target=""
        if is_link "$LIVE_LINK"; then
          prev_target="$(sudo readlink -f "$LIVE_LINK" || true)"
        elif is_dir "$LIVE_LINK"; then
          seed="${APP_RELEASES_DIR}/diff-legacy-backup-$(ts)"
          log "LIVE_DIR 기반 초기 백업 생성 → $seed"
          sudo rsync -rlpgoDc --delete --exclude='_logs/**' "${LIVE_LINK%/}/" "${seed%/}/" || true
          prev_target="$seed"

          log "LIVE_DIR 제거 후 seed로 심링크 전환"
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo ln -sT "$seed" "$LIVE_LINK" || true
        else
          log "LIVE_LINK가 없음 → 신규 서비스로 간주, 초기화 모드 실행"
          seed="${APP_RELEASES_DIR}/diff-initial-${APP_NAME}-$(ts)"
          sudo mkdir -p "$seed"
          sudo cp -a "${NEW_DIR%/}/." "$seed/"
          prev_target="$seed"
          sudo ln -sT "$seed" "$LIVE_LINK"

          ok "신규 서비스 초기화 완료: $seed"
        fi

        BASE_DIR="$(sudo readlink -f "$LIVE_LINK" || true)"
        [ -n "$BASE_DIR" ] || fail "BASE_DIR 확인 실패"
        [ -n "$prev_target" ] || prev_target="$BASE_DIR"
      }

      # ───────────────────────────────────────────────
      # prepare_target_from_prev()
      # 이전 릴리스 복제 후 TARGET 디렉터리 생성
      # ───────────────────────────────────────────────
      prepare_target_from_prev() {
        stamp="$(ts)"
        TARGET="${APP_RELEASES_DIR}/diff-${APP_NAME}-${DEPLOY_VERSION}-${stamp}"
        log "새 TARGET 생성: $TARGET"
        sudo mkdir -p "$TARGET"
        sudo rsync -rlpgoDc --delete  --exclude='_logs/**' "${prev_target%/}/" "${TARGET%/}/" || true

        LOG_DIR="${TARGET%/}/_logs"
        sudo rm -rf "$LOG_DIR"
        sudo mkdir -p "$LOG_DIR" 

        DIFF_BASE_FILE="$LOG_DIR/diff-base.env"
        LIVE_POINTER_FILE="$LOG_DIR/live-pointer.env"
        CHANGED_LIST="$LOG_DIR/changed-files.txt"
        DELETE_LIST="$LOG_DIR/deleted-files.txt"
        : > "$CHANGED_LIST"; : > "$DELETE_LIST"
        printf 'BASE_DIR=%s\n' "$BASE_DIR" > "$DIFF_BASE_FILE"

        # [ADD] 프리뷰/비교 산출물 경로
        RSYNC_FILTER="$LOG_DIR/rsync.filter"
        RSYNC_RAW_OUT="$LOG_DIR/rsync.out"
        RSYNC_PATHS="$LOG_DIR/rsync.paths"
        REPORT_TXT="$LOG_DIR/report.txt"

        # [ADD] 로컬에서 전달된 git 예측 리스트 복원
        if [ -n "${PREDICTED_LIST_B64:-}" ]; then
          echo "$PREDICTED_LIST_B64" | base64 -d > "$LOG_DIR/predicted.list" || true
        else
          : > "$LOG_DIR/predicted.list"
        fi
      }

      # ───────────────────────────────────────────────
      # [ADD] 필터 생성 (SAFE_FILTER_MODE=static|dynamic|none)
      # ───────────────────────────────────────────────
      make_filter_if_enabled() {
        case "${SAFE_FILTER_MODE:-static}" in
          none|"") return 0 ;;
          static)
            sudo printf '%s\n' \
            '+ /WEB-INF/classes/***' \
            '+ /WEB-INF/lib/***' \
            '+ *.jsp' \
            '+ *.jspf' \
            '+ *.jspx' \
            '+ *.tag' \
            '+ *.tagx' \
            '+ *.tld' \
            '+ /WEB-INF/**/*.jsp' \
            '+ /WEB-INF/**/*.jspf' \
            '+ /WEB-INF/**/*.jspx' \
            '+ /WEB-INF/**/*.tag' \
            '+ /WEB-INF/**/*.tagx' \
            '+ /WEB-INF/**/*.tld' \
            '+ *.html' \
            '+ *.htm' \
            '+ *.css' \
            '+ *.js' \
            '+ *.png' \
            '+ *.jpg' \
            '+ *.jpeg' \
            '+ *.gif' \
            '+ *.svg' \
            '+ *.webp' \
            '+ favicon.ico' \
            '+ *.xml' \
            '+ *.properties' \
            '+ *.yml' \
            '+ *.yaml' \
            '+ MANIFEST.MF' \
            '+ /META-INF/resources/***' \
            '- *' \
            | sudo tee "$RSYNC_FILTER" >/dev/null
            ;;
          dynamic)
            sudo printf '%s\n' \
            '+ /WEB-INF/classes/***' \
            '+ /WEB-INF/lib/***' \
            '+ /META-INF/***' \
            '+ /BOOT-INF/***' \
            '+ /static/***' \
            '+ /public/***' \
            '+ /assets/***' \
            '+ /resources/***' \
            '+ *.css' \
            '+ *.js' \
            '+ *.mjs' \
            '+ *.map' \
            '+ *.json' \
            '+ *.html' \
            '+ *.htm' \
            '+ *.png' \
            '+ *.jpg' \
            '+ *.jpeg' \
            '+ *.gif' \
            '+ *.svg' \
            '+ *.webp' \
            '+ *.jsp' \
            '+ *.jspf' \
            '+ *.jspx' \
            '+ *.tag' \
            '+ *.tagx' \
            '+ *.tld' \
            '+ *.xhtml' \
            '+ /WEB-INF/**/*.jsp' \
            '+ /WEB-INF/**/*.jspf' \
            '+ /WEB-INF/**/*.jspx' \
            '+ /WEB-INF/**/*.tag' \
            '+ /WEB-INF/**/*.tagx' \
            '+ /WEB-INF/**/*.tld' \
            '+ /WEB-INF/**/*.xhtml' \
            '+ *.xml' \
            '+ *.properties' \
            '+ *.yml' \
            '+ *.yaml' \
            '+ *.ini' \
            '+ *.conf' \
            '+ *.cfg' \
            '+ *.env' \
            '+ *.txt' \
            '+ *.csv' \
            '+ *.tsv' \
            '+ *.json5' \
            '+ *.ftl' \
            '+ *.vm' \
            '+ *.mustache' \
            '+ *.hbs' \
            '+ /templates/***' \
            '+ /views/***' \
            '+ MANIFEST.MF' \
            '+ application.properties' \
            '+ application.yml' \
            '+ application.yaml' \
            '+ logback*.xml' \
            '+ logging*.xml' \
            '+ context*.xml' \
            '+ web.xml' \
            '+ robots.txt' \
            '+ sitemap.xml' \
            '+ favicon.ico' \
            '+ .well-known/***' \
            '+ /META-INF/resources/***' \
            '- *' \
            | sudo tee "$RSYNC_FILTER" >/dev/null
            ;;
          *) :;;
        esac
      }

      # ───────────────────────────────────────────────
      # compute_diff_lists()
      # rsync dry-run 결과를 기반으로 변경/삭제 파일 목록 계산
      # ───────────────────────────────────────────────
      compute_diff_lists() {
        log "Rsync dry-run 실행 중 (NEW vs BASE)"

        make_filter_if_enabled

        # 공통 exclude (로그/임시파일 등)
        common_excludes=(--exclude='_logs' --exclude='_logs/**' \
                         --exclude='*.bad' --exclude='*.tmp' --exclude='*.bak' \
                         --exclude='*.swp' --exclude='*.log')

        # [KEEP] 필터 있으면 merge 사용
        if [ -f "$RSYNC_FILTER" ]; then
          sudo rsync -rlDic --delete --dry-run --out-format='%i %n' \
            --filter="merge $RSYNC_FILTER" \
            "${common_excludes[@]}" \
            "${NEW_DIR%/}/" "${BASE_DIR%/}/" | tee "$RSYNC_RAW_OUT" >/dev/null
        else
          sudo rsync -rlDic --delete --dry-run --out-format='%i %n' \
            "${common_excludes[@]}" \
            "${NEW_DIR%/}/" "${BASE_DIR%/}/" | tee "$RSYNC_RAW_OUT" >/dev/null
        fi

        # 경로만 추출(디렉터리 제거) → rsync.paths
        awk '{sub(/^[^ ]+[ ]+/,""); print}' "$RSYNC_RAW_OUT" \
          | sed -e 's#^\.\/##' -e '/\/$/d' \
          | sort -u > "$RSYNC_PATHS" || true

        # 삭제/변경 파일 목록 산출 (파일 기준)
        > "$CHANGED_LIST"; > "$DELETE_LIST"
        while IFS= read -r ln; do
          # 삭제
          if [[ "$ln" == *"deleting "* ]]; then
            f="${ln#*deleting }"
            echo "$f" >> "$DELETE_LIST"
            continue
          fi
          # 코드 / 경로 분리
          code="${ln%% *}"
          f="${ln#* }"
          [[ "$f" == */ ]] && continue
          # 파일 전송/생성/속성변경 포함
          case "$code" in
            ">f"*)         echo "$f" >> "$CHANGED_LIST" ;;  # 새로 전송된 파일
            ".f"*)         echo "$f" >> "$CHANGED_LIST" ;;  # 파일 속성만 변경
            c[fps]*)       echo "$f" >> "$CHANGED_LIST" ;;  # 생성/특수 케이스(cf, cp, cs 등)
            *)             : ;;
          esac
        done < "$RSYNC_RAW_OUT"

        # [ADD] git 예상 vs rsync 결과 교차 비교
        if [ -s "$LOG_DIR/predicted.list" ]; then
          sort -u "$LOG_DIR/predicted.list" -o "$LOG_DIR/predicted.list"
          comm -12 "$LOG_DIR/predicted.list" "$RSYNC_PATHS" > "$LOG_DIR/intersection.txt" || true
          comm -23 "$LOG_DIR/predicted.list" "$RSYNC_PATHS" > "$LOG_DIR/missing.from.rsync.txt" || true
          comm -13 "$LOG_DIR/predicted.list" "$RSYNC_PATHS" > "$LOG_DIR/extra.in.rsync.txt" || true
        else
          : > "$LOG_DIR/intersection.txt"
          : > "$LOG_DIR/missing.from.rsync.txt"
          : > "$LOG_DIR/extra.in.rsync.txt"
        fi

        # [ADD] 프리뷰 리포트 출력 (_logs/report.txt)
        {
          echo "=== Diff Deploy Preview Report ==="
          echo "Version   : $DEPLOY_VERSION"
          echo "Context   : $APP_NAME"
          echo "Base Dir  : $BASE_DIR"
          echo "New Dir   : $NEW_DIR"
          echo "Filter    : ${SAFE_FILTER_MODE:-static}"
          echo
          echo "[GIT DIFF 예상 변경 개수]"
          (wc -l < "$LOG_DIR/predicted.list") 2>/dev/null || echo 0
          head -30 "$LOG_DIR/predicted.list" 2>/dev/null || true
          echo
          echo "[rsync --dry-run 파일 변경 개수]"
          (wc -l < "$RSYNC_PATHS") 2>/dev/null || echo 0
          head -30 "$RSYNC_PATHS" 2>/dev/null || true
          echo
          echo "[교집합] git 예상 ∩ rsync"
          head -30 "$LOG_DIR/intersection.txt" 2>/dev/null || true
          echo
          echo "[MISSING] git 변경에는 있지만 rsync 없음"
          head -30 "$LOG_DIR/missing.from.rsync.txt" 2>/dev/null || true
          echo
          echo "[EXTRA] rsync에는 있지만 예상에 없음"
          head -30 "$LOG_DIR/extra.in.rsync.txt" 2>/dev/null || true
          echo
          echo "[삭제 건수]"
          (wc -l < "$DELETE_LIST") 2>/dev/null || echo 0
          echo "[변경/생성 건수]"
          (wc -l < "$CHANGED_LIST") 2>/dev/null || echo 0
        } > "$REPORT_TXT" || true
        log "프리뷰 리포트: $REPORT_TXT"
      }

      # ───────────────────────────────────────────────
      # apply_deletions()
      # DELETE_LIST 기반 안전 삭제 (심볼릭 링크는 링크 자체만 제거)
      # ───────────────────────────────────────────────
      apply_deletions() {
        local target="$1" list="$2"
        rp_tgt="$(realpath -m -- "$target")"
        pushd "$rp_tgt" >/dev/null
        while IFS= read -r rel || [[ -n "${rel:-}" ]]; do
          [[ -z "$rel" ]] && continue
          if [[ "$rel" = /* || "$rel" = *".."* ]]; then
            echo "[SKIP] 위험 경로: $rel"
            continue
          fi
          if [[ -L "$rel" ]]; then
            echo "[DEL] (symlink) $rel"
            sudo rm -f -- "$rel"
          elif [[ -e "$rel" ]]; then
            echo "[DEL] $rel"
            sudo rm -rf --one-file-system -- "$rel"
          fi
        done < "$list"
        popd >/dev/null
      }

      # ───────────────────────────────────────────────
      # apply_changes()
      # CHANGED_LIST 기반으로 변경 파일만 복사
      # ───────────────────────────────────────────────
      apply_changes() {
        if [ -s "$CHANGED_LIST" ]; then
          # # [FIX] 내용만 갱신하고, 기존 소유자/그룹/권한은 유지 (-o -g -p 제거)
          sudo rsync -rlDic --files-from="$CHANGED_LIST" "${NEW_DIR%/}/" "${TARGET%/}/"
        fi
      }

      # ───────────────────────────────────────────────
      # switch_live_symlink()
      # LIVE 심볼릭 링크를 새 TARGET으로 전환
      # ───────────────────────────────────────────────
      switch_live_symlink() {
        tmp_link="${LIVE_LINK}.new.$(ts)"
        sudo ln -sT "$TARGET" "$tmp_link" || sudo ln -s "$TARGET" "$tmp_link"
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || {
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo mv "$tmp_link" "$LIVE_LINK"
        }
        log "LIVE → $TARGET 전환 완료"
      }

      # ───────────────────────────────────────────────
      # update_live_pointer()
      # 심링크 교체후에 라이브 포인터 정보 재기록
      # ───────────────────────────────────────────────
      update_live_pointer() {
        local current="$TARGET"
        local prev="$prev_target"   # BASE_DIR로 기록하고 싶으면 prev="$BASE_DIR"
        sudo sh -c "printf 'CURRENT=%s\nPREV=%s\n' '$current' '${prev:-}' > '$TARGET/_logs/live-pointer.env'"
      }

      # ───────────────────────────────────────────────
      # reload_or_restart_tomcat()
      # Tomcat 핫리로드 or 재기동 처리
      # ───────────────────────────────────────────────
      reload_or_restart_tomcat() {
        if [ "$HOT_RELOAD" = "true" ] && [ -n "$DEPLOY_USER" ]; then
          sudo curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://$WAS_URL/manager/text/reload?path=/${APP_NAME}" || true
        else
          sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null || sudo systemctl restart "$TOMCAT_SERVICE"
        fi
      }

      # ───────────────────────────────────────────────
      # do_healthcheck()
      # 배포 후 서비스 정상 응답 확인
      # ───────────────────────────────────────────────
      do_healthcheck() {
        case "$HEALTH_MODE" in
          actuator) hc_url="http://127.0.0.1:8080/${APP_NAME}/actuator/health" ;;
          page)     hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
          none)     return ;;
          *)        hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
        esac

        elapsed=0
        while [ "$elapsed" -lt "$HC_TIMEOUT" ]; do
          if sudo curl -fsS --max-time 3 "$hc_url" >/dev/null 2>&1; then
            ok "헬스체크 성공: $hc_url"
            return
          fi
          sleep "$HC_INTERVAL"; elapsed=$((elapsed+HC_INTERVAL))
        done
        fail "헬스체크 실패: $hc_url"
      }

      # ───────────────────────────────────────────────
      # prune_releases()
      # KEEP_RELEASES 초과 버전 정리
      # ───────────────────────────────────────────────
      prune_releases() {
        mapfile -t snaps < <(sudo ls -1dt "${APP_RELEASES_DIR}/diff-${APP_NAME}-"* 2>/dev/null || true)
        if [ "${#snaps[@]}" -gt "$KEEP_RELEASES" ]; then
          for ((i=KEEP_RELEASES; i<${#snaps[@]}; i++)); do
            [ "${snaps[$i]}" = "$TARGET" ] && continue
            sudo rm -rf --one-file-system "${snaps[$i]}" || true
          done
        fi
      }

      # ───────────────────────────────────────────────
      # package_artifacts()
      # 로그, 목록 파일 등을 ZIP으로 압축
      # ───────────────────────────────────────────────
      package_artifacts() {
        sudo cp -f "$DIFF_BASE_FILE" "$ART_DIR/diff-base.env" || true
        sudo cp -f "$CHANGED_LIST" "$ART_DIR/changed-files.txt" || true
        sudo cp -f "$DELETE_LIST" "$ART_DIR/deleted-files.txt" || true
        # [ADD] 프리뷰 산출물도 같이 담기
        sudo cp -f "$RSYNC_RAW_OUT" "$ART_DIR/rsync.out" 2>/dev/null || true
        sudo cp -f "$RSYNC_PATHS" "$ART_DIR/rsync.paths" 2>/dev/null || true
        sudo cp -f "$REPORT_TXT" "$ART_DIR/report.txt" 2>/dev/null || true
        sudo cp -f "$RSYNC_FILTER" "$ART_DIR/rsync.filter" 2>/dev/null || true
        # [ADD] git diff 비교 산출물
        sudo cp -f "$LOG_DIR/predicted.list" "$ART_DIR/predicted.list" 2>/dev/null || true
        sudo cp -f "$LOG_DIR/intersection.txt" "$ART_DIR/intersection.txt" 2>/dev/null || true
        sudo cp -f "$LOG_DIR/missing.from.rsync.txt" "$ART_DIR/missing.from.rsync.txt" 2>/dev/null || true
        sudo cp -f "$LOG_DIR/extra.in.rsync.txt" "$ART_DIR/extra.in.rsync.txt" 2>/dev/null || true

        {
          echo "DEPLOYED_VERSION=$DEPLOY_VERSION"
          echo "LIVE_LINK=$LIVE_LINK"
          echo "TARGET=$TARGET"
          echo "BASE_DIR=$BASE_DIR"
        } > "$ART_DIR/.env"

        ( cd "$ART_DIR" && zip -r "$(basename "$OUT_ZIP")" .env *.txt rsync.* *.list >/dev/null 2>&1 || true )
        ok "배포 로그 ZIP 생성 완료"
        echo "$OUT_ZIP"
      }

      # [ADD-commit.log] ─────────────────────────────────────────────
      # ───────────────────────────────────────────────
      # [NEW] 함수: write_pre_deploy_commit_log_if_missing
      # 목적:
      #   - BASE_COMMIT 값이 있을 경우,
      #     LIVE 디렉터리에 commit.log가 없으면 자동으로 생성
      #   - 기존 commit.log가 있거나 BASE_COMMIT이 비어 있으면 아무 작업 안 함
      # ───────────────────────────────────────────────
      write_pre_deploy_commit_log_if_missing() {
        # BASE_COMMIT이 없으면 스킵
        if [ -z "${BASE_COMMIT:-}" ]; then
          log "[PRE-DEPLOY] BASE_COMMIT 미설정 → commit.log 기록 생략"
          return 0
        fi
      
        # LIVE 실경로 추적 (심링크 or 디렉터리)
        local live_real=""
        if sudo test -L "$LIVE_LINK"; then
          live_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        elif sudo test -d "$LIVE_LINK"; then
          live_real="$LIVE_LINK"
        fi
      
        # 유효한 LIVE가 없으면 스킵
        if [ -z "$live_real" ] || ! sudo test -d "$live_real"; then
          log "[PRE-DEPLOY] LIVE 디렉터리 없음 → commit.log 기록 생략"
          return 0
        fi
      
        # 이미 commit.log가 존재하면 스킵
        local logf="$live_real/_logs/commit.log"
        if sudo test -f "$logf"; then
          log "[PRE-DEPLOY] 기존 commit.log 존재 → skip ($logf)"
          return 0
        fi
      
        # 생성
        sudo mkdir -p "$live_real/_logs"
        sudo sh -c "printf 'COMMIT=%s\nDATE=%s\nNOTE=base_commit_predeploy\n' \
          \"$BASE_COMMIT\" \"\$(date -Iseconds)\" > '$logf'"
        log "[PRE-DEPLOY] commit.log 생성 완료: $logf (COMMIT=$BASE_COMMIT)"
      }
      
      write_commit_log() {
        # diff-deploy는 TARGET 디렉터리가 최종 LIVE가 됨
        local file="$TARGET/_logs/commit.log"
        sudo mkdir -p "$(dirname "$file")"
        sudo sh -c "printf 'COMMIT=%s\nTAG=%s\nVERSION=%s\nDATE=%s\n' \
          \"$CURRENT_COMMIT_SHA\" \"$COMMIT_TAG\" \"$DEPLOY_VERSION\" \"\$(date -Iseconds)\" > \"$file\""
        log "Wrote commit info to ${file}" 
      }

      # ────────────────────────────────────────────────

      main() {
        require_envs
        ensure_tools
        setup_context
        maybe_fetch_new_dir
        resolve_base_from_live
        write_pre_deploy_commit_log_if_missing      # [ADD-commit.log] 배포 전 보강
        prepare_target_from_prev
        compute_diff_lists
        apply_deletions "$TARGET" "$DELETE_LIST"
        apply_changes
        switch_live_symlink
        reload_or_restart_tomcat
        do_healthcheck
        update_live_pointer
        write_commit_log  # [ADD-commit.log] 배포 후 기록
        prune_releases
        package_artifacts
      }

      main "$@"

    REMOTE_SH

      log "▶ Executing diff deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "ARTIFACTS_BASE='$(shq "$artifacts_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "KEEP_RELEASES='$(shq "$keep_releases")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "WAS_URL='$(shq "$was_url")'" \
        "AUTO_FETCH_ON_MISSING='true'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "SAFE_FILTER_MODE='$(shq "$SAFE_FILTER_MODE")'" \
        "PREDICTED_LIST_B64='$(shq "$PREDICTED_LIST_B64")'" \
        "CURRENT_COMMIT_SHA='$(shq "${CURRENT_COMMIT_SHA:-}")'" \
        "BASE_COMMIT='$(shq "${BASE_COMMIT:-}")'" \
        "ARTIFACT_USER='$(shq "$ARTIFACT_USER")'" \
        "ARTIFACT_GROUP='$(shq "$ARTIFACT_GROUP")'" \
        'export REMOTE_DIR COMMIT_TAG CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE ARTIFACTS_BASE TOMCAT_SERVICE KEEP_RELEASES HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL HOT_RELOAD DEPLOY_USER DEPLOY_PASS WAS_URL AUTO_FETCH_ON_MISSING NEXUS_USER NEXUS_PASS RELEASE_REPO_URL GROUP_ID ARTIFACT_ID SAFE_FILTER_MODE PREDICTED_LIST_B64 CURRENT_COMMIT_SHA BASE_COMMIT ARTIFACT_USER ARTIFACT_GROUP; bash -s' \
        < "$remote_script" | tee /tmp/_diff_deploy_out.txt

      remote_zip_path="$(tail -n1 /tmp/_diff_deploy_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/diff-deploy-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_diff_deploy_out.txt || true
      ok "Diff deploy finished"
    }


.fn_tomcat_diff_deploy3:
  script: |
    fn_tomcat_diff_deploy() {
      set -eu

      # ── 필수 입력 ─────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${ARTIFACT_USER:?ARTIFACT_USER is required}"
      : "${ARTIFACT_GROUP:?ARTIFACT_GROUP is required}"       

      # ── 선택 입력(기본값) ───────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      artifacts_base="${TOMCAT_ARTIFACTS_DIR:-/opt/tomcat/artifacts}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"
      keep_releases="${KEEP_RELEASES:-15}"

      # 헬스체크
      health_mode="${HEALTH_MODE:-page}"           # actuator|page|none
      health_url_override="${HEALTH_URL_OVERRIDE:-}"
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      # Tomcat manager(핫리로드)
      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"
      was_url="${WAS_URL:-127.0.0.1:8080}"

      auto_fetch_on_missing="true"                 # NEW_DIR 없으면 Nexus에서 내려받아 생성

      # GitLab 산출물 파일명(로컬 Runner 수집용)
      deploy_log_name="deploy.log"                 # 산출물로 복사되는 이름

      # [ADD] 프리뷰 필터 모드(선택). "static"|"dynamic"|"none"
      SAFE_FILTER_MODE="${SAFE_FILTER_MODE:-static}"

      # ── 유틸 ─────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      #──────────────────────────── 
      # fetch_base_commit_from_remote_live
      #
      # 목적:
      #   - 원격 서버의 LIVE 심링크 또는 디렉터리가 가리키는 현재 버전의
      #     _logs/commit.log 에서 COMMIT 값을 읽어 BASE_COMMIT 변수로 설정
      #
      # 동작 개요:
      #   1. SSH로 원격 접속하여 LIVE 실경로 확인 (readlink -f)
      #   2. commit.log 존재 시 COMMIT= 값 추출
      #   3. 성공 시 BASE_COMMIT 환경 변수로 export
      #───────────────────────────────────────────── 
      fetch_base_commit_from_remote_live() {
        : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
        : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

        if [ -n "${BASE_COMMIT:-}" ]; then
          log "[INFO] BASE_COMMIT 설정됨 → live 에서 읽기 생략"
          return 0
        fi

        local remote_port="${REMOTE_DEPLOY_PORT:-22}"
        local webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
        local app_name="${CONTEXT_PATH#/}"
        local live_link="${webapps_root%/}/${app_name}"
        local prev_commit=""

        log "[SSH] 원격 LIVE commit.log 조회 중: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"

        prev_commit="$(
          ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
            "LIVE='$live_link';
             if sudo test -L \"\$LIVE\"; then REAL=\$(sudo readlink -f \"\$LIVE\" 2>/dev/null || true);
             elif sudo test -d \"\$LIVE\"; then REAL=\"\$LIVE\"; 
             else REAL=\"\"; fi;
             if [ -n \"\$REAL\" ] && sudo test -f \"\$REAL/_logs/commit.log\"; then
               sudo awk -F= '/^COMMIT=/{print \$2}' \"\$REAL/_logs/commit.log\" | tr -d '\r';
             fi" 2>/dev/null || true
        )"

        if [ -n "$prev_commit" ]; then
          export BASE_COMMIT="$prev_commit"
          log "[OK] BASE_COMMIT(from remote LIVE): $BASE_COMMIT"
        else
          log "[WARN] 원격 LIVE commit.log 없음 → BASE_COMMIT 미설정"
        fi
      }

      
      #######################################################################
      # 함수: build_predicted_list_b64
      # 목적:
      #   - 로컬 git diff 결과를 WAR 내부 배치 경로로 매핑하여
      #     "예상 변경 목록(predicted.list)"을 생성하고 base64로 인코딩한다.
      #   - 생성된 base64 문자열은 전역 변수 PREDICTED_LIST_B64에 담긴다.
      #
      # 동작:
      #   1) HEAD_REF: 현재 커밋(HEAD)
      #   2) BASE_COMMIT: 입력 없으면 HEAD 바로 이전(HEAD~1)
      #   3) git diff --name-status BASE..HEAD
      #   4) 경로 매핑 규칙 (WAR 기준):
      #        - src/main/java/**.java      -> WEB-INF/classes/**.class
      #        - src/main/resources/**      -> WEB-INF/classes/**
      #        - src/main/webapp/**         -> (루트 그대로)
      #
      # 비고:
      #   - 컨테이너에 git이 없거나 .git이 없으면 자동 스킵(배포엔 영향 없음)
      #   - BASE_COMMIT/HEAD_REF 중 하나라도 비면 스킵
      #######################################################################
      build_predicted_list_b64() {
        PREDICTED_LIST_B64=""

        # git 미탑재 또는 .git 없음 → 스킵
        if ! command -v git >/dev/null 2>&1; then
          log "git 미탑재: git diff 기반 예상 목록 생략"
          return 0
        fi
        if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          log ".git 없음: git diff 기반 예상 목록 생략"
          return 0
        fi

        # HEAD(현재 커밋)
        local head_ref
        head_ref="$(git rev-parse --verify HEAD 2>/dev/null || true)"

        # BASE(입력값 우선, 없으면 HEAD~1)
        local base_ref_input base_ref
        base_ref_input="${BASE_COMMIT:-}"
        if [ -n "$base_ref_input" ]; then
          base_ref="$base_ref_input"
        else
          base_ref="$(git rev-parse --verify HEAD~1 2>/dev/null || true)"
        fi

        # 하나라도 비면 스킵
        if [ -z "$head_ref" ] || [ -z "$base_ref" ]; then
          log "git rev-parse 실패: HEAD=$head_ref BASE=$base_ref (예상 목록 생략)"
          return 0
        fi

        # 변경 목록 추출 및 WAR 경로로 매핑
        local tmpd
        tmpd="$(mktemp -d)"
        # shellcheck disable=SC2064
        trap "rm -rf '$tmpd'" EXIT

        git diff --name-status "$base_ref" "$head_ref" > "$tmpd/changed.tab" || true
        : > "$tmpd/predicted.list"

        # name-status 형식: <status>\t<path>
        # status 값은 사용하지 않고 path만으로 매핑
        while IFS=$'\t' read -r _status path || [ -n "${path:-}" ]; do
          case "$path" in
            src/main/java/*)
              # 예: src/main/java/a/b/C.java -> WEB-INF/classes/a/b/C.class
              base="${path#src/main/java/}"
              base="${base%.java}"
              printf 'WEB-INF/classes/%s.class\n' "$base" >> "$tmpd/predicted.list"
              ;;
            src/main/resources/*)
              # 리소스는 classes 루트로 그대로
              rel="${path#src/main/resources/}"
              printf 'WEB-INF/classes/%s\n' "$rel" >> "$tmpd/predicted.list"
              ;;
            src/main/webapp/*)
              # webapp 정적 리소스는 WAR 루트로
              printf '%s\n' "${path#src/main/webapp/}" >> "$tmpd/predicted.list"
              ;;
            *) :;;
          esac
        done < "$tmpd/changed.tab"

        sort -u "$tmpd/predicted.list" -o "$tmpd/predicted.list"

        # base64 인코딩 (GNU/BSD 차이 고려)
        if command -v base64 >/dev/null 2>&1; then
          if base64 --help 2>&1 | grep -q -- '-w'; then
            PREDICTED_LIST_B64="$(base64 -w0 "$tmpd/predicted.list" || true)"
          else
            PREDICTED_LIST_B64="$(base64 < "$tmpd/predicted.list" | tr -d '\n' || true)"
          fi
        fi
      }

      # [ADD-commit.log] 원격 LIVE에서 BASE_COMMIT 확보(있으면 skip)
      fetch_base_commit_from_remote_live
      
      #  로컬 git diff 예측 리스트 생성
      build_predicted_list_b64

      # [ADD-commit.log] 현재 커밋 SHA 계산(원격 commit.log에 기록용)
      if [ -n "${CI_COMMIT_SHA:-}" ]; then
        CURRENT_COMMIT_SHA="$CI_COMMIT_SHA"
      elif command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        CURRENT_COMMIT_SHA="$(git rev-parse --verify HEAD 2>/dev/null || echo "")"
      else
        CURRENT_COMMIT_SHA=""
      fi

      remote_script=$(mktemp /tmp/remote_diff_deploy.XXXXXX)
      log "Created temporary diff deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'

      #!/usr/bin/env bash
      set -eu

      # ───────────────────────────────────────────────
      # 공통 유틸 함수
      # ───────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }
      restorecon_if_available() {
        local p="$1"
        if command -v restorecon >/dev/null 2>&1; then
          sudo restorecon -R "$p" >/dev/null 2>&1 || true
        fi
      }

      # 파일 타입 검사 도우미
      is_link() { sudo test -L "$1"; }
      is_dir()  { sudo test -d "$1"; }
      is_any()  { sudo test -e "$1" || sudo test -L "$1"; }

      # ───────────────────────────────────────────────
      # require_envs()
      # 환경 변수 필수값 확인
      # ───────────────────────────────────────────────
      require_envs() {
        : "${REMOTE_DIR:?REMOTE_DIR is required}"
        : "${COMMIT_TAG:?COMMIT_TAG is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
        : "${WEBAPPS_ROOT:?WEBAPPS_ROOT is required}"
        : "${RELEASES_BASE:?RELEASES_BASE is required}"
        : "${ARTIFACTS_BASE:?ARTIFACTS_BASE is required}"
        : "${TOMCAT_SERVICE:?TOMCAT_SERVICE is required}"
        : "${KEEP_RELEASES:?KEEP_RELEASES is required}"
        : "${HEALTH_MODE:?HEALTH_MODE is required}"
        : "${HC_TIMEOUT:?HC_TIMEOUT is required}"
        : "${HC_INTERVAL:?HC_INTERVAL is required}"
        : "${NEXUS_USER:?NEXUS_USER is required}"
        : "${NEXUS_PASS:?NEXUS_PASS is required}"
        : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
        : "${GROUP_ID:?GROUP_ID is required}"
        : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
        : "${SAFE_FILTER_MODE:-static}"
        : "${CURRENT_COMMIT_SHA:=}"
        : "${BASE_COMMIT:=}"
        : "${ARTIFACT_USER:?ARTIFACT_USER is required}"
        : "${ARTIFACT_GROUP:?ARTIFACT_GROUP is required}"
      }

      # ───────────────────────────────────────────────
      # ensure_tools()
      # 필수 도구 설치 확인 (rsync, unzip 등)
      # ───────────────────────────────────────────────
      ensure_tools() {
        for t in rsync ln readlink zip awk sed grep sort uniq curl unzip mktemp df ls tee realpath base64; do
          if ! need "$t"; then
            if   need apk; then
              sudo apk add --no-cache coreutils "$t" || true
            elif need apt-get; then
              sudo apt-get update -y && sudo apt-get install -y "$t" || true
            elif need dnf; then
              sudo dnf install -y "$t" || true
            fi
          fi
        done
      }

      # ───────────────────────────────────────────────
      # setup_context()
      # 디렉터리 및 배포 경로 설정
      # ───────────────────────────────────────────────
      setup_context() {
        APP_NAME="${CONTEXT_PATH#/}"
        DEPLOY_VERSION="${COMMIT_TAG#v}"

        LIVE_LINK="${WEBAPPS_ROOT%/}/$APP_NAME"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/$APP_NAME"
        NEW_DIR="${ARTIFACTS_BASE%/}/$APP_NAME/$APP_NAME-$DEPLOY_VERSION"

        ART_DIR="$REMOTE_DIR/artifacts"
        OUT_ZIP="$ART_DIR/diff-deploy-artifacts.zip"

        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
      }

      # ───────────────────────────────────────────────
      # maybe_fetch_new_dir()
      # NEW_DIR이 없을 경우 Nexus에서 WAR 자동 다운로드 및 unzip
      # ───────────────────────────────────────────────
      maybe_fetch_new_dir() {
        if [ -d "$NEW_DIR" ]; then
          log "기존 NEW_DIR 사용: $NEW_DIR"
          return
        fi
        log "NEW_DIR 없음 → Nexus에서 자동 생성"
        APP_PATH="${GROUP_ID//.//}/${ARTIFACT_ID}/${DEPLOY_VERSION}"
        NEW_WAR="${ARTIFACT_ID}-${DEPLOY_VERSION}.war"
        NEW_URL="${RELEASE_REPO_URL%/}/${APP_PATH}/${NEW_WAR}"
        TMP_DIR=$(sudo mktemp -d /tmp/${APP_NAME}-${DEPLOY_VERSION}-fetch.XXXXXX)

        sudo curl -fsSL -u "$NEXUS_USER:$NEXUS_PASS" -o "$TMP_DIR/$NEW_WAR" "$NEW_URL"
        sudo unzip -q "$TMP_DIR/$NEW_WAR" -d "$TMP_DIR/unzip"
        sudo test -d "$TMP_DIR/unzip/WEB-INF" || fail "WAR 구조 이상"
        sudo mkdir -p "$(dirname "$NEW_DIR")"
        sudo rm -rf "$NEW_DIR"
        sudo mv "$TMP_DIR/unzip" "$NEW_DIR"
        sudo rm -rf "$TMP_DIR"
        ok "NEW_DIR 생성 완료: $NEW_DIR"
      }

      # ───────────────────────────────────────────────
      # resolve_base_from_live()
      # LIVE 심볼릭 링크에서 BASE_DIR 추출 또는 초기화
      # ───────────────────────────────────────────────
      resolve_base_from_live() {
        prev_target=""
        if is_link "$LIVE_LINK"; then
          prev_target="$(sudo readlink -f "$LIVE_LINK" || true)"
        elif is_dir "$LIVE_LINK"; then
          seed="${APP_RELEASES_DIR}/diff-legacy-backup-$(ts)"
          log "LIVE_DIR 기반 초기 백업 생성 → $seed"
          sudo rsync -rlpgoDc --delete --exclude='_logs/**' "${LIVE_LINK%/}/" "${seed%/}/" || true
          prev_target="$seed"

          log "LIVE_DIR 제거 후 seed로 심링크 전환"
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo ln -sT "$seed" "$LIVE_LINK" || true
        else
          log "LIVE_LINK가 없음 → 신규 서비스로 간주, 초기화 모드 실행"
          seed="${APP_RELEASES_DIR}/diff-initial-${APP_NAME}-$(ts)"
          sudo mkdir -p "$seed"
          sudo cp -a "${NEW_DIR%/}/." "$seed/"
          prev_target="$seed"
          sudo ln -sT "$seed" "$LIVE_LINK"

          ok "신규 서비스 초기화 완료: $seed"
        fi

        BASE_DIR="$(sudo readlink -f "$LIVE_LINK" || true)"
        [ -n "$BASE_DIR" ] || fail "BASE_DIR 확인 실패"
        [ -n "$prev_target" ] || prev_target="$BASE_DIR"
      }

      # ───────────────────────────────────────────────
      # prepare_target_from_prev()
      # 이전 릴리스 복제 후 TARGET 디렉터리 생성
      # ───────────────────────────────────────────────
      prepare_target_from_prev() {
        stamp="$(ts)"
        TARGET="${APP_RELEASES_DIR}/diff-${APP_NAME}-${DEPLOY_VERSION}-${stamp}"
        log "새 TARGET 생성: $TARGET"

        # 러너 UID/GID (파일/디렉터리 소유권에 사용)
        RUN_UID="$ARTIFACT_USER"
        RUN_GID="$ARTIFACT_GROUP"

        # TARGET 만들고 이전 스냅샷 복사
        sudo mkdir -p "$TARGET"
        sudo rsync -rlpgoDc --delete --exclude='_logs/**' "${prev_target%/}/" "${TARGET%/}/" || true

        #  _logs 디렉터리 초기화 
        LOG_DIR="${TARGET%/}/_logs"
        sudo rm -rf "$LOG_DIR"
        sudo mkdir -p "$LOG_DIR"
        sudo chown "$RUN_UID:$RUN_GID" "$LOG_DIR"
        sudo chmod 0755 "$LOG_DIR"

        # 로그/산출물 파일 경로 정의
        DIFF_BASE_FILE="$LOG_DIR/diff-base.env"
        LIVE_POINTER_FILE="$LOG_DIR/live-pointer.env"
        CHANGED_LIST="$LOG_DIR/changed-files.txt"
        DELETE_LIST="$LOG_DIR/deleted-files.txt"
        RSYNC_FILTER="$LOG_DIR/rsync.filter"
        RSYNC_RAW_OUT="$LOG_DIR/rsync.out"
        RSYNC_PATHS="$LOG_DIR/rsync.paths"
        REPORT_TXT="$LOG_DIR/report.txt"
        PRED_LIST="$LOG_DIR/predicted.list"

        printf '' | tee "$CHANGED_LIST" >/dev/null
        printf '' | tee "$DELETE_LIST"  >/dev/null
        printf '' | tee "$DIFF_BASE_FILE" >/dev/null
        printf '' | tee "$RSYNC_FILTER" >/dev/null
        printf '' | tee "$RSYNC_RAW_OUT" >/dev/null
        printf '' | tee "$RSYNC_PATHS"   >/dev/null
        printf '' | tee "$REPORT_TXT"    >/dev/null
        printf '' | tee "$PRED_LIST"     >/dev/null

        sudo chmod 0755 "$CHANGED_LIST"
        sudo chmod 0755 "$DELETE_LIST"
        sudo chmod 0755 "$DIFF_BASE_FILE"
        sudo chmod 0755 "$RSYNC_FILTER"
        sudo chmod 0755 "$RSYNC_RAW_OUT"
        sudo chmod 0755 "$RSYNC_PATHS"
        sudo chmod 0755 "$REPORT_TXT"
        sudo chmod 0755 "$PRED_LIST"

        printf 'BASE_DIR=%s\n' "$(printf %s "$BASE_DIR")" | tee "$DIFF_BASE_FILE" >/dev/null

        if [ -n "${PREDICTED_LIST_B64:-}" ]; then
          echo "$PREDICTED_LIST_B64" | base64 -d | tee "$LOG_DIR/predicted.list" >/dev/null || true
        fi
      }

      # ───────────────────────────────────────────────
      # [ADD] 필터 생성 (SAFE_FILTER_MODE=static|dynamic|none)
      # ───────────────────────────────────────────────
      make_filter_if_enabled() {
        case "${SAFE_FILTER_MODE:-static}" in
          none|"") return 0 ;;
          static)
            sudo printf '%s\n' \
            '+ /WEB-INF/classes/***' \
            '+ /WEB-INF/lib/***' \
            '+ *.jsp' \
            '+ *.jspf' \
            '+ *.jspx' \
            '+ *.tag' \
            '+ *.tagx' \
            '+ *.tld' \
            '+ /WEB-INF/**/*.jsp' \
            '+ /WEB-INF/**/*.jspf' \
            '+ /WEB-INF/**/*.jspx' \
            '+ /WEB-INF/**/*.tag' \
            '+ /WEB-INF/**/*.tagx' \
            '+ /WEB-INF/**/*.tld' \
            '+ *.html' \
            '+ *.htm' \
            '+ *.css' \
            '+ *.js' \
            '+ *.png' \
            '+ *.jpg' \
            '+ *.jpeg' \
            '+ *.gif' \
            '+ *.svg' \
            '+ *.webp' \
            '+ favicon.ico' \
            '+ *.xml' \
            '+ *.properties' \
            '+ *.yml' \
            '+ *.yaml' \
            '+ MANIFEST.MF' \
            '+ /META-INF/resources/***' \
            '- *' \
            | sudo tee "$RSYNC_FILTER" >/dev/null
            ;;
          dynamic)
            sudo printf '%s\n' \
            '+ /WEB-INF/classes/***' \
            '+ /WEB-INF/lib/***' \
            '+ /META-INF/***' \
            '+ /BOOT-INF/***' \
            '+ /static/***' \
            '+ /public/***' \
            '+ /assets/***' \
            '+ /resources/***' \
            '+ *.css' \
            '+ *.js' \
            '+ *.mjs' \
            '+ *.map' \
            '+ *.json' \
            '+ *.html' \
            '+ *.htm' \
            '+ *.png' \
            '+ *.jpg' \
            '+ *.jpeg' \
            '+ *.gif' \
            '+ *.svg' \
            '+ *.webp' \
            '+ *.jsp' \
            '+ *.jspf' \
            '+ *.jspx' \
            '+ *.tag' \
            '+ *.tagx' \
            '+ *.tld' \
            '+ *.xhtml' \
            '+ /WEB-INF/**/*.jsp' \
            '+ /WEB-INF/**/*.jspf' \
            '+ /WEB-INF/**/*.jspx' \
            '+ /WEB-INF/**/*.tag' \
            '+ /WEB-INF/**/*.tagx' \
            '+ /WEB-INF/**/*.tld' \
            '+ /WEB-INF/**/*.xhtml' \
            '+ *.xml' \
            '+ *.properties' \
            '+ *.yml' \
            '+ *.yaml' \
            '+ *.ini' \
            '+ *.conf' \
            '+ *.cfg' \
            '+ *.env' \
            '+ *.txt' \
            '+ *.csv' \
            '+ *.tsv' \
            '+ *.json5' \
            '+ *.ftl' \
            '+ *.vm' \
            '+ *.mustache' \
            '+ *.hbs' \
            '+ /templates/***' \
            '+ /views/***' \
            '+ MANIFEST.MF' \
            '+ application.properties' \
            '+ application.yml' \
            '+ application.yaml' \
            '+ logback*.xml' \
            '+ logging*.xml' \
            '+ context*.xml' \
            '+ web.xml' \
            '+ robots.txt' \
            '+ sitemap.xml' \
            '+ favicon.ico' \
            '+ .well-known/***' \
            '+ /META-INF/resources/***' \
            '- *' \
            | sudo tee "$RSYNC_FILTER" >/dev/null
            ;;
          *) :;;
        esac
      }

      # ───────────────────────────────────────────────
      # compute_diff_lists()
      # rsync dry-run 결과를 기반으로 변경/삭제 파일 목록 계산
      # ───────────────────────────────────────────────
      compute_diff_lists() {
        log "Rsync dry-run 실행 중 (NEW vs BASE)"
      
        make_filter_if_enabled
      
        # 공통 exclude (로그/임시파일 등)
        common_excludes=(--exclude='_logs' --exclude='_logs/**' \
                         --exclude='*.bad' --exclude='*.tmp' --exclude='*.bak' \
                         --exclude='*.swp' --exclude='*.log')
      
        # rsync dry-run → RAW_OUT (읽기는 sudo, 쓰기는 러너 소유/권한으로 tee)
        if [ -f "$RSYNC_FILTER" ]; then
          sudo rsync -rlDic --delete --dry-run --out-format='%i %n' \
            --filter="merge $RSYNC_FILTER" \
            "${common_excludes[@]}" \
            "${NEW_DIR%/}/" "${BASE_DIR%/}/" | tee "$RSYNC_RAW_OUT" >/dev/null
        else
          sudo rsync -rlDic --delete --dry-run --out-format='%i %n' \
            "${common_excludes[@]}" \
            "${NEW_DIR%/}/" "${BASE_DIR%/}/" | tee "$RSYNC_RAW_OUT" >/dev/null
        fi
      
        # 경로만 추출(디렉터리 제거) → rsync.paths  (sudo 불필요: _logs는 러너 소유)
        awk '{sub(/^[^ ]+[ ]+/,""); print}' "$RSYNC_RAW_OUT" \
          | sed -e 's#^\.\/##' -e '/\/$/d' \
          | sort -u | tee "$RSYNC_PATHS" >/dev/null || true
      
        # 삭제/변경 파일 목록 초기화 (리다이렉션 대신 tee 사용으로 안전)
        echo -n | tee "$CHANGED_LIST" >/dev/null
        echo -n | tee "$DELETE_LIST"  >/dev/null
      
        # RAW_OUT 파싱해서 삭제/변경 분리
        while IFS= read -r ln || [ -n "${ln:-}" ]; do
          # 삭제
          if [[ "$ln" == *"deleting "* ]]; then
            f="${ln#*deleting }"
            printf '%s\n' "$f" | tee -a "$DELETE_LIST" >/dev/null
            continue
          fi
          # 코드 / 경로 분리
          code="${ln%% *}"
          f="${ln#* }"
          [[ "$f" == */ ]] && continue
      
          # 파일 전송/생성/속성변경 포함
          case "$code" in
            ">f"*)   printf '%s\n' "$f" | tee -a "$CHANGED_LIST" >/dev/null ;; # 새로 전송
            ".f"*)   printf '%s\n' "$f" | tee -a "$CHANGED_LIST" >/dev/null ;; # 속성만 변경
            c[fps]*) printf '%s\n' "$f" | tee -a "$CHANGED_LIST" >/dev/null ;; # cf/cp/cs 등
            *)       : ;;
          esac
        done < "$RSYNC_RAW_OUT"
      
        # [ADD] git 예상 vs rsync 결과 교차 비교
        if [ -s "$LOG_DIR/predicted.list" ]; then
          sort -u "$LOG_DIR/predicted.list" -o "$LOG_DIR/predicted.list"
          comm -12 "$LOG_DIR/predicted.list" "$RSYNC_PATHS"       | tee "$LOG_DIR/intersection.txt"        >/dev/null || true
          comm -23 "$LOG_DIR/predicted.list" "$RSYNC_PATHS"       | tee "$LOG_DIR/missing.from.rsync.txt"  >/dev/null || true
          comm -13 "$LOG_DIR/predicted.list" "$RSYNC_PATHS"       | tee "$LOG_DIR/extra.in.rsync.txt"      >/dev/null || true
        else
          echo -n | tee "$LOG_DIR/intersection.txt"        >/dev/null
          echo -n | tee "$LOG_DIR/missing.from.rsync.txt"  >/dev/null
          echo -n | tee "$LOG_DIR/extra.in.rsync.txt"      >/dev/null
        fi
      
        # 출력 유틸 (sudo 없이 안전하게)
        _lines_or_zero() { [ -r "$1" ] && wc -l < "$1" 2>/dev/null || echo 0; }
        _head_opt()      { [ -r "$1" ] && head -n "${2:-30}" "$1" || true; }
      
        # [ADD] 프리뷰 리포트 출력 (_logs/report.txt)
        {
          echo "=== Diff Deploy Preview Report ==="
          echo "Version   : $DEPLOY_VERSION"
          echo "Context   : $APP_NAME"
          echo "Base Dir  : $BASE_DIR"
          echo "New Dir   : $NEW_DIR"
          echo "Filter    : ${SAFE_FILTER_MODE:-static}"
          echo
      
          echo "[GIT DIFF 예상 변경 개수]"
          _lines_or_zero "$LOG_DIR/predicted.list"
          _head_opt "$LOG_DIR/predicted.list" 30
          echo
      
          echo "[rsync --dry-run 파일 변경 개수]"
          _lines_or_zero "$RSYNC_PATHS"
          _head_opt "$RSYNC_PATHS" 30
          echo
      
          echo "[교집합] git 예상 ∩ rsync"
          _head_opt "$LOG_DIR/intersection.txt" 30
          echo
      
          echo "[MISSING] git 변경에는 있지만 rsync 없음"
          _head_opt "$LOG_DIR/missing.from.rsync.txt" 30
          echo
      
          echo "[EXTRA] rsync에는 있지만 예상에 없음"
          _head_opt "$LOG_DIR/extra.in.rsync.txt" 30
          echo
      
          echo "[삭제 건수]"
          _lines_or_zero "$DELETE_LIST"
          echo "[변경/생성 건수]"
          _lines_or_zero "$CHANGED_LIST"
        } | tee "$REPORT_TXT" >/dev/null
      
        log "프리뷰 리포트: $REPORT_TXT"
      }

      # ───────────────────────────────────────────────
      # apply_deletions()
      # DELETE_LIST 기반 안전 삭제 (심볼릭 링크는 링크 자체만 제거)
      # ───────────────────────────────────────────────
      apply_deletions() {
        local target="$1" list="$2"

        log "apply_deletions1"

        # 대상 디렉터리 실경로(보안상 정규화)
        local rp_tgt
        rp_tgt="$(sudo realpath -m -- "$target")" || return 0

        # 리스트 읽어서 절대경로 기준으로 삭제
        while IFS= read -r rel || [[ -n "${rel:-}" ]]; do
          [[ -z "$rel" ]] && continue
          # 위험 경로 차단
          if [[ "$rel" = /* || "$rel" = *".."* ]]; then
            echo "[SKIP] 위험 경로: $rel"
            continue
          fi
          abs="$rp_tgt/$rel"
          if sudo test -L "$abs"; then
            echo "[DEL] (symlink) $rel"
            sudo rm -f -- "$abs"
          elif sudo test -e "$abs"; then
            echo "[DEL] $rel"
            sudo rm -rf --one-file-system -- "$abs"
          fi
        done < "$list"

        log "apply_deletions2"
      }

      # ───────────────────────────────────────────────
      # apply_changes()
      # CHANGED_LIST 기반으로 변경 파일만 복사
      # ───────────────────────────────────────────────
      apply_changes() {
        if [ -s "$CHANGED_LIST" ]; then
          # # [FIX] 내용만 갱신하고, 기존 소유자/그룹/권한은 유지 (-o -g -p 제거)
          sudo rsync -rlDic --files-from="$CHANGED_LIST" "${NEW_DIR%/}/" "${TARGET%/}/"
        fi
      }

      # ───────────────────────────────────────────────
      # switch_live_symlink()
      # LIVE 심볼릭 링크를 새 TARGET으로 전환
      # ───────────────────────────────────────────────
      switch_live_symlink() {
        tmp_link="${LIVE_LINK}.new.$(ts)"
        sudo ln -sT "$TARGET" "$tmp_link" || sudo ln -s "$TARGET" "$tmp_link"
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || {
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo mv "$tmp_link" "$LIVE_LINK"
        }
        log "LIVE → $TARGET 전환 완료"
      }

      # ───────────────────────────────────────────────
      # update_live_pointer()
      # 심링크 교체후에 라이브 포인터 정보 재기록
      # ───────────────────────────────────────────────
      update_live_pointer() {
        local current="$TARGET"
        local prev="$prev_target"   # BASE_DIR로 기록하고 싶으면 prev="$BASE_DIR"
        sudo sh -c "printf 'CURRENT=%s\nPREV=%s\n' '$current' '${prev:-}' > '$TARGET/_logs/live-pointer.env'"
      }

      # ───────────────────────────────────────────────
      # reload_or_restart_tomcat()
      # Tomcat 핫리로드 or 재기동 처리
      # ───────────────────────────────────────────────
      reload_or_restart_tomcat() {
        if [ "$HOT_RELOAD" = "true" ] && [ -n "$DEPLOY_USER" ]; then
          sudo curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://$WAS_URL/manager/text/reload?path=/${APP_NAME}" || true
        else
          sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null || sudo systemctl restart "$TOMCAT_SERVICE"
        fi
      }

      # ───────────────────────────────────────────────
      # do_healthcheck()
      # 배포 후 서비스 정상 응답 확인
      # ───────────────────────────────────────────────
      do_healthcheck() {
        case "$HEALTH_MODE" in
          actuator) hc_url="http://127.0.0.1:8080/${APP_NAME}/actuator/health" ;;
          page)     hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
          none)     return ;;
          *)        hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
        esac

        elapsed=0
        while [ "$elapsed" -lt "$HC_TIMEOUT" ]; do
          if sudo curl -fsS --max-time 3 "$hc_url" >/dev/null 2>&1; then
            ok "헬스체크 성공: $hc_url"
            return
          fi
          sleep "$HC_INTERVAL"; elapsed=$((elapsed+HC_INTERVAL))
        done
        fail "헬스체크 실패: $hc_url"
      }

      # ───────────────────────────────────────────────
      # prune_releases()
      # KEEP_RELEASES 초과 버전 정리
      # ───────────────────────────────────────────────
      prune_releases() {
        mapfile -t snaps < <(sudo ls -1dt "${APP_RELEASES_DIR}/diff-${APP_NAME}-"* 2>/dev/null || true)
        if [ "${#snaps[@]}" -gt "$KEEP_RELEASES" ]; then
          for ((i=KEEP_RELEASES; i<${#snaps[@]}; i++)); do
            [ "${snaps[$i]}" = "$TARGET" ] && continue
            sudo rm -rf --one-file-system "${snaps[$i]}" || true
          done
        fi
      }

      # ───────────────────────────────────────────────
      # package_artifacts()
      # 로그, 목록 파일 등을 ZIP으로 압축
      # ───────────────────────────────────────────────
      package_artifacts() {
        sudo cp -f "$DIFF_BASE_FILE" "$ART_DIR/diff-base.env" || true
        sudo cp -f "$CHANGED_LIST" "$ART_DIR/changed-files.txt" || true
        sudo cp -f "$DELETE_LIST" "$ART_DIR/deleted-files.txt" || true
        # [ADD] 프리뷰 산출물도 같이 담기
        sudo cp -f "$RSYNC_RAW_OUT" "$ART_DIR/rsync.out" 2>/dev/null || true
        sudo cp -f "$RSYNC_PATHS" "$ART_DIR/rsync.paths" 2>/dev/null || true
        sudo cp -f "$REPORT_TXT" "$ART_DIR/report.txt" 2>/dev/null || true
        sudo cp -f "$RSYNC_FILTER" "$ART_DIR/rsync.filter" 2>/dev/null || true
        # [ADD] git diff 비교 산출물
        sudo cp -f "$LOG_DIR/predicted.list" "$ART_DIR/predicted.list" 2>/dev/null || true
        sudo cp -f "$LOG_DIR/intersection.txt" "$ART_DIR/intersection.txt" 2>/dev/null || true
        sudo cp -f "$LOG_DIR/missing.from.rsync.txt" "$ART_DIR/missing.from.rsync.txt" 2>/dev/null || true
        sudo cp -f "$LOG_DIR/extra.in.rsync.txt" "$ART_DIR/extra.in.rsync.txt" 2>/dev/null || true

        {
          echo "DEPLOYED_VERSION=$DEPLOY_VERSION"
          echo "LIVE_LINK=$LIVE_LINK"
          echo "TARGET=$TARGET"
          echo "BASE_DIR=$BASE_DIR"
        } | sudo tee "$ART_DIR/.env" >/dev/null

        ( cd "$ART_DIR" && zip -r "$(basename "$OUT_ZIP")" .env *.txt rsync.* *.list >/dev/null 2>&1 || true )
        ok "배포 로그 ZIP 생성 완료"
        echo "$OUT_ZIP"
      }

      # [ADD-commit.log] ─────────────────────────────────────────────
      # ───────────────────────────────────────────────
      # [NEW] 함수: write_pre_deploy_commit_log_if_missing
      # 목적:
      #   - BASE_COMMIT 값이 있을 경우,
      #     LIVE 디렉터리에 commit.log가 없으면 자동으로 생성
      #   - 기존 commit.log가 있거나 BASE_COMMIT이 비어 있으면 아무 작업 안 함
      # ───────────────────────────────────────────────
      write_pre_deploy_commit_log_if_missing() {
        # BASE_COMMIT이 없으면 스킵
        if [ -z "${BASE_COMMIT:-}" ]; then
          log "[PRE-DEPLOY] BASE_COMMIT 미설정 → commit.log 기록 생략"
          return 0
        fi
      
        # LIVE 실경로 추적 (심링크 or 디렉터리)
        local live_real=""
        if sudo test -L "$LIVE_LINK"; then
          live_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        elif sudo test -d "$LIVE_LINK"; then
          live_real="$LIVE_LINK"
        fi
      
        # 유효한 LIVE가 없으면 스킵
        if [ -z "$live_real" ] || ! sudo test -d "$live_real"; then
          log "[PRE-DEPLOY] LIVE 디렉터리 없음 → commit.log 기록 생략"
          return 0
        fi
      
        # 이미 commit.log가 존재하면 스킵
        local logf="$live_real/_logs/commit.log"
        if sudo test -f "$logf"; then
          log "[PRE-DEPLOY] 기존 commit.log 존재 → skip ($logf)"
          return 0
        fi
      
        # 생성
        sudo mkdir -p "$live_real/_logs"
        sudo sh -c "printf 'COMMIT=%s\nDATE=%s\nNOTE=base_commit_predeploy\n' \
          \"$BASE_COMMIT\" \"\$(date -Iseconds)\" > '$logf'"
        log "[PRE-DEPLOY] commit.log 생성 완료: $logf (COMMIT=$BASE_COMMIT)"
      }
      
      write_commit_log() {
        # diff-deploy는 TARGET 디렉터리가 최종 LIVE가 됨
        local file="$TARGET/_logs/commit.log"
        sudo mkdir -p "$(dirname "$file")"
        sudo sh -c "printf 'COMMIT=%s\nTAG=%s\nVERSION=%s\nDATE=%s\n' \
          \"$CURRENT_COMMIT_SHA\" \"$COMMIT_TAG\" \"$DEPLOY_VERSION\" \"\$(date -Iseconds)\" > \"$file\""
        log "Wrote commit info to ${file}" 
      }

      # ────────────────────────────────────────────────

      main() {
        require_envs
        log "require_envs 완료"
        ensure_tools
        log "ensure_tools 완료"
        setup_context
        log "setup_context 완료"
        maybe_fetch_new_dir
        log "maybe_fetch_new_dir 완료"
        resolve_base_from_live
        log "resolve_base_from_live 완료"
        write_pre_deploy_commit_log_if_missing
        log "write_pre_deploy_commit_log_if_missing 완료"
        prepare_target_from_prev
        log "prepare_target_from_prev 완료"
        compute_diff_lists
        log "compute_diff_lists 완료"
        apply_deletions "$TARGET" "$DELETE_LIST"
        log "apply_deletions 완료"
        apply_changes
        log "apply_changes 완료"
        switch_live_symlink
        log "switch_live_symlink 완료"
        reload_or_restart_tomcat
        log "reload_or_restart_tomcat 완료"
        do_healthcheck
        update_live_pointer
        write_commit_log  # [ADD-commit.log] 배포 후 기록
        prune_releases
        package_artifacts
      }

      main "$@"

    REMOTE_SH

      log "▶ Executing diff deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "ARTIFACTS_BASE='$(shq "$artifacts_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "KEEP_RELEASES='$(shq "$keep_releases")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "WAS_URL='$(shq "$was_url")'" \
        "AUTO_FETCH_ON_MISSING='true'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "SAFE_FILTER_MODE='$(shq "$SAFE_FILTER_MODE")'" \
        "PREDICTED_LIST_B64='$(shq "$PREDICTED_LIST_B64")'" \
        "CURRENT_COMMIT_SHA='$(shq "${CURRENT_COMMIT_SHA:-}")'" \
        "BASE_COMMIT='$(shq "${BASE_COMMIT:-}")'" \
        "ARTIFACT_USER='$(shq "$ARTIFACT_USER")'" \
        "ARTIFACT_GROUP='$(shq "$ARTIFACT_GROUP")'" \
        'export REMOTE_DIR COMMIT_TAG CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE ARTIFACTS_BASE TOMCAT_SERVICE KEEP_RELEASES HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL HOT_RELOAD DEPLOY_USER DEPLOY_PASS WAS_URL AUTO_FETCH_ON_MISSING NEXUS_USER NEXUS_PASS RELEASE_REPO_URL GROUP_ID ARTIFACT_ID SAFE_FILTER_MODE PREDICTED_LIST_B64 CURRENT_COMMIT_SHA BASE_COMMIT ARTIFACT_USER ARTIFACT_GROUP; bash -s' \
        < "$remote_script" | tee /tmp/_diff_deploy_out.txt

      remote_zip_path="$(tail -n1 /tmp/_diff_deploy_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/diff-deploy-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_diff_deploy_out.txt || true
      ok "Diff deploy finished"
    }


.fn_tomcat_diff_deploy:
  script: |
    fn_tomcat_diff_deploy() {
      set -eu

      # ── 필수 입력 ─────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"

      # ── 선택 입력(기본값) ───────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      artifacts_base="${TOMCAT_ARTIFACTS_DIR:-/opt/tomcat/artifacts}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"
      keep_releases="${KEEP_RELEASES:-15}"

      # 헬스체크
      health_mode="${HEALTH_MODE:-page}"           # actuator|page|none
      health_url_override="${HEALTH_URL_OVERRIDE:-}"
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      # Tomcat manager(핫리로드)
      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"
      was_url="${WAS_URL:-127.0.0.1:8080}"

      auto_fetch_on_missing="true"                 # NEW_DIR 없으면 Nexus에서 내려받아 생성

      # GitLab 산출물 파일명(로컬 Runner 수집용)
      deploy_log_name="deploy.log"                 # 산출물로 복사되는 이름

      # ── 유틸 ─────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      remote_script=$(mktemp /tmp/remote_diff_deploy.XXXXXX)
      log "Created temporary diff deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'

      #!/usr/bin/env bash
      set -eu

      DEBUG_MODE="${DEBUG_MODE:-false}" 

      # ───────────────────────────────────────────────
      # 공통 유틸 함수
      # ───────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }
      dbg() {
        if [ "$DEBUG_MODE" = "true" ]; then
          printf '[DBG]  %s\n' "$*"
        fi
      }

      # 파일 타입 검사 도우미
      is_link() { sudo test -L "$1"; }
      is_dir()  { sudo test -d "$1"; }
      # -o 대신 안전하게 두 번 검사
      is_any()  { sudo test -e "$1" || sudo test -L "$1"; }

      # ───────────────────────────────────────────────
      # require_envs()
      # 환경 변수 필수값 확인
      # ───────────────────────────────────────────────
      require_envs() {
        : "${REMOTE_DIR:?REMOTE_DIR is required}"
        : "${COMMIT_TAG:?COMMIT_TAG is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
        : "${WEBAPPS_ROOT:?WEBAPPS_ROOT is required}"
        : "${RELEASES_BASE:?RELEASES_BASE is required}"
        : "${ARTIFACTS_BASE:?ARTIFACTS_BASE is required}"
        : "${TOMCAT_SERVICE:?TOMCAT_SERVICE is required}"
        : "${KEEP_RELEASES:?KEEP_RELEASES is required}"
        : "${HEALTH_MODE:?HEALTH_MODE is required}"
        : "${HC_TIMEOUT:?HC_TIMEOUT is required}"
        : "${HC_INTERVAL:?HC_INTERVAL is required}"
        : "${NEXUS_USER:?NEXUS_USER is required}"
        : "${NEXUS_PASS:?NEXUS_PASS is required}"
        : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
        : "${GROUP_ID:?GROUP_ID is required}"
        : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      }

      # ───────────────────────────────────────────────
      # ensure_tools()
      # 필수 도구 설치 확인 (rsync, unzip 등)
      # ───────────────────────────────────────────────
      ensure_tools() {
        for t in rsync ln readlink zip awk sed grep sort uniq curl unzip mktemp df ls tee realpath; do
          if ! need "$t"; then
            if   need apk; then
              sudo apk add --no-cache coreutils "$t" || true
            elif need apt-get; then
              sudo apt-get update -y && sudo apt-get install -y "$t" || true
            elif need dnf; then
              sudo dnf install -y "$t" || true
            fi
          fi
        done
      }

      # ───────────────────────────────────────────────
      # setup_context()
      # 디렉터리 및 배포 경로 설정
      # ───────────────────────────────────────────────
      setup_context() {
        APP_NAME="${CONTEXT_PATH#/}"
        DEPLOY_VERSION="${COMMIT_TAG#v}"

        LIVE_LINK="${WEBAPPS_ROOT%/}/$APP_NAME"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/$APP_NAME"
        NEW_DIR="${ARTIFACTS_BASE%/}/$APP_NAME/$APP_NAME-$DEPLOY_VERSION"

        ART_DIR="$REMOTE_DIR/artifacts"
        OUT_ZIP="$ART_DIR/diff-deploy-artifacts.zip"

        uid="$(id -u)"; gid="$(id -g)"
        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
        sudo chown -R "$uid:$gid" "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
      }

      # ───────────────────────────────────────────────
      # maybe_fetch_new_dir()
      # NEW_DIR이 없을 경우 Nexus에서 WAR 자동 다운로드 및 unzip
      # ───────────────────────────────────────────────
      maybe_fetch_new_dir() {
        if [ -d "$NEW_DIR" ]; then
          log "기존 NEW_DIR 사용: $NEW_DIR"
          return
        fi
        log "NEW_DIR 없음 → Nexus에서 자동 생성"
        APP_PATH="${GROUP_ID//.//}/${ARTIFACT_ID}/${DEPLOY_VERSION}"
        NEW_WAR="${ARTIFACT_ID}-${DEPLOY_VERSION}.war"
        NEW_URL="${RELEASE_REPO_URL%/}/${APP_PATH}/${NEW_WAR}"
        TMP_DIR=$(sudo mktemp -d /tmp/${APP_NAME}-${DEPLOY_VERSION}-fetch.XXXXXX)

        sudo curl -fsSL -u "$NEXUS_USER:$NEXUS_PASS" -o "$TMP_DIR/$NEW_WAR" "$NEW_URL"
        sudo unzip -q "$TMP_DIR/$NEW_WAR" -d "$TMP_DIR/unzip"
        sudo test -d "$TMP_DIR/unzip/WEB-INF" || fail "WAR 구조 이상"
        sudo mkdir -p "$(dirname "$NEW_DIR")"
        sudo rm -rf "$NEW_DIR"
        sudo mv "$TMP_DIR/unzip" "$NEW_DIR"
        sudo rm -rf "$TMP_DIR"
        ok "NEW_DIR 생성 완료: $NEW_DIR"
      }

      # ───────────────────────────────────────────────
      # resolve_base_from_live()
      # LIVE 심볼릭 링크에서 BASE_DIR 추출 또는 초기화
      # ───────────────────────────────────────────────
      resolve_base_from_live() {
        prev_target=""
        if is_link "$LIVE_LINK"; then
          prev_target="$(sudo readlink -f "$LIVE_LINK" || true)"
        elif is_dir "$LIVE_LINK"; then
          seed="${APP_RELEASES_DIR}/diff-legacy-backup-$(ts)"
          log "LIVE_DIR 기반 초기 백업 생성 → $seed"
          sudo rsync -a --delete --exclude='_logs/**' "${LIVE_LINK%/}/" "${seed%/}/" || true
          prev_target="$seed"
          sudo ln -sT "$seed" "$LIVE_LINK" || true
        else
          log "LIVE_LINK가 없음 → 신규 서비스로 간주, 초기화 모드 실행"
          seed="${APP_RELEASES_DIR}/diff-initial-${APP_NAME}-$(ts)"
          sudo mkdir -p "$seed"
          sudo cp -a "${NEW_DIR%/}/." "$seed/"
          prev_target="$seed"
          sudo ln -sT "$seed" "$LIVE_LINK"
          ok "신규 서비스 초기화 완료: $seed"
        fi

        BASE_DIR="$(sudo readlink -f "$LIVE_LINK" || true)"
        [ -n "$BASE_DIR" ] || fail "BASE_DIR 확인 실패"
        [ -n "$prev_target" ] || prev_target="$BASE_DIR"
      }

      # ───────────────────────────────────────────────
      # prepare_target_from_prev()
      # 이전 릴리스 복제 후 TARGET 디렉터리 생성
      # ───────────────────────────────────────────────
      prepare_target_from_prev() {
        stamp="$(ts)"
        TARGET="${APP_RELEASES_DIR}/diff-${APP_NAME}-${DEPLOY_VERSION}-${stamp}"
        log "새 TARGET 생성: $TARGET"
        sudo mkdir -p "$TARGET"
        sudo rsync -a --delete  --exclude='_logs/**' "${prev_target%/}/" "${TARGET%/}/" || true

        LOG_DIR="${TARGET%/}/_logs"
        sudo rm -rf "$LOG_DIR"
        sudo mkdir -p "$LOG_DIR"
        sudo chown -R "$uid:$gid" "$LOG_DIR"

        DIFF_BASE_FILE="$LOG_DIR/diff-base.env"
        LIVE_POINTER_FILE="$LOG_DIR/live-pointer.env"
        CHANGED_LIST="$LOG_DIR/changed-files.txt"
        DELETE_LIST="$LOG_DIR/deleted-files.txt"
        : > "$CHANGED_LIST"; : > "$DELETE_LIST"
        printf 'BASE_DIR=%s\n' "$BASE_DIR" > "$DIFF_BASE_FILE"
      }

      # ───────────────────────────────────────────────
      # compute_diff_lists()
      # rsync dry-run 결과를 기반으로 변경/삭제 파일 목록 계산
      # ───────────────────────────────────────────────
      compute_diff_lists() {
        log "Rsync dry-run 실행 중 (NEW vs BASE)"
        mapfile -t lines < <(sudo rsync -rlDic --delete --dry-run --out-format='%i %n' \
          --exclude='_logs/**' --exclude='*.bad' --exclude='*.tmp' \
          --exclude='*.bak' --exclude='*.swp' --exclude='*.log' \
          "${NEW_DIR%/}/" "${BASE_DIR%/}/")

        for ln in "${lines[@]}"; do
          if printf '%s\n' "$ln" | grep -q '^\*deleting '; then
            f="${ln#*deleting }"
            echo "$f" >> "$DELETE_LIST"
          elif printf '%s\n' "$ln" | grep -qE '^(>f|\.f\+|>d)'; then
            f="$(printf '%s' "$ln" | sed 's/^[^ ]\+ //')"
            [[ "$f" == */ ]] && continue
            echo "$f" >> "$CHANGED_LIST"
          fi
        done
      }

      # ───────────────────────────────────────────────
      # apply_deletions()
      # DELETE_LIST 기반 안전 삭제 (심볼릭 링크는 링크 자체만 제거)
      # ───────────────────────────────────────────────
      apply_deletions() {
        local target="$1" list="$2"

        # 대상 디렉터리 실경로(보안상 정규화)
        local rp_tgt
        rp_tgt="$(sudo realpath -m -- "$target")" || return 0

        # 리스트 읽어서 절대경로 기준으로 삭제
        while IFS= read -r raw || [[ -n "${raw:-}" ]]; do
          rel="$(printf '%s' "$raw" | sed -e 's/\r$//' -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//' )"
          rel="${rel#./}"

          # 빈 줄/주석 스킵
          [[ -z "$rel" ]] && continue
          [[ "$rel" =~ ^# ]] && continue 

          # 위험 경로 차단
          if [[ "$rel" = /* || "$rel" = *".."* ]]; then
            log "  [SKIP] 위험 경로: $rel"
            continue
          fi

          abs="$rp_tgt/$rel"

          if sudo test -L "$abs"; then
            log "[DEL] (symlink) $abs"
            sudo rm -f -- "$abs"
          elif sudo test -e "$abs"; then
            log "[DEL] $abs"
            sudo rm -rf --one-file-system -- "$abs"
          fi
        done < "$list" 
      }

      # ───────────────────────────────────────────────
      # apply_changes()
      # CHANGED_LIST 기반으로 변경 파일만 복사
      # ───────────────────────────────────────────────
      apply_changes() {
        log "[apply_changes] 파일 변경 적용 시작"

        dbg "rsync source=${NEW_DIR%/}/ target=${TARGET%/}/ list=$CHANGED_LIST"    

        if [ -s "$CHANGED_LIST" ]; then
          sudo rsync -rlDic \
            --files-from="$CHANGED_LIST" \
            --ignore-missing-args \
            --out-format='[SYNC] %i %n' \
            "${NEW_DIR%/}/" "${TARGET%/}/" | tee "$LOG_DIR/rsync.apply.out"

          ok "[apply_changes] 변경 파일 적용 완료 (로그: $LOG_DIR/rsync.apply.out)"
        else
          log "[apply_changes] 변경된 파일 없음 → skip"
        fi
      }

      # ───────────────────────────────────────────────
      # switch_live_symlink()
      # LIVE 심볼릭 링크를 새 TARGET으로 전환
      # ───────────────────────────────────────────────
      switch_live_symlink() {
        tmp_link="${LIVE_LINK}.new.$(ts)"
        sudo ln -sT "$TARGET" "$tmp_link" || sudo ln -s "$TARGET" "$tmp_link"
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || {
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo mv "$tmp_link" "$LIVE_LINK"
        }
        log "LIVE → $TARGET 전환 완료"
      }
      
      # ───────────────────────────────────────────────
      # update_live_pointer()
      # 심링크 교체후에 라이브 포인터 정보 재기록
      # ───────────────────────────────────────────────
      update_live_pointer() {
        local current="$TARGET"
        local prev="$prev_target"   # BASE_DIR로 기록하고 싶으면 prev="$BASE_DIR"
        sudo sh -c "printf 'CURRENT=%s\nPREV=%s\n' '$current' '${prev:-}' > '$TARGET/_logs/live-pointer.env'"
        uid="$(id -u)"; gid="$(id -g)" 
        sudo chown "$uid:$gid" "$TARGET/_logs/live-pointer.env"
      }

      # ───────────────────────────────────────────────
      # reload_or_restart_tomcat()
      # Tomcat 핫리로드 or 재기동 처리
      # ───────────────────────────────────────────────
      reload_or_restart_tomcat() {
        if [ "$HOT_RELOAD" = "true" ] && [ -n "$DEPLOY_USER" ]; then
          sudo curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://$WAS_URL/manager/text/reload?path=/${APP_NAME}" || true
        else
          sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null || sudo systemctl restart "$TOMCAT_SERVICE"
        fi
      }

      # ───────────────────────────────────────────────
      # do_healthcheck()
      # 배포 후 서비스 정상 응답 확인
      # ───────────────────────────────────────────────
      do_healthcheck() {
        case "$HEALTH_MODE" in
          actuator) hc_url="http://127.0.0.1:8080/${APP_NAME}/actuator/health" ;;
          page)     hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
          none)     return ;;
          *)        hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
        esac

        elapsed=0
        while [ "$elapsed" -lt "$HC_TIMEOUT" ]; do
          if sudo curl -fsS --max-time 3 "$hc_url" >/dev/null 2>&1; then
            ok "헬스체크 성공: $hc_url"
            return
          fi
          sleep "$HC_INTERVAL"; elapsed=$((elapsed+HC_INTERVAL))
        done
        fail "헬스체크 실패: $hc_url"
      }

      # ───────────────────────────────────────────────
      # prune_releases()
      # KEEP_RELEASES 초과 버전 정리
      # ───────────────────────────────────────────────
      prune_releases() {
        mapfile -t snaps < <(sudo ls -1dt "${APP_RELEASES_DIR}/diff-${APP_NAME}-"* 2>/dev/null || true)
        if [ "${#snaps[@]}" -gt "$KEEP_RELEASES" ]; then
          for ((i=KEEP_RELEASES; i<${#snaps[@]}; i++)); do
            [ "${snaps[$i]}" = "$TARGET" ] && continue
            sudo rm -rf --one-file-system "${snaps[$i]}" || true
          done
        fi
      }

      # ───────────────────────────────────────────────
      # package_artifacts()
      # 로그, 목록 파일 등을 ZIP으로 압축
      # ───────────────────────────────────────────────
      package_artifacts() {
        sudo cp -f "$DIFF_BASE_FILE" "$ART_DIR/diff-base.env" || true
        sudo cp -f "$CHANGED_LIST" "$ART_DIR/changed-files.txt" || true
        sudo cp -f "$DELETE_LIST" "$ART_DIR/deleted-files.txt" || true

        {
          echo "DEPLOYED_VERSION=$DEPLOY_VERSION"
          echo "LIVE_LINK=$LIVE_LINK"
          echo "TARGET=$TARGET"
          echo "BASE_DIR=$BASE_DIR"
        } > "$ART_DIR/.env"

        ( cd "$ART_DIR" && zip -r "$(basename "$OUT_ZIP")" .env *.txt >/dev/null 2>&1 )
        ok "배포 로그 ZIP 생성 완료"
        echo "$OUT_ZIP"
      }

      # ───────────────────────────────────────────────
      # main
      # ───────────────────────────────────────────────
      main() {
        require_envs
        ensure_tools
        setup_context
        maybe_fetch_new_dir
        resolve_base_from_live
        prepare_target_from_prev
        compute_diff_lists
        apply_deletions "$TARGET" "$DELETE_LIST"
        apply_changes
        switch_live_symlink
        reload_or_restart_tomcat
        do_healthcheck
        update_live_pointer
        prune_releases
        package_artifacts
      }

      main "$@"

    REMOTE_SH

      log "▶ Executing diff deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "ARTIFACTS_BASE='$(shq "$artifacts_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "KEEP_RELEASES='$(shq "$keep_releases")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "WAS_URL='$(shq "$was_url")'" \
        "AUTO_FETCH_ON_MISSING='$(shq "$auto_fetch_on_missing")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        'export REMOTE_DIR COMMIT_TAG CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE ARTIFACTS_BASE TOMCAT_SERVICE KEEP_RELEASES HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL HOT_RELOAD DEPLOY_USER DEPLOY_PASS WAS_URL AUTO_FETCH_ON_MISSING NEXUS_USER NEXUS_PASS RELEASE_REPO_URL GROUP_ID ARTIFACT_ID; bash -s' \
        < "$remote_script" | tee /tmp/_diff_deploy_out.txt

      remote_zip_path="$(tail -n1 /tmp/_diff_deploy_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/diff-deploy-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_diff_deploy_out.txt || true
      ok "Diff deploy finished"
    }


# ───────────────────────────────────────────────────────────────────────────────
# 함수: fn_tomcat_diff_restore
#
# 목적:
#   - /opt/tomcat/releases/<app>/ 아래의 diff 스냅샷(diff-<app>-<ver>-<ts>) 중
#     지정 대상(이름 또는 버전)이나 “현재보다 한 단계 이전” 스냅샷으로
#     LIVE 심링크를 원자적으로 되돌리고 Tomcat 반영 및 헬스체크를 수행한다.
#
# 작동 개요(코드 기준):
#   1) 현재 LIVE 대상 파악:
#      - LIVE_LINK = <WEBAPPS_ROOT>/<app>, current = readlink -f(LIVE_LINK)
#      - LIVE가 심링크가 아니면(레거시) releases/<app>로 마이그레이션 수행(1회)
#   2) 후보 조회(최신순):
#      - /opt/tomcat/releases/<app>/diff-<app>-* 디렉터리
#      - 디렉터리 내 .bad 마커가 있으면 후보에서 제외(자동화 안정성)
#   3) 대상 선택 우선순위:
#      - ROLLBACK_TO_NAME(정확한 디렉터리명) >
#        ROLLBACK_TO_VERSION(버전 일치) >
#        현재 타깃의 _logs/diff-base.env 의 BASE_DIR 값(직전 운영) >
#        “현재보다 한 단계 이전”(없으면 최신/유일 후보)
#      - 자기 자신(current)으로 선택되는 경우는 다음 적합 후보로 대체
#   4) LIVE 전환(원자적):
#      - ln -sT target <tmp link> → mv -Tf 로 LIVE_LINK 교체(폴백 처리 포함)
#      - 대상 스냅샷의 _logs/live-pointer.env 에 CURRENT=target, PREV=<이전 current> 기록
#   5) Tomcat 적용:
#      - HOT_RELOAD=true & DEPLOY_USER/PASS 있으면 manager reload 호출
#      - 아니면 systemctl reload 실패 시 restart
#   6) 헬스체크:
#      - HEALTH_URL_OVERRIDE 우선, 없으면 mode에 따라 기본 URL 구성
#      - 실패 시 fail
#   7) 마커 처리:
#      - 성공 롤백 후, 이전 current 디렉터리에 .bad 마커를 기록(옵션)
#   8) 산출물 zip 반환:
#      - 원격: $REMOTE_DIR/artifacts/diff-restore-artifacts.zip
#
# 주요 경로(코드 기본값):
#   WEBAPPS_ROOT  : /opt/tomcat/webapps
#   RELEASES_BASE : /opt/tomcat/releases
#   LIVE_LINK     : <WEBAPPS_ROOT>/<app>
#   SNAPSHOTS     : <RELEASES_BASE>/<app>/diff-<app>-*
#   LOGS PER SNAP : <SNAPSHOT>/_logs/{diff-base.env, live-pointer.env, ...}
#   BAD_MARKER    : .bad (변수 BAD_MARKER_NAME)
#
# 산출물(원격에 생성):
#   $REMOTE_DIR/artifacts/
#     ├── diff-restore-artifacts.zip
#     ├── diff-restore.log             (RESTORE_LOG_NAME, 기본 diff-restore.log)
#     └── .env
#         - ROLLED_BACK_FROM=<이전 current>
#         - ROLLED_BACK_TO=<target dir>
#         - LIVE_LINK=<LIVE_LINK>
#         - RESOLVED_BY=override:name|override:version|diff-base.env|list:*
#
# 필수 환경변수(외부 래퍼/CI에서 주입):
#   REMOTE_DEPLOY_HOST, REMOTE_DEPLOY_USER, REMOTE_DIR, CONTEXT_PATH
#
# 내부 스크립트가 요구하는 추가 변수(함수에서 기본값 제공/전달):
#   WEBAPPS_ROOT=/opt/tomcat/webapps
#   RELEASES_BASE=/opt/tomcat/releases
#   TOMCAT_SERVICE=tomcat
#   WAS_URL=127.0.0.1:8080
#   ROLLBACK_TO_NAME=""                # 예: diff-devops-1.4.0-20251019101822
#   ROLLBACK_TO_VERSION=""             # 예: 1.4.0
#   HEALTH_MODE=page | actuator | none
#   HEALTH_URL_OVERRIDE=""
#   HEALTHCHECK_TIMEOUT=60
#   HEALTHCHECK_INTERVAL=2
#   HOT_RELOAD=false
#   DEPLOY_USER=""
#   DEPLOY_PASS=""
#   RESTORE_LOG_NAME=diff-restore.log
#   MARK_BAD_ON_ROLLBACK=true
#   BAD_MARKER_NAME=.bad
#
# 주의사항(코드 반영됨):
#   - 후보 목록은 최신순이며, .bad 마커가 있는 스냅샷은 자동 제외.
#   - 현재 대상(current)과 동일한 스냅샷으로의 전환을 회피하도록 보호 로직 포함.
#   - ln -sT + mv -Tf 조합으로 원자적 전환, 실패 시 rm → mv 폴백 처리.
# ───────────────────────────────────────────────────────────────────────────────
.fn_tomcat_diff_restore:
  script: |
    fn_tomcat_diff_restore() {
      set -eu

      # ── 필수 ──────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

      # ── 선택 ──────────────────────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"
      was_url="${WAS_URL:-127.0.0.1:8080}"

      rollback_to_name="${ROLLBACK_TO_NAME:-}"           # 예: diff-devops-1.4.0-20251019101822
      rollback_to_version="${ROLLBACK_TO_VERSION:-}"     # 예: 1.4.0

      mark_bad_on_rollback="${MARK_BAD_ON_ROLLBACK:-true}"
      bad_marker_name="${BAD_MARKER_NAME:-.bad}"

      health_mode="${HEALTH_MODE:-page}"
      health_url_override="${HEALTH_URL_OVERRIDE:-}"
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"

      restore_log_name="${RESTORE_LOG_NAME:-diff-restore.log}"

      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      remote_script=$(mktemp /tmp/remote_diff_restore.XXXXXX)
      log "Created temporary diff restore script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH' 
      #!/usr/bin/env bash
      set -eu

      # ── 공통 유틸 ───────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }
      is_link() { sudo test -L "$1"; }
      is_dir()  { sudo test -d "$1"; }

      # ── 입력 검증 ───────────────────────────────────────
      require_envs() {
        : "${REMOTE_DIR:?}"
        : "${CONTEXT_PATH:?}"
        : "${WEBAPPS_ROOT:?}"
        : "${RELEASES_BASE:?}"
        : "${TOMCAT_SERVICE:?}"
        : "${WAS_URL:?}"
        : "${ROLLBACK_TO_NAME:-}"
        : "${ROLLBACK_TO_VERSION:-}"
        : "${HEALTH_MODE:?}"
        : "${HEALTH_URL_OVERRIDE:-}"
        : "${HC_TIMEOUT:?}"
        : "${HC_INTERVAL:?}"
        : "${HOT_RELOAD:?}"
        : "${DEPLOY_USER:-}"
        : "${DEPLOY_PASS:-}"
        : "${RESTORE_LOG_NAME:?}"
        : "${MARK_BAD_ON_ROLLBACK:?}"
        : "${BAD_MARKER_NAME:?}"
      }

      # ── 도구 확인/설치 ─────────────────────────────────
      ensure_tools() {
        local tools="ln readlink zip ls grep awk sed curl"
        for t in $tools; do
          if ! need "$t"; then
            if   need apk;     then sudo apk add --no-cache "$t" || true
            elif need apt-get; then sudo apt-get update -y && sudo apt-get install -y "$t" || true
            elif need dnf;     then sudo dnf install -y "$t" || true
            fi
          fi
        done
        # systemctl은 선택
      }

      # ── 컨텍스트 구성 ───────────────────────────────────
      setup_context() {
        APP_NAME="${CONTEXT_PATH#/}"
        LIVE_LINK="${WEBAPPS_ROOT%/}/${APP_NAME}"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/${APP_NAME}"

        ART_DIR="$REMOTE_DIR/artifacts"
        LOG="$ART_DIR/$RESTORE_LOG_NAME"
        OUT_ZIP="$ART_DIR/diff-restore-artifacts.zip"

        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
        : > "$LOG"
      }

      # ── 현재 LIVE 대상 확인 ────────────────────────────
      get_current_live() {
        CURRENT=""
        if is_link "$LIVE_LINK"; then
          CURRENT="$(sudo readlink -f "$LIVE_LINK" || true)"
        fi
        echo "CURRENT=$CURRENT" | tee -a "$LOG"
      }

      # ── 후보 스냅샷 수집 (최신순, BAD 제외) ─────────────
      collect_candidates() {
        local list
        mapfile -t list < <(
          ls -1dt "${APP_RELEASES_DIR}/diff-${APP_NAME}-"* 2>/dev/null \
          | while read -r d; do
              if sudo test -f "$d/$BAD_MARKER_NAME"; then
                continue
              fi
              printf "%s\n" "$d"
            done
        )
        CANDIDATES=("${list[@]}")
      }

      # ── 후보 결정 1: 이름 강제 ──────────────────────────
      resolve_by_name() {
        [ -n "${ROLLBACK_TO_NAME:-}" ] || return 1
        local cand="${APP_RELEASES_DIR}/${ROLLBACK_TO_NAME}"
        [ -d "$cand" ] || fail "rollback target not found: $cand"
        TARGET="$cand"; RESOLVED_BY="override:name"
        return 0
      }

      # ── 후보 결정 2: 버전 강제 ───────────────────────────
      resolve_by_version() {
        [ -n "${ROLLBACK_TO_VERSION:-}" ] || return 1
        [ "${#CANDIDATES[@]}" -ge 1 ] || fail "no diff snapshots found"
        local d base ver
        for d in "${CANDIDATES[@]}"; do
          base="$(basename "$d")"
          ver="$(printf "%s" "$base" | sed -E "s/^diff-${APP_NAME}-([^-]+)-.*/\1/")"
          if [ "$ver" = "$ROLLBACK_TO_VERSION" ]; then
            TARGET="$d"; RESOLVED_BY="override:version"; return 0
          fi
        done
        fail "no snapshot found for version: $ROLLBACK_TO_VERSION"
      }

      # ── 후보 결정 3: diff-base.env 기반 ─────────────────
      resolve_by_diffbase() {
        [ -n "${CURRENT:-}" ] && [ -d "${CURRENT:-}" ] || return 1
        local dbase lp base_dir cur_in_log
        dbase="$CURRENT/_logs/diff-base.env"
        lp="$CURRENT/_logs/live-pointer.env"
        if sudo test -f "$lp"; then
          cur_in_log="$(sudo awk -F= '/^CURRENT=/{print $2}' "$lp" 2>/dev/null || true)"
          echo "CHECK live-pointer CURRENT=$cur_in_log" | tee -a "$LOG"
        fi
        if sudo test -f "$dbase"; then
          base_dir="$(sudo awk -F= '/^BASE_DIR=/{print $2}' "$dbase" 2>/dev/null || true)"
          if [ -n "$base_dir" ] && [ -d "$base_dir" ]; then
            TARGET="$base_dir"; RESOLVED_BY="diff-base.env"; return 0
          fi
        fi
        return 1
      }

      # ── 후보 결정 4: 목록 폴백(현재 이전/세컨드 최신 등) ─
      resolve_by_list() {
        [ "${#CANDIDATES[@]}" -ge 1 ] || fail "no diff snapshots found"

        if [ -n "${CURRENT:-}" ]; then
          local found=0 idx=0 i
          for ((i=0; i<${#CANDIDATES[@]}; i++)); do
            [ "$(sudo readlink -f "${CANDIDATES[$i]}")" = "$CURRENT" ] && { found=1; idx=$i; break; }
          done
          if [ "$found" = 1 ] && [ $((idx+1)) -lt ${#CANDIDATES[@]} ]; then
            TARGET="${CANDIDATES[$((idx+1))]}"; RESOLVED_BY="list:prev-of-current"; return 0
          fi
        fi

        if [ "${#CANDIDATES[@]}" -ge 2 ]; then
          TARGET="${CANDIDATES[1]}"; RESOLVED_BY="list:second-latest"
        else
          TARGET="${CANDIDATES[0]}"; RESOLVED_BY="list:latest"
        fi
        return 0
      }

      # ── LIVE 링크 전환 ──────────────────────────────────
      switch_live() {
        [ -n "${TARGET:-}" ] && [ -d "$TARGET" ] || fail "rollback target invalid"
        echo "TARGET=$TARGET (resolved_by=$RESOLVED_BY)" | tee -a "$LOG"

        local tmp_link="${LIVE_LINK}.new.$(ts)"
        sudo ln -sT "$TARGET" "$tmp_link" 2>/dev/null || sudo ln -s "$TARGET" "$tmp_link"
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || {
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo mv "$tmp_link" "$LIVE_LINK"
        }
        log "LIVE -> $TARGET"
      }

      # ── Tomcat 반영(핫리로드/재로드/재시작) ──────────────
      apply_tomcat() {
        if [ "$HOT_RELOAD" = "true" ] && [ -n "${DEPLOY_USER:-}" ] && [ -n "${DEPLOY_PASS:-}" ] && need curl; then
          curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://$WAS_URL/manager/text/reload?path=/${APP_NAME}" >>"$LOG" 2>&1 || true
        else
          if need systemctl; then
            if sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null; then
              :
            else
              sudo systemctl restart "$TOMCAT_SERVICE"
            fi
          fi
        fi
      }

      # ── Healthcheck ─────────────────────────────────────
      healthcheck() {
        local hc_url=""
        if [ -n "${HEALTH_URL_OVERRIDE:-}" ]; then
          hc_url="$HEALTH_URL_OVERRIDE"
        else
          case "$HEALTH_MODE" in
            actuator) hc_url="http://127.0.0.1:8080/${APP_NAME}/actuator/health" ;;
            page)     hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
            none)     hc_url="" ;;
            *)        hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
          esac
        fi

        [ -n "$hc_url" ] || return 0
        need curl || return 0

        local elapsed=0 ok_flag=0
        while [ "$elapsed" -lt "$HC_TIMEOUT" ]; do
          if curl -fsS --max-time 3 "$hc_url" >/dev/null 2>&1; then ok_flag=1; break; fi
          sleep "$HC_INTERVAL"; elapsed=$((elapsed+HC_INTERVAL))
        done
        [ "$ok_flag" = 1 ] || fail "rollback health failed: $hc_url"
      }

      # ── BAD 마커 처리 ───────────────────────────────────
      mark_bad_if_needed() {
        if [ -n "${CURRENT:-}" ] && [ -d "${CURRENT:-}" ] && [ "$MARK_BAD_ON_ROLLBACK" = "true" ]; then
          sudo sh -c "printf 'marked bad on %s\n' \"$(date -Ins)\" > '$CURRENT/$BAD_MARKER_NAME'"
        fi
      }

      # ── 산출물 패키징 ───────────────────────────────────
      package_artifacts() {
        {
          echo "ROLLED_BACK_FROM=${CURRENT:-}"
          echo "ROLLED_BACK_TO=$TARGET"
          echo "LIVE_LINK=$LIVE_LINK"
          echo "RESOLVED_BY=$RESOLVED_BY"
        } > "$ART_DIR/.env"

        sudo rm -f "$OUT_ZIP"
        ( cd "$ART_DIR" && zip -r "$(basename "$OUT_ZIP")" "$(basename "$LOG")" ".env" >/dev/null 2>&1 || true )
        ok "Diff restore completed"
        echo "$OUT_ZIP"
      }

      # ── 후보 결정 파이프라인 ────────────────────────────
      choose_target() {
        TARGET=""; RESOLVED_BY=""
        resolve_by_name     && return 0
        resolve_by_version  && return 0
        resolve_by_diffbase && return 0
        resolve_by_list     && return 0
        fail "no rollback target could be resolved"
      }

      # ── main ────────────────────────────────────────────
      main() {
        require_envs
        ensure_tools
        setup_context
        get_current_live
        collect_candidates
        choose_target
        switch_live
        apply_tomcat
        healthcheck
        mark_bad_if_needed 
        package_artifacts
      }
      main "$@"

    REMOTE_SH

      log "▶ Executing diff restore via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "WAS_URL='$(shq "$was_url")'" \
        "ROLLBACK_TO_NAME='$(shq "$rollback_to_name")'" \
        "ROLLBACK_TO_VERSION='$(shq "$rollback_to_version")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "RESTORE_LOG_NAME='$(shq "$restore_log_name")'" \
        "MARK_BAD_ON_ROLLBACK='$(shq "$mark_bad_on_rollback")'" \
        "BAD_MARKER_NAME='$(shq "$bad_marker_name")'" \
        'export REMOTE_DIR CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE TOMCAT_SERVICE WAS_URL ROLLBACK_TO_NAME ROLLBACK_TO_VERSION HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL HOT_RELOAD DEPLOY_USER DEPLOY_PASS RESTORE_LOG_NAME MARK_BAD_ON_ROLLBACK BAD_MARKER_NAME; bash -s' \
        < "$remote_script" | tee /tmp/_diff_restore_out.txt

      remote_zip_path="$(tail -n1 /tmp/_diff_restore_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/diff-restore-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_diff_restore_out.txt || true
      ok "Diff restore finished"
    }

# ────────────────────────────────────────────────
# 함수: fn_tomcat_symbolic_deploy
#
# 목적:
#   - Tomcat 운영 서버에 "심링크 전환 방식"으로 새 버전을 배포한다.
#   - LIVE 링크(webapps/<APP_NAME>)를 /opt/tomcat/releases/<APP_NAME>/<APP_NAME>-<version> 로 전환.
#   - 헬스체크 실패 시, 직전 타깃 디렉터리로 자동 롤백한다.
#
# 동작 개요:
#   1) Runner → SSH 접속 → 원격 임시 스크립트 생성
#   2) Nexus에서 NEW WAR 다운로드 및 검사/압축해제
#   3) releases/<APP>/<APP-<version>> 디렉터리 생성 후 WAR unzip 결과 반영
#   4) LIVE 링크를 심링크로 보정(최초 1회, 디렉터리→심링크 마이그레이션)
#   5) LIVE 링크를 새 버전 디렉터리로 원자적 전환 (ln -sfn)
#   6) Tomcat reload 시도(불가 시 restart)
#   7) 헬스체크(HEALTH_MODE 또는 --health-url 대체); 실패 시 자동 롤백
#   8) 보관정책(KEEP_RELEASES) 적용: 오래된 릴리스 디렉터리 삭제
#   9) 로그/메타(.env)를 zip으로 묶어 Runner 아티팩트로 회수
#
# 특징:
#   - 원격 SSH 실행/정리/아티팩트 회수 플로우는 기존과 동일
#   - LIVE가 디렉터리인 레거시 환경을 자동으로 심링크로 전환
#   - Nexus 인증 기반 다운로드(유저/패스), 필요한 툴은 OS별 설치 시도
#   - HOT_RELOAD=true & Tomcat Manager 계정이 있으면 컨텍스트 reload 시도
#   - 실패 시 직전 타깃(심링크의 이전 대상)으로 즉시 되돌림
#
# 생성/수정되는 리소스:
#   - 원격: /opt/tomcat/releases/<APP_NAME>/<APP_NAME>-<version> (새 버전)
#   - 원격: <WEBAPPS_ROOT>/<APP_NAME> (LIVE 심링크)
#   - 원격: <REMOTE_DIR>/artifacts/{symlink-deploy-artifacts.zip, .env, 로그}
#   - 로컬(Runner): artifacts/symlink-deploy-artifacts.zip (회수)
#
# 종료/실패 시나리오:
#   - 헬스체크 실패 시: 라이브 링크를 직전 타깃으로 되돌리고 종료(비정상 종료)
#   - 이전 타깃 부재 시: 롤백 불가로 실패 처리
#
# 권장 전제조건:
#   - Tomcat 서비스명이 정확(TOMCAT_SERVICE), manager(reload) 권한은 선택
#   - releases, webapps 경로에 쓰기 가능(권한/SELinux 정책 환경에 맞춰 운영)
#   - Nexus에 해당 버전 WAR가 존재하고 접근 가능
# ────────────────────────────────────────────────
.fn_tomcat_symbolic_deploy:
  script: |
    fn_tomcat_symbolic_deploy() {
      set -eu

      # ── 필수 입력 ─────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"   # 예: /devops
      : "${ARTIFACT_USER:?ARTIFACT_USER is required}"
      : "${ARTIFACT_GROUP:?ARTIFACT_GROUP is required}"

      # ── 선택 입력(기본값) ───────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"         # tomcat|tomcat9|tomcat10 등
      keep_releases="${KEEP_RELEASES:-5}"

      # 헬스체크 정책
      health_mode="${HEALTH_MODE:-actuator}"             # actuator|page|none
      health_url_override="${HEALTH_URL_OVERRIDE:-}"     # 지정 시 최우선
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      # Tomcat manager 옵션(핫리로드)
      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"

      # 로그/산출물
      deploy_log_name="${DEPLOY_LOG_NAME:-symlink-deploy.log}"

      # [ADD] 프리뷰 필터 모드(정적/동적/해제)
      SAFE_FILTER_MODE="${SAFE_FILTER_MODE:-static}"

      # [NEW] git diff 기준 커밋(옵션)
      BASE_COMMIT="${BASE_COMMIT:-}"

      # ── 유틸 ─────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      #######################################################################
      # 함수: fetch_base_commit_from_remote_live
      # 목적:
      #   - 원격 서버의 LIVE 심링크 또는 디렉터리가 가리키는 현재 버전의
      #     _logs/commit.log 에서 COMMIT 값을 읽어 BASE_COMMIT 변수로 설정
      # 동작 개요:
      #   1. SSH로 원격 접속하여 LIVE 실경로 확인 (readlink -f)
      #   2. commit.log 존재 시 COMMIT= 값 추출
      #   3. 성공 시 BASE_COMMIT 환경 변수로 export
      #######################################################################
      fetch_base_commit_from_remote_live() {
        : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
        : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

        if [ -n "${BASE_COMMIT:-}" ]; then
           log "[INFO] BASE_COMMIT 설정됨 → live 에서 읽기 생략"
        else
          log "[INFO] BASE_COMMIT 미설정 → live 에서 읽기"
          local remote_port="${REMOTE_DEPLOY_PORT:-22}"
          local webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
          local app_name="${CONTEXT_PATH#/}"
          local live_link="${webapps_root%/}/${app_name}"
          local prev_commit=""
         
          log "[SSH] 원격 LIVE commit.log 조회 중: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
         
          prev_commit="$(
            ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "LIVE='$live_link';
               if sudo test -L \"\$LIVE\"; then REAL=\$(sudo readlink -f \"\$LIVE\" 2>/dev/null || true);
               elif sudo test -d \"\$LIVE\"; then REAL=\"\$LIVE\";
               else REAL=\"\"; fi;
               if [ -n \"\$REAL\" ] && sudo test -f \"\$REAL/_logs/commit.log\"; then
                 sudo awk -F= '/^COMMIT=/{print \$2}' \"\$REAL/_logs/commit.log\" | tr -d '\r';
               fi" 2>/dev/null || true
          )"
         
          if [ -n "$prev_commit" ]; then
            export BASE_COMMIT="$prev_commit"
            log "[OK] BASE_COMMIT(from remote LIVE): $BASE_COMMIT"
          else
            log "[WARN] 원격 LIVE commit.log 없음 → BASE_COMMIT 미설정"
          fi
        fi
      }


      #######################################################################
      # [ADD] 함수: build_predicted_list_b64
      # 목적:
      #   - 로컬 git diff를 WAR 내부 경로로 매핑하여 predicted.list 생성 후 base64 인코딩
      #   - PREDICTED_LIST_B64 변수에 저장, 원격에 전달하여 rsync 결과와 교차 비교
      #######################################################################
      build_predicted_list_b64() {
        PREDICTED_LIST_B64=""

        if ! command -v git >/dev/null 2>&1; then
          log "[ADD] git 없음 → 예측 목록 생략"
          return 0
        fi
        if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          log "[ADD] .git 미존재 → 예측 목록 생략"
          return 0
        fi

        # [NEW] HEAD/CURRENT_COMMIT
        local head_ref
        if [ -n "${CI_COMMIT_SHA:-}" ]; then
          head_ref="$CI_COMMIT_SHA"
        else
          head_ref="$(git rev-parse --verify HEAD 2>/dev/null || true)"
        fi
        if [ -z "$head_ref" ]; then
          log "[ADD] HEAD 찾기 실패 → 예측 목록 생략"
          return 0
        fi

        # [NEW] BASE_COMMIT이 최종적으로 없으면 예측 스킵
        local base_ref=""
        if [ -n "${BASE_COMMIT:-}" ]; then
          base_ref="$BASE_COMMIT"
        else
          log "[ADD] BASE_COMMIT 미설정 → 예측 목록 생략"
          return 0
        fi
        if ! git cat-file -e "$base_ref^{commit}" 2>/dev/null; then
          log "[ADD] BASE_COMMIT($base_ref) 유효하지 않음 → 예측 목록 생략"
          return 0
        fi

        local tmpd base rel
        tmpd="$(mktemp -d)"
        # shellcheck disable=SC2064
        trap "rm -rf '$tmpd'" EXIT

        git diff --name-status "$base_ref" "$head_ref" > "$tmpd/changed.tab" || true
        : > "$tmpd/predicted.list"

        while IFS=$'\t' read -r _status path || [ -n "${path:-}" ]; do
          case "$path" in
            src/main/java/*)
              base="${path#src/main/java/}"
              base="${base%.java}"
              printf 'WEB-INF/classes/%s.class\n' "$base" >> "$tmpd/predicted.list"
              ;;
            src/main/resources/*)
              rel="${path#src/main/resources/}"
              printf 'WEB-INF/classes/%s\n' "$rel" >> "$tmpd/predicted.list"
              ;;
            src/main/webapp/*)
              printf '%s\n' "${path#src/main/webapp/}" >> "$tmpd/predicted.list"
              ;;
            *) :;;
          esac
        done < "$tmpd/changed.tab"

        sort -u "$tmpd/predicted.list" -o "$tmpd/predicted.list"

        if command -v base64 >/dev/null 2>&1; then
          if base64 --help 2>&1 | grep -q -- '-w'; then
            PREDICTED_LIST_B64="$(base64 -w0 "$tmpd/predicted.list" || true)"
          else
            PREDICTED_LIST_B64="$(base64 < "$tmpd/predicted.list" | tr -d '\n' || true)"
          fi
        fi
      }

      fetch_base_commit_from_remote_live
      build_predicted_list_b64

      # ── 원격 스크립트 생성 ───────────────────────────
      remote_script=$(mktemp /tmp/remote_symlink_deploy.XXXXXX)
      log "Created temporary symlink deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      #!/usr/bin/env bash
      set -euo pipefail
      IFS=$'\n\t'

      # ── 유틸 ─────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }

      # sudo 기반 탐지 (권한 문제 회피)
      is_link() { sudo test -L "$1"; }                 # 심링크?
      is_dir()  { sudo test -d "$1"; }                 # 디렉터리?
      is_any()  { sudo test -e "$1" || sudo test -L "$1"; } # 어떤 엔트리든 존재?

      # ── ENV 검증/기본값 ─────────────────────────────────
      require_env() {
        : "${REMOTE_DIR:?REMOTE_DIR is required}"
        : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
        : "${GROUP_ID:?GROUP_ID is required}"
        : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
        : "${COMMIT_TAG:?COMMIT_TAG is required}"
        : "${WAS_URL:?WAS_URL is required}"
        : "${NEXUS_USER:?NEXUS_USER is required}"
        : "${NEXUS_PASS:?NEXUS_PASS is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
        : "${WEBAPPS_ROOT:?WEBAPPS_ROOT is required}"
        : "${RELEASES_BASE:?RELEASES_BASE is required}"
        : "${TOMCAT_SERVICE:?TOMCAT_SERVICE is required}"
        : "${KEEP_RELEASES:?KEEP_RELEASES is required}"
        : "${ARTIFACT_USER:?ARTIFACT_USER is required}"
        : "${ARTIFACT_GROUP:?ARTIFACT_GROUP is required}"

        : "${HEALTH_MODE:=actuator}"      # actuator|page|none
        : "${HEALTH_URL_OVERRIDE:=}"      # 지정 시 최우선
        : "${HC_TIMEOUT:=60}"
        : "${HC_INTERVAL:=2}"

        : "${HOT_RELOAD:=false}"
        : "${DEPLOY_USER:=}"
        : "${DEPLOY_PASS:=}"

        : "${DEPLOY_LOG_NAME:=symlink-deploy.log}"
        : "${BAD_MARKER_NAME:=.bad}"
        : "${MARK_BAD_ON_ROLLBACK:=true}"

        # [ADD]
        : "${SAFE_FILTER_MODE:=static}"
        : "${PREDICTED_LIST_B64:=}"

        # [NEW] 현재 배포 커밋 정보(로컬에서 전달)
        : "${CURRENT_COMMIT_SHA:=}"

        APP_NAME="${CONTEXT_PATH#/}"                       # "/devops" → "devops"
        LIVE_LINK="${WEBAPPS_ROOT%/}/${APP_NAME}"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/${APP_NAME}"
        APP_RELEASES_LOGS="${APP_RELEASES_DIR}/_logs"      # [NEW]
        ART_DIR="$REMOTE_DIR/artifacts"
        LOG="$ART_DIR/$DEPLOY_LOG_NAME"
        OUT_ZIP="$ART_DIR/symlink-deploy-artifacts.zip"

        NEW_VERSION="${COMMIT_TAG#v}"
        BASE_URL="${RELEASE_REPO_URL%/}/${GROUP_ID//.//}/${ARTIFACT_ID}"
        NEW_WAR="${ARTIFACT_ID}-${NEW_VERSION}.war"
        NEW_URL="${BASE_URL}/${NEW_VERSION}/${NEW_WAR}"

        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR" "$APP_RELEASES_LOGS"
        sudo sh -c ": > \"$LOG\""
      }

      # ── 도구 보장 ───────────────────────────────────────
      ensure_tools() {
        # [ADD] rsync/텍스트 유틸 포함
        local pkgs=(curl unzip zip ln readlink rsync awk sed grep sort uniq tee realpath base64)

        for t in "${pkgs[@]}"; do
          if ! need "$t"; then
            if   need apk; then
              sudo apk add --no-cache "$t" || true
            elif need apt-get; then
              sudo apt-get update -y || true
              sudo apt-get install -y "$t" || true
            elif need dnf; then
              sudo dnf install -y "$t" || true
            elif need yum; then
              sudo yum install -y "$t" || true
            elif need zypper; then
              sudo zypper --non-interactive install "$t" || true
            else
              log "WARN: unknown package manager; cannot auto-install '$t'"
            fi
          fi
        done

        # 최종 확인
        for t in "${pkgs[@]}"; do
          need "$t" || fail "'$t' not available"
        done
      }

      ensure_owned_dir() { # $1=dir
        sudo mkdir -p "$1"
        sudo chown -R "$ARTIFACT_USER:$ARTIFACT_GROUP" "$1"
        command -v restorecon >/dev/null 2>&1 && sudo restorecon -R "$1" || true
      }

      chown_path() { # $1=path
        sudo chown -R "$ARTIFACT_USER:$ARTIFACT_GROUP" "$1"
        command -v restorecon >/dev/null 2>&1 && sudo restorecon -R "$1" || true
      }
      
      # ── NEW(=새 릴리스) 준비 ────────────────────────────
      prepare_new_version() {
        new_dir="${APP_RELEASES_DIR}/${APP_NAME}-${NEW_VERSION}"
        tmp_dir="${new_dir}.tmp.$$"

        log "Download NEW: $NEW_URL"
        ensure_owned_dir "$tmp_dir"

        # WAR 다운로드는 루트로 받아도 OK → 이후 소유권 정리
        sudo curl -fsS -u "$NEXUS_USER:$NEXUS_PASS" -o "$tmp_dir/$NEW_WAR" "$NEW_URL" \
          | sudo tee -a "$LOG" >/dev/null || true

        # unzip 은 아티팩트 계정으로 수행 
        sudo -u "$ARTIFACT_USER" unzip -q "$tmp_dir/$NEW_WAR" -d "$tmp_dir/unzip"
        sudo test -d "$tmp_dir/unzip/WEB-INF" || fail "WAR structure invalid (no WEB-INF)"

        # 새 릴리스 경로 준비 및 전개
        sudo rm -rf "$new_dir"
        sudo mv "$tmp_dir/unzip" "$new_dir"

        # 최종 소유권/SELinux 컨텍스트 정리
        chown_path "$new_dir"

        # tmp 정리
        sudo rm -rf "$tmp_dir" || true

        printf 'NEW_VERSION=%s\n' "$NEW_VERSION" | sudo tee -a "$LOG" >/dev/null
        printf 'NEW_DIR=%s\n' "$new_dir" | sudo tee -a "$LOG" >/dev/null
      }


      # ── 기존 LIVE → 릴리스로 1회 이관(최초 배포 포함) ─────────
      migrate_live_once() {
        prev_target=""

        log "MIGRATE: probe $(sudo ls -ld "$LIVE_LINK" 2>/dev/null || echo '<not-found>')"

        if is_link "$LIVE_LINK"; then
          prev_target="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
          log "MIGRATE: already symlink -> ${prev_target:-<broken>}"
          return 0
        fi

        if is_dir "$LIVE_LINK"; then
          local legacy="${APP_RELEASES_DIR}/${APP_NAME}-legacy-$(ts)"
          log "MIGRATE: moving DIR to legacy: $legacy"
          sudo mv "$LIVE_LINK" "$legacy"
          prev_target="$legacy"
        elif is_any "$LIVE_LINK"; then
          local legacy="${APP_RELEASES_DIR}/${APP_NAME}-legacy-$(ts).file"
          log "MIGRATE: moving FILE to legacy: $legacy"
          sudo mv "$LIVE_LINK" "$legacy"
        else
          log "MIGRATE: nothing to move (first deploy likely)"
        fi
      }

      # ── 심링크 전환 ─────────────────────────────────────
      ln_s_safe() {
        local tgt="$1" link="$2"
        link="${link%/}"
        sudo ln -sT "$tgt" "$link" 2>/dev/null || sudo ln -s "$tgt" "$link"
      }
      set_live_symlink() {
        local target_dir="$1"
        local tmp_link="${LIVE_LINK}.new.$(ts)"
        ln_s_safe "$target_dir" "$tmp_link"
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || { sudo rm -rf --one-file-system "$LIVE_LINK"; sudo mv "$tmp_link" "$LIVE_LINK"; }
        log "LIVE -> $target_dir"
      }

      # ── 서비스 갱신 ────────────────────────────────────
      tomcat_reload_or_restart() {
        if [ "${HOT_RELOAD}" = "true" ] && [ -n "${DEPLOY_USER}" ] && [ -n "${DEPLOY_PASS}" ] && need curl; then
          curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://${WAS_URL}/manager/text/reload?path=/${APP_NAME}" | sudo tee -a "$LOG" >/dev/null || true
          log "Tomcat manager reload attempted"
          return 0
        fi
        if need systemctl; then
          if sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null; then
            log "Tomcat reload ok"; return 0
          fi
          log "Reload unsupported → restart"
          sudo systemctl restart "$TOMCAT_SERVICE"
          log "Tomcat restart ok"
        fi
      }

      # ── 헬스체크 (URL 생성/대기) ─────────────────────────
      health_url_build() {
        if [ -n "$HEALTH_URL_OVERRIDE" ]; then
          printf '%s\n' "$HEALTH_URL_OVERRIDE"; return
        fi
        case "$HEALTH_MODE" in
          actuator) printf 'http://127.0.0.1:8080/%s/actuator/health\n' "$APP_NAME" ;;
          page)     printf 'http://127.0.0.1:8080/%s/\n' "$APP_NAME" ;;
          none)     printf '\n' ;;
          *)        printf 'http://127.0.0.1:8080/%s/actuator/health\n' "$APP_NAME" ;;
        esac
      }

      health_wait() {
        local url="$1" timeout="$2" interval="$3" elapsed=0
        while [ "$elapsed" -lt "$timeout" ]; do
          if curl -fsS --max-time 3 "$url" >/dev/null 2>&1; then
            log "Health OK: $url"
            return 0
          fi
          sleep "$interval"
          elapsed=$((elapsed+interval))
        done
        return 1
      }

      # ── live-pointer 기록/활용 ──────────────────────────
      ensure_logs_dir() { sudo mkdir -p "$1/_logs"; }

      write_live_pointer() {
        ## $1=current_release_dir, $2=prev_release_dir
        local current="$1" prev="${2:-}"

        # PREV 유효할 때만 기록 (sudo로 검사)
        if [ -z "$prev" ] || ! sudo test -d "$prev"; then
          log "live-pointer: skip write (no valid PREV)"
          return 0
        fi

        ensure_logs_dir "$current"

        sudo sh -c \
          "printf 'CURRENT=%s\nPREV=%s\n' \
            \"\$(readlink -f \"$current\" 2>/dev/null || echo \"$current\")\" \
            \"\$(readlink -f \"$prev\" 2>/dev/null || echo '')\" \
            > \"$current/_logs/live-pointer.env\""

        log "live-pointer.env updated (CURRENT=$(sudo readlink -f "$current" 2>/dev/null || echo "$current"), PREV=$(sudo readlink -f "$prev" 2>/dev/null || echo "$prev"))"
      }

      # 안전한 롤백 후보 탐색
      resolve_prev_for_rollback() {
        local new="$1" prev_hint="${2:-}"
        local live_real="" prev="" rels=() i idx=-1 cand=""

        live_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"

        # 1) 현재 LIVE의 live-pointer.env
        if [ -n "$live_real" ] && sudo test -f "$live_real/_logs/live-pointer.env"; then
          prev="$(sudo awk -F= '/^PREV=/{print $2}' "$live_real/_logs/live-pointer.env" | tr -d '\r')"
          if [ -n "$prev" ] && sudo test -d "$prev" && ! sudo test -f "$prev/$BAD_MARKER_NAME"; then
            printf '%s\n' "$prev"; return 0
          fi
        fi
        # 2) prev_hint (배포 직전 LIVE)
        if [ -n "$prev_hint" ] && sudo test -d "$prev_hint" && ! sudo test -f "$prev_hint/$BAD_MARKER_NAME"; then
          printf '%s\n' "$prev_hint"; return 0
        fi

        # 3) 릴리스 목록에서 new의 바로 이전(older sibling)
        mapfile -t rels < <(sudo ls -1dt "${APP_RELEASES_DIR}/${APP_NAME}-"* 2>/dev/null || true)

        # new 위치
        for i in "${!rels[@]}"; do
          if [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo "${rels[$i]}")" = "$(sudo readlink -f "$new" 2>/dev/null || echo "$new")" ]; then
            idx="$i"; break
          fi
        done
        # 없으면 live_real 기준
        if [ "$idx" -lt 0 ] && [ -n "$live_real" ]; then
          for i in "${!rels[@]}"; do
            if [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo "${rels[$i]}")" = "$live_real" ]; then
              idx="$i"; break
            fi
          done
        fi

        if [ "$idx" -ge 0 ]; then
          for (( i=idx+1; i<${#rels[@]}; i++ )); do
            cand="${rels[$i]}"
            # 자기 자신/현재 LIVE 제외
            [ "$(sudo readlink -f "$cand" 2>/dev/null || echo "$cand")" = "$(sudo readlink -f "$new" 2>/dev/null || echo "$new")" ] && continue
            [ -n "$live_real" ] && [ "$(sudo readlink -f "$cand" 2>/dev/null || echo "$cand")" = "$live_real" ] && continue
            # 유효성 및 .bad 제외
            sudo test -d "$cand" || continue
            sudo test -f "$cand/$BAD_MARKER_NAME" && continue
            printf '%s\n' "$cand"; return 0
          done
        fi

        return 1
      }

      # ───────────────────────────────────────────────────
      # [ADD] PREVIEW: BASE_DIR 결정 (LIVE 기준) + 필터 생성
      # ───────────────────────────────────────────────────
      resolve_base_for_preview() {
        BASE_DIR=""
        if sudo test -L "$LIVE_LINK"; then
          BASE_DIR="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        elif sudo test -d "$LIVE_LINK"; then
          BASE_DIR="$LIVE_LINK"
        elif [ -n "${prev_target:-}" ] && sudo test -d "$prev_target"; then
          BASE_DIR="$prev_target"
        else
          BASE_DIR=""
        fi
      }

      # ───────────────────────────────────────────────
      # [ADD] 필터 생성 (SAFE_FILTER_MODE=static|dynamic|none)
      # ───────────────────────────────────────────────
      make_filter_if_enabled() {
        case "${SAFE_FILTER_MODE:-static}" in
          none|"") return 0 ;;
          static)
            sudo printf '%s\n' \
            '+ /WEB-INF/classes/***' \
            '+ /WEB-INF/lib/***' \
            '+ *.jsp' \
            '+ *.jspf' \
            '+ *.jspx' \
            '+ *.tag' \
            '+ *.tagx' \
            '+ *.tld' \
            '+ /WEB-INF/**/*.jsp' \
            '+ /WEB-INF/**/*.jspf' \
            '+ /WEB-INF/**/*.jspx' \
            '+ /WEB-INF/**/*.tag' \
            '+ /WEB-INF/**/*.tagx' \
            '+ /WEB-INF/**/*.tld' \
            '+ *.html' \
            '+ *.htm' \
            '+ *.css' \
            '+ *.js' \
            '+ *.png' \
            '+ *.jpg' \
            '+ *.jpeg' \
            '+ *.gif' \
            '+ *.svg' \
            '+ *.webp' \
            '+ favicon.ico' \
            '+ *.xml' \
            '+ *.properties' \
            '+ *.yml' \
            '+ *.yaml' \
            '+ MANIFEST.MF' \
            '+ /META-INF/resources/***' \
            '- *' \
            | sudo tee "$RSYNC_FILTER" >/dev/null
            ;;
          dynamic)
            sudo printf '%s\n' \
            '+ /WEB-INF/classes/***' \
            '+ /WEB-INF/lib/***' \
            '+ /META-INF/***' \
            '+ /BOOT-INF/***' \
            '+ /static/***' \
            '+ /public/***' \
            '+ /assets/***' \
            '+ /resources/***' \
            '+ *.css' \
            '+ *.js' \
            '+ *.mjs' \
            '+ *.map' \
            '+ *.json' \
            '+ *.html' \
            '+ *.htm' \
            '+ *.png' \
            '+ *.jpg' \
            '+ *.jpeg' \
            '+ *.gif' \
            '+ *.svg' \
            '+ *.webp' \
            '+ *.jsp' \
            '+ *.jspf' \
            '+ *.jspx' \
            '+ *.tag' \
            '+ *.tagx' \
            '+ *.tld' \
            '+ *.xhtml' \
            '+ /WEB-INF/**/*.jsp' \
            '+ /WEB-INF/**/*.jspf' \
            '+ /WEB-INF/**/*.jspx' \
            '+ /WEB-INF/**/*.tag' \
            '+ /WEB-INF/**/*.tagx' \
            '+ /WEB-INF/**/*.tld' \
            '+ /WEB-INF/**/*.xhtml' \
            '+ *.xml' \
            '+ *.properties' \
            '+ *.yml' \
            '+ *.yaml' \
            '+ *.ini' \
            '+ *.conf' \
            '+ *.cfg' \
            '+ *.env' \
            '+ *.txt' \
            '+ *.csv' \
            '+ *.tsv' \
            '+ *.json5' \
            '+ *.ftl' \
            '+ *.vm' \
            '+ *.mustache' \
            '+ *.hbs' \
            '+ /templates/***' \
            '+ /views/***' \
            '+ MANIFEST.MF' \
            '+ application.properties' \
            '+ application.yml' \
            '+ application.yaml' \
            '+ logback*.xml' \
            '+ logging*.xml' \
            '+ context*.xml' \
            '+ web.xml' \
            '+ robots.txt' \
            '+ sitemap.xml' \
            '+ favicon.ico' \
            '+ .well-known/***' \
            '+ /META-INF/resources/***' \
            '- *' \
            | sudo tee "$RSYNC_FILTER" >/dev/null
            ;;
          *) :;;
        esac
      }

      #######################################################################
      # resolve_base_commit_from_live
      # 목적:
      #   - BASE_COMMIT 미설정 시, 현재 LIVE 심링크가 가리키는 릴리스 디렉터리의
      #     _logs/commit.log 에서 COMMIT 값을 직접 읽어 BASE_COMMIT으로 설정 
      # 동작:
      #   1) LIVE 경로(심링크 또는 디렉터리) → 실경로 계산
      #   2) _logs/commit.log 존재 시 COMMIT= 값 추출
      #   3) 성공 시 BASE_COMMIT 업데이트
      #######################################################################
      resolve_base_commit_from_live() {
        if [ -z "${BASE_COMMIT:-}" ]; then
          # 앱 이름/라이브 경로 계산
          local app_name live_link real_path prev_commit=""
          app_name="${CONTEXT_PATH#/}"                    # "/devops" → "devops"
          live_link="${WEBAPPS_ROOT%/}/${app_name}"
          
          log "LIVE 기준 BASE_COMMIT 획득 시도: ${live_link}"
          
          # LIVE가 심링크이면 readlink -f 로 실경로 추적
          if sudo test -L "$live_link"; then
            real_path="$(sudo readlink -f "$live_link" 2>/dev/null || true)"
          elif sudo test -d "$live_link"; then
            real_path="$live_link"
          else
            real_path=""
          fi
          
          # commit.log 읽기 시도
          if [ -n "$real_path" ] && sudo test -f "$real_path/_logs/commit.log"; then
            prev_commit="$(sudo awk -F= '/^COMMIT=/{print $2}' "$real_path/_logs/commit.log" | tr -d '\r')"
          fi
          
          if [ -n "$prev_commit" ]; then
            BASE_COMMIT="$prev_commit"
            log "BASE_COMMIT(from LIVE commit.log): $BASE_COMMIT"
          else
            log "LIVE commit.log 없음 → git-diff 예측은 생략"
          fi
           fi
      }

      compute_preview_diff() {
        RSYNC_RAW_OUT="$ART_DIR/rsync.out"
        RSYNC_PATHS="$ART_DIR/rsync.paths"
        REPORT_TXT="$ART_DIR/report.txt"
        # [FIX] rsync 필터 파일 경로(함수 공통 사용)
        RSYNC_FILTER="$ART_DIR/rsync.filter"
        
        # 예측 리스트 복원
        if [ -n "${PREDICTED_LIST_B64:-}" ]; then
          echo "$PREDICTED_LIST_B64" | base64 -d > "$ART_DIR/predicted.list" || : 
        else
          : > "$ART_DIR/predicted.list"
        fi

        if [ -z "${BASE_DIR:-}" ] || ! sudo test -d "$BASE_DIR"; then
          log "[ADD] PREVIEW: 유효한 BASE_DIR 없음 (첫 배포 등) → 프리뷰 생략"
          printf "=== Diff Deploy Preview Report ===\n(no BASE_DIR → preview skipped)\n" | sudo tee "$REPORT_TXT" >/dev/null
          return 0
        fi

        make_filter_if_enabled

        common_excludes=(--exclude='_logs' --exclude='_logs/**' \
                         --exclude='*.bad' --exclude='*.tmp' --exclude='*.bak' \
                         --exclude='*.swp' --exclude='*.log')

        if sudo test -f "$ART_DIR/rsync.filter"; then
          sudo rsync -rlpgoDic --delete --dry-run --out-format='%i %n' \
            --filter="merge $ART_DIR/rsync.filter" \
            "${common_excludes[@]}" \
            "${new_dir%/}/" "${BASE_DIR%/}/" | tee "$RSYNC_RAW_OUT" >/dev/null
        else
          sudo rsync -rlpgoDic --delete --dry-run --out-format='%i %n' \
            "${common_excludes[@]}" \
            "${new_dir%/}/" "${BASE_DIR%/}/" | tee "$RSYNC_RAW_OUT" >/dev/null
        fi

        awk '{sub(/^[^ ]+[ ]+/,""); print}' "$RSYNC_RAW_OUT" \
          | sed -e 's#^\.\/##' -e '/\/$/d' \
          | sort -u > "$RSYNC_PATHS" || true

        # 교차 비교
        if [ -s "$ART_DIR/predicted.list" ]; then
          sort -u "$ART_DIR/predicted.list" -o "$ART_DIR/predicted.list"
          comm -12 "$ART_DIR/predicted.list" "$RSYNC_PATHS" > "$ART_DIR/intersection.txt" || true
          comm -23 "$ART_DIR/predicted.list" "$RSYNC_PATHS" > "$ART_DIR/missing.from.rsync.txt" || true
          comm -13 "$ART_DIR/predicted.list" "$RSYNC_PATHS" > "$ART_DIR/extra.in.rsync.txt" || true
        else
          : > "$ART_DIR/intersection.txt"
          : > "$ART_DIR/missing.from.rsync.txt"
          : > "$ART_DIR/extra.in.rsync.txt"
        fi

        {
          echo "=== Diff Deploy Preview Report ==="
          echo "Version   : $NEW_VERSION"
          echo "Context   : $APP_NAME"
          echo "Base Dir  : $BASE_DIR"
          echo "New Dir   : $new_dir"
          echo "Filter    : ${SAFE_FILTER_MODE:-static}"
          echo
          echo "[GIT DIFF 예상 변경 개수]"
          (wc -l < "$ART_DIR/predicted.list") 2>/dev/null || echo 0
          head -30 "$ART_DIR/predicted.list" 2>/dev/null || true
          echo
          echo "[rsync --dry-run 파일 변경 개수]"
          (wc -l < "$RSYNC_PATHS") 2>/dev/null || echo 0
          head -30 "$RSYNC_PATHS" 2>/dev/null || true
          echo
          echo "[교집합] git 예상 ∩ rsync"
          head -30 "$ART_DIR/intersection.txt" 2>/dev/null || true
          echo
          echo "[MISSING] git 변경에는 있지만 rsync 없음"
          head -30 "$ART_DIR/missing.from.rsync.txt" 2>/dev/null || true
          echo
          echo "[EXTRA] rsync에는 있지만 예상에 없음"
          head -30 "$ART_DIR/extra.in.rsync.txt" 2>/dev/null || true
        } | sudo tee "$REPORT_TXT" >/dev/null

        log "[ADD] 프리뷰 리포트 생성: $REPORT_TXT"
      }

      # ── 헬스체크 후 실패 시 롤백 ─────────────────────────
      healthcheck_or_rollback() {
        local hc_url="$1" new="$2" prev_hint="${3:-}"

        if [ -z "$hc_url" ]; then
          log "Health check skipped (mode=none)"; return 0
        fi

        log "Health wait: $hc_url (timeout=${HC_TIMEOUT}s, mode=${HEALTH_MODE})"
        if health_wait "$hc_url" "$HC_TIMEOUT" "$HC_INTERVAL"; then
          return 0
        fi

        echo "[WARN] Health failed → rollback procedure" | sudo tee -a "$LOG" >/dev/null

        # 실패 마킹(옵션)
        if [ "$MARK_BAD_ON_ROLLBACK" = "true" ]; then
          sudo sh -c "printf 'marked bad on %s\n' \"$(date -Ins)\" > '$new/$BAD_MARKER_NAME'"
        fi

        # 안전한 순서로 롤백 대상 탐색
        local prev=""
        if prev="$(resolve_prev_for_rollback "$new" "$prev_hint")"; then
          set_live_symlink "$prev"
          tomcat_reload_or_restart
          health_wait "$hc_url" "$HC_TIMEOUT" "$HC_INTERVAL" || true
          fail "Deploy failed. Rolled back to: $prev"
        fi

        fail "Deploy failed and no previous target to rollback"
      }

      # ── 보존 정책 ───────────────────────────────────────
      prune_releases() {
        mapfile -t rels < <(sudo ls -1dt "${APP_RELEASES_DIR}/${APP_NAME}-"* 2>/dev/null || true)
        [ "${#rels[@]}" -le "$KEEP_RELEASES" ] && { log "Keep-policy: nothing to prune"; return 0; }

        for ((i=KEEP_RELEASES; i<${#rels[@]}; i++)); do
          [ -n "${new_dir:-}" ]     && [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo x)" = "$(sudo readlink -f "$new_dir" 2>/dev/null || echo y)" ] && continue
          [ -n "${prev_target:-}" ] && [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo x)" = "$(sudo readlink -f "$prev_target" 2>/dev/null || echo y)" ] && continue
          base="$(basename "${rels[$i]}")"
          [[ "$base" == "${APP_NAME}-legacy-"* ]] && continue  # 최초 이관 백업 보호
          log "Keep-policy: remove ${rels[$i]}"
          sudo rm -rf --one-file-system "${rels[$i]}" || true
        done
      }

      # ── 산출물 ZIP ─────────────────────────────────────
      package_artifacts() {
        sudo sh -c "printf 'NEW_VERSION=%s\nNEW_DIR=%s\nPREV_DIR=%s\nLIVE_LINK=%s\n' \
          \"$NEW_VERSION\" \"$new_dir\" \"${prev_target:-}\" \"$LIVE_LINK\" > \"$ART_DIR/.env\""

        # [ADD] 프리뷰 산출물도 함께 ZIP에 포함
        sudo sh -c "(cd \"$ART_DIR\" && zip -r \"$(basename "$OUT_ZIP")\" \
          \"$(basename "$LOG")\" \
          .env \
          rsync.out rsync.paths report.txt rsync.filter \
          predicted.list intersection.txt missing.from.rsync.txt extra.in.rsync.txt \
          >/dev/null 2>&1) || true"

        ok "Artifacts packaged: $OUT_ZIP"
        echo "$OUT_ZIP"
      }

      # ───────────────────────────────────────────────
      # [ADD] copy_preview_logs_to_release()
      # 목적:
      #   - 프리뷰 리포트(rsync.out, report.txt 등)를
      #     새 릴리스 디렉터리의 _logs 로 복사
      # ───────────────────────────────────────────────
      copy_preview_logs_to_release() {
        local src_dir="$ART_DIR"
        local dst_logs="$new_dir/_logs"

        sudo mkdir -p "$dst_logs"

        local files=(
          rsync.out
          rsync.paths
          report.txt
          rsync.filter
          predicted.list
          intersection.txt
          missing.from.rsync.txt
          extra.in.rsync.txt
        )

        for f in "${files[@]}"; do
          if sudo test -f "$src_dir/$f"; then
            sudo cp -f "$src_dir/$f" "$dst_logs/" || true
          fi
        done

        log "[ADD] 프리뷰 로그를 ${dst_logs} 에 복사 완료"
      }
      
      # ───────────────────────────────────────────────
      # [NEW] 함수: write_pre_deploy_commit_log_if_missing
      # 목적:
      #   - BASE_COMMIT 값이 있을 경우,
      #     LIVE 디렉터리에 commit.log가 없으면 자동으로 생성
      #   - 기존 commit.log가 있거나 BASE_COMMIT이 비어 있으면 아무 작업 안 함
      # ───────────────────────────────────────────────
      write_pre_deploy_commit_log_if_missing() {
        # BASE_COMMIT이 없으면 스킵
        if [ -z "${BASE_COMMIT:-}" ]; then
          log "[PRE-DEPLOY] BASE_COMMIT 미설정 → commit.log 기록 생략"
          return 0
        fi
      
        # LIVE 실경로 추적 (심링크 or 디렉터리)
        local live_real=""
        if sudo test -L "$LIVE_LINK"; then
          live_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        elif sudo test -d "$LIVE_LINK"; then
          live_real="$LIVE_LINK"
        fi
      
        # 유효한 LIVE가 없으면 스킵
        if [ -z "$live_real" ] || ! sudo test -d "$live_real"; then
          log "[PRE-DEPLOY] LIVE 디렉터리 없음 → commit.log 기록 생략"
          return 0
        fi
      
        # 이미 commit.log가 존재하면 스킵
        local logf="$live_real/_logs/commit.log"
        if sudo test -f "$logf"; then
          log "[PRE-DEPLOY] 기존 commit.log 존재 → skip ($logf)"
          return 0
        fi
      
        # 생성
        sudo mkdir -p "$live_real/_logs"
        sudo sh -c "printf 'COMMIT=%s\nDATE=%s\nNOTE=base_commit_predeploy\n' \
          \"$BASE_COMMIT\" \"\$(date -Iseconds)\" > '$logf'"
        log "[PRE-DEPLOY] commit.log 생성 완료: $logf (COMMIT=$BASE_COMMIT)"
      }

      # ───────────────────────────────────────────────
      # [NEW] 배포 성공 후 releases/_logs/commit.log 기록
      #   - 파일 내용 형식:
      #       COMMIT=<sha>
      #       TAG=<vX.Y.Z>
      #       VERSION=<X.Y.Z>
      #       DATE=<ISO-8601>
      # ───────────────────────────────────────────────
      write_commit_log() {
        # 릴리스 디렉터리 내부 로그 경로
        ensure_logs_dir "$new_dir"
        local file="$new_dir/_logs/commit.log"
        sudo sh -c "printf 'COMMIT=%s\nTAG=%s\nVERSION=%s\nDATE=%s\n' \
          \"$CURRENT_COMMIT_SHA\" \"$COMMIT_TAG\" \"$NEW_VERSION\" \"\$(date -Iseconds)\" > \"$file\""
        log "Wrote commit info to ${file}" 
      }

      # ── 메인 ───────────────────────────────────────────
      main() {
        require_env
        ensure_tools

        prepare_new_version                     # 새 릴리스 디렉터리 생성
        migrate_live_once                       # 기존 LIVE 이관/탐지 (최초 배포면 prev_target 없을 수 있음)
        write_pre_deploy_commit_log_if_missing  # [NEW] LIVE 교체 전 commit.log 보강 (BASE_COMMIT 있을 경우)
  
        # [ADD] PREVIEW: 현재 LIVE(또는 prev_target)와 NEW 간 rsync dry-run 리포트 생성
        resolve_base_for_preview
        compute_preview_diff
        copy_preview_logs_to_release

        resolve_base_commit_from_live    # LIVE → BASE_COMMIT 정보 추출
        set_live_symlink "$new_dir"      # LIVE → 새 버전 전환
        tomcat_reload_or_restart

        hc_url="$(health_url_build)"
        healthcheck_or_rollback "$hc_url" "$new_dir" "${prev_target:-}"  # 실패 시 내부에서 롤백/종료

        write_live_pointer "$new_dir" "${prev_target:-}"  # 헬스 성공 시 포인터 기록
        write_commit_log "$new_dir"                       # [NEW] 성공 시 커밋 기록

        prune_releases
        package_artifacts                # 마지막 줄에 ZIP 경로 echo
      }

      main "$@"

    REMOTE_SH

      # ── 현재 커밋 SHA 계산(원격 commit.log에 기록용) ─────────────
      if [ -n "${CI_COMMIT_SHA:-}" ]; then
        CURRENT_COMMIT_SHA="$CI_COMMIT_SHA"
      elif command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        CURRENT_COMMIT_SHA="$(git rev-parse --verify HEAD 2>/dev/null || echo "")"
      else
        CURRENT_COMMIT_SHA=""
      fi

      # ── 원격 실행 ─────────────────────────────────────
      log "▶ Executing symlink deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "KEEP_RELEASES='$(shq "$keep_releases")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "DEPLOY_LOG_NAME='$(shq "$deploy_log_name")'" \
        "MARK_BAD_ON_ROLLBACK='$(shq "${MARK_BAD_ON_ROLLBACK:-true}")'" \
        "BAD_MARKER_NAME='$(shq "${BAD_MARKER_NAME:-.bad}")'" \
        "SAFE_FILTER_MODE='$(shq "$SAFE_FILTER_MODE")'" \
        "PREDICTED_LIST_B64='$(shq "${PREDICTED_LIST_B64:-}")'" \
        "CURRENT_COMMIT_SHA='$(shq "${CURRENT_COMMIT_SHA:-}")'" \
        "BASE_COMMIT='$(shq "${BASE_COMMIT:-}")'" \
        "ARTIFACT_USER='$(shq "${ARTIFACT_USER:-}")'" \
        "ARTIFACT_GROUP='$(shq "${ARTIFACT_GROUP:-}")'" \
        'export REMOTE_DIR RELEASE_REPO_URL GROUP_ID ARTIFACT_ID COMMIT_TAG WAS_URL NEXUS_USER NEXUS_PASS CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE TOMCAT_SERVICE KEEP_RELEASES HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL HOT_RELOAD DEPLOY_USER DEPLOY_PASS DEPLOY_LOG_NAME MARK_BAD_ON_ROLLBACK BAD_MARKER_NAME SAFE_FILTER_MODE PREDICTED_LIST_B64 CURRENT_COMMIT_SHA BASE_COMMIT ARTIFACT_USER ARTIFACT_GROUP; bash -s' \
        < "$remote_script" | tee /tmp/_symlink_deploy_out.txt

      # 산출물 회수
      remote_zip_path="$(tail -n1 /tmp/_symlink_deploy_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/symlink-deploy-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_symlink_deploy_out.txt || true
      ok "Symlink deploy finished"
    }

.fn_tomcat_deploy_preview:
  script: |
    fn_tomcat_deploy_preview() {
      set -eu

      # ── 필수 입력 ─────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"   # 예: /devops

      # ── 선택 입력(기본값) ───────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"

      # 프리뷰 필터/예측
      SAFE_FILTER_MODE="${SAFE_FILTER_MODE:-static}"   # static|dynamic|none
      BASE_COMMIT="${BASE_COMMIT:-}"                   # git diff base(optional)

      # 로그/산출물
      preview_log_name="${PREVIEW_LOG_NAME:-symlink-preview.log}"

      # ── 로컬 유틸 ─────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── BASE_COMMIT 보강(원격 LIVE의 commit.log에서 추출 시도) ──
      fetch_base_commit_from_remote_live() {
        : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
        : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

        if [ -n "${BASE_COMMIT:-}" ]; then
          log "[INFO] BASE_COMMIT 설정됨 → live 에서 읽기 생략"
          return 0
        fi

        local remote_port="${REMOTE_DEPLOY_PORT:-22}"
        local webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
        local app_name="${CONTEXT_PATH#/}"
        local live_link="${webapps_root%/}/${app_name}"
        local prev_commit=""

        log "[SSH] 원격 LIVE commit.log 조회 중: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"

        prev_commit="$(
          ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
            "LIVE='$live_link';
             if sudo test -L \"\$LIVE\"; then REAL=\$(sudo readlink -f \"\$LIVE\" 2>/dev/null || true);
             elif sudo test -d \"\$LIVE\"; then REAL=\"\$LIVE\"; 
             else REAL=\"\"; fi;
             if [ -n \"\$REAL\" ] && sudo test -f \"\$REAL/_logs/commit.log\"; then
               sudo awk -F= '/^COMMIT=/{print \$2}' \"\$REAL/_logs/commit.log\" | tr -d '\r';
             fi" 2>/dev/null || true
        )"

        if [ -n "$prev_commit" ]; then
          export BASE_COMMIT="$prev_commit"
          log "[OK] BASE_COMMIT(from remote LIVE): $BASE_COMMIT"
        else
          log "[WARN] 원격 LIVE commit.log 없음 → BASE_COMMIT 미설정"
        fi
      }

      # ── 로컬 git diff → predicted.list(base64) ─────────
      build_predicted_list_b64() {
        PREDICTED_LIST_B64=""

        if ! command -v git >/dev/null 2>&1; then
          log "[ADD] git 없음 → 예측 목록 생략"
          return 0
        fi
        if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
          log "[ADD] .git 미존재 → 예측 목록 생략"
          return 0
        fi

        # [NEW] HEAD/CURRENT_COMMIT
        local head_ref
        if [ -n "${CI_COMMIT_SHA:-}" ]; then
          head_ref="$CI_COMMIT_SHA"
        else
          head_ref="$(git rev-parse --verify HEAD 2>/dev/null || true)"
        fi
        if [ -z "$head_ref" ]; then
          log "[ADD] HEAD 찾기 실패 → 예측 목록 생략"
          return 0
        fi

        # [NEW] BASE_COMMIT이 최종적으로 없으면 예측 스킵
        local base_ref=""
        if [ -n "${BASE_COMMIT:-}" ]; then
          base_ref="$BASE_COMMIT"
        else
          log "[ADD] BASE_COMMIT 미설정 → 예측 목록 생략"
          return 0
        fi
        if ! git cat-file -e "$base_ref^{commit}" 2>/dev/null; then
          log "[ADD] BASE_COMMIT($base_ref) 유효하지 않음 → 예측 목록 생략"
          return 0
        fi

        local tmpd base rel
        tmpd="$(mktemp -d)"
        # shellcheck disable=SC2064
        trap "rm -rf '$tmpd'" EXIT

        git diff --name-status "$base_ref" "$head_ref" > "$tmpd/changed.tab" || true
        : > "$tmpd/predicted.list"

        while IFS=$'\t' read -r _status path || [ -n "${path:-}" ]; do
          case "$path" in
            src/main/java/*)
              base="${path#src/main/java/}"
              base="${base%.java}"
              printf 'WEB-INF/classes/%s.class\n' "$base" >> "$tmpd/predicted.list"
              ;;
            src/main/resources/*)
              rel="${path#src/main/resources/}"
              printf 'WEB-INF/classes/%s\n' "$rel" >> "$tmpd/predicted.list"
              ;;
            src/main/webapp/*)
              printf '%s\n' "${path#src/main/webapp/}" >> "$tmpd/predicted.list"
              ;;
            *) :;;
          esac
        done < "$tmpd/changed.tab"

        sort -u "$tmpd/predicted.list" -o "$tmpd/predicted.list"

        if command -v base64 >/dev/null 2>&1; then
          if base64 --help 2>&1 | grep -q -- '-w'; then
            PREDICTED_LIST_B64="$(base64 -w0 "$tmpd/predicted.list" || true)"
          else
            PREDICTED_LIST_B64="$(base64 < "$tmpd/predicted.list" | tr -d '\n' || true)"
          fi
        fi
      }

      fetch_base_commit_from_remote_live
      build_predicted_list_b64

      # ── 원격 스크립트 작성/실행 ─────────────────────────
      remote_script=$(mktemp /tmp/remote_symlink_preview.XXXXXX)
      log "Created temporary symlink preview script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      #!/usr/bin/env bash
      set -euo pipefail
      IFS=$'\n\t'

      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }

      # ENV
      : "${REMOTE_DIR:?}"; : "${RELEASE_REPO_URL:?}"; : "${GROUP_ID:?}"; : "${ARTIFACT_ID:?}"
      : "${COMMIT_TAG:?}"; : "${CONTEXT_PATH:?}"; : "${WEBAPPS_ROOT:?}"; : "${RELEASES_BASE:?}"

      : "${SAFE_FILTER_MODE:=static}"
      : "${PREDICTED_LIST_B64:=}"

      APP_NAME="${CONTEXT_PATH#/}"
      LIVE_LINK="${WEBAPPS_ROOT%/}/${APP_NAME}"
      APP_RELEASES_DIR="${RELEASES_BASE%/}/${APP_NAME}"

      ART_DIR="$REMOTE_DIR/artifacts"
      LOG="$ART_DIR/symlink-preview.log"
      OUT_ZIP="$ART_DIR/symlink-preview-artifacts.zip"

      NEW_VERSION="${COMMIT_TAG#v}"
      BASE_URL="${RELEASE_REPO_URL%/}/${GROUP_ID//.//}/${ARTIFACT_ID}"
      NEW_WAR="${ARTIFACT_ID}-${NEW_VERSION}.war"
      NEW_URL="${BASE_URL}/${NEW_VERSION}/${NEW_WAR}"

      PREVIEW_NEW_DIR="$REMOTE_DIR/preview/${APP_NAME}/${NEW_VERSION}"   # ← releases에 손대지 않음

      sudo mkdir -p "$ART_DIR" "$(dirname "$PREVIEW_NEW_DIR")"
      sudo sh -c ": > \"$LOG\""

      # 도구
      ensure_tools() {
        local pkgs=(curl unzip rsync awk sed sort uniq tee base64)
        for t in "${pkgs[@]}"; do
          need "$t" || {
            if   need apk; then sudo apk add --no-cache "$t" || true
            elif need apt-get; then sudo apt-get update -y || true; sudo apt-get install -y "$t" || true
            elif need dnf; then sudo dnf install -y "$t" || true
            elif need yum; then sudo yum install -y "$t" || true
            elif need zypper; then sudo zypper -n install "$t" || true
            fi
          }
        done
        for t in "${pkgs[@]}"; do need "$t" || fail "'$t' not available"; done
      }

      # NEW(미리보기 전용) 준비: REMOTE_DIR/preview/... 에만 전개
      prepare_preview_new() {
        local tmp="$PREVIEW_NEW_DIR.tmp.$$"
        sudo rm -rf "$PREVIEW_NEW_DIR" "$tmp"
        sudo mkdir -p "$tmp"
        log "Download NEW (preview only): $NEW_URL"
        sudo curl -fsS -o "$tmp/$NEW_WAR" "$NEW_URL"
        sudo unzip -q "$tmp/$NEW_WAR" -d "$tmp/unzip"
        sudo test -d "$tmp/unzip/WEB-INF" || fail "WAR invalid (no WEB-INF)"
        sudo mv "$tmp/unzip" "$PREVIEW_NEW_DIR"
        sudo rm -rf "$tmp"
        printf 'NEW_DIR(PREVIEW)=%s\n' "$PREVIEW_NEW_DIR" | sudo tee -a "$LOG" >/dev/null
      }

      # BASE_DIR 결정: LIVE만 참조(심링크 실경로 또는 디렉터리)
      resolve_base_from_live() {
        BASE_DIR=""
        if sudo test -L "$LIVE_LINK"; then
          BASE_DIR="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        elif sudo test -d "$LIVE_LINK"; then
          BASE_DIR="$LIVE_LINK"
        fi
        if [ -z "$BASE_DIR" ] || ! sudo test -d "$BASE_DIR"; then
          log "No valid BASE_DIR (first deploy scenario?) → preview will be marked as skipped."
        else
          printf 'BASE_DIR=%s\n' "$BASE_DIR" | sudo tee -a "$LOG" >/dev/null
        fi
      }

      # 필터
      make_filter_if_enabled() {
        RSYNC_FILTER="$ART_DIR/rsync.filter"
        case "$SAFE_FILTER_MODE" in
          none|"") : > "$RSYNC_FILTER"; return 0 ;;
          static)
            sudo printf '%s\n' \
              '+ /WEB-INF/classes/***' '+ /WEB-INF/lib/***' \
              '+ *.jsp' '+ *.jspf' '+ *.jspx' '+ *.tag' '+ *.tagx' '+ *.tld' \
              '+ /WEB-INF/**/*.jsp' '+ /WEB-INF/**/*.jspf' '+ /WEB-INF/**/*.jspx' '+ /WEB-INF/**/*.tag' '+ /WEB-INF/**/*.tagx' '+ /WEB-INF/**/*.tld' \
              '+ *.html' '+ *.htm' '+ *.css' '+ *.js' \
              '+ *.png' '+ *.jpg' '+ *.jpeg' '+ *.gif' '+ *.svg' '+ *.webp' 'favicon.ico' \
              '+ *.xml' '+ *.properties' '+ *.yml' '+ *.yaml' 'MANIFEST.MF' \
              '+ /META-INF/resources/***' \
              '- *' \
              | sudo tee "$RSYNC_FILTER" >/dev/null
            ;;
          dynamic)
            sudo printf '%s\n' \
              '+ /WEB-INF/classes/***' '+ /WEB-INF/lib/***' '+ /META-INF/***' '+ /BOOT-INF/***' \
              '+ /static/***' '+ /public/***' '+ /assets/***' '+ /resources/***' \
              '+ *.css' '+ *.js' '+ *.mjs' '+ *.map' '+ *.json' \
              '+ *.html' '+ *.htm' '+ *.png' '+ *.jpg' '+ *.jpeg' '+ *.gif' '+ *.svg' '+ *.webp' \
              '+ *.jsp' '+ *.jspf' '+ *.jspx' '+ *.tag' '+ *.tagx' '+ *.tld' '+ *.xhtml' \
              '+ /WEB-INF/**/*.jsp' '+ /WEB-INF/**/*.jspf' '+ /WEB-INF/**/*.jspx' '+ /WEB-INF/**/*.tag' '+ /WEB-INF/**/*.tagx' '+ /WEB-INF/**/*.tld' '+ /WEB-INF/**/*.xhtml' \
              '+ *.xml' '+ *.properties' '+ *.yml' '+ *.yaml' '+ *.ini' '+ *.conf' '+ *.cfg' '+ *.env' \
              '+ *.txt' '+ *.csv' '+ *.tsv' '+ *.json5' '+ *.ftl' '+ *.vm' '+ *.mustache' '+ *.hbs' \
              '+ /templates/***' '+ /views/***' 'MANIFEST.MF' \
              'application.properties' 'application.yml' 'application.yaml' \
              'logback*.xml' 'logging*.xml' 'context*.xml' 'web.xml' 'robots.txt' 'sitemap.xml' 'favicon.ico' \
              '+ .well-known/***' '+ /META-INF/resources/***' \
              '- *' \
              | sudo tee "$RSYNC_FILTER" >/dev/null
            ;;
        esac
      }

      # 예측 리스트 복원
      restore_predicted_list() {
        if [ -n "${PREDICTED_LIST_B64:-}" ]; then
          echo "$PREDICTED_LIST_B64" | base64 -d > "$ART_DIR/predicted.list" || :
        else
          : > "$ART_DIR/predicted.list"
        fi
      }

      # 프리뷰 계산 (절대 실제 반영 없음)
      compute_preview() {
        RSYNC_RAW_OUT="$ART_DIR/rsync.out"
        RSYNC_PATHS="$ART_DIR/rsync.paths"
        REPORT_TXT="$ART_DIR/report.txt"

        if [ -z "${BASE_DIR:-}" ] || ! sudo test -d "$BASE_DIR"; then
          printf "=== Diff Deploy Preview Report ===\n(no BASE_DIR → preview skipped)\n" | sudo tee "$REPORT_TXT" >/dev/null
          return 0
        fi

        make_filter_if_enabled
        restore_predicted_list

        common_excludes=(--exclude='_logs' --exclude='_logs/**' --exclude='*.bad' --exclude='*.tmp' --exclude='*.bak' --exclude='*.swp' --exclude='*.log')

        sudo rsync -rlDic --delete --dry-run --out-format='%i %n' \
          --filter="merge $ART_DIR/rsync.filter" \
          "${common_excludes[@]}" \
          "${PREVIEW_NEW_DIR%/}/" "${BASE_DIR%/}/" | tee "$RSYNC_RAW_OUT" >/dev/null

        awk '{sub(/^[^ ]+[ ]+/,""); print}' "$RSYNC_RAW_OUT" \
        | sed -e 's#^\.\/##' -e '/\/$/d' \
        | sort -u > "$RSYNC_PATHS" || true

        if [ -s "$ART_DIR/predicted.list" ]; then
          sort -u "$ART_DIR/predicted.list" -o "$ART_DIR/predicted.list"
          comm -12 "$ART_DIR/predicted.list" "$RSYNC_PATHS" > "$ART_DIR/intersection.txt" || true
          comm -23 "$ART_DIR/predicted.list" "$RSYNC_PATHS" > "$ART_DIR/missing.from.rsync.txt" || true
          comm -13 "$ART_DIR/predicted.list" "$RSYNC_PATHS" > "$ART_DIR/extra.in.rsync.txt" || true
        else
          : > "$ART_DIR/intersection.txt"; : > "$ART_DIR/missing.from.rsync.txt"; : > "$ART_DIR/extra.in.rsync.txt"
        fi

        {
          echo "=== Diff Deploy Preview Report ==="
          echo "Version   : $NEW_VERSION"
          echo "Context   : $APP_NAME"
          echo "Base Dir  : $BASE_DIR"
          echo "New Dir   : $PREVIEW_NEW_DIR"
          echo "Filter    : ${SAFE_FILTER_MODE:-static}"
          echo
          echo "[GIT DIFF 예상 변경 개수]"
          (wc -l < "$ART_DIR/predicted.list") 2>/dev/null || echo 0
          head -30 "$ART_DIR/predicted.list" 2>/dev/null || true
          echo
          echo "[rsync --dry-run 파일 변경 개수]"
          (wc -l < "$RSYNC_PATHS") 2>/dev/null || echo 0
          head -30 "$RSYNC_PATHS" 2>/dev/null || true
          echo
          echo "[교집합] git 예상 ∩ rsync"
          head -30 "$ART_DIR/intersection.txt" 2>/dev/null || true
          echo
          echo "[MISSING] git 변경에는 있지만 rsync 없음"
          head -30 "$ART_DIR/missing.from.rsync.txt" 2>/dev/null || true
          echo
          echo "[EXTRA] rsync에는 있지만 예상에 없음"
          head -30 "$ART_DIR/extra.in.rsync.txt" 2>/dev/null || true
        } | sudo tee "$REPORT_TXT" >/dev/null

        log "Preview report generated: $REPORT_TXT"
      }

      package_artifacts() {
        sudo sh -c "printf 'NEW_VERSION=%s\nPREVIEW_NEW_DIR=%s\nLIVE_BASE_DIR=%s\nLIVE_LINK=%s\n' \
          \"$NEW_VERSION\" \"$PREVIEW_NEW_DIR\" \"${BASE_DIR:-}\" \"$LIVE_LINK\" > \"$ART_DIR/.env\""

        sudo sh -c "(cd \"$ART_DIR\" && zip -r \"$(basename "$OUT_ZIP")\" \
          \"$(basename "$LOG")\" \
          .env \
          rsync.out rsync.paths report.txt rsync.filter \
          predicted.list intersection.txt missing.from.rsync.txt extra.in.rsync.txt \
          >/dev/null 2>&1) || true"

        ok "Artifacts packaged: $OUT_ZIP"
        echo "$OUT_ZIP"
      }

      main() {
        ensure_tools
        prepare_preview_new          # REMOTE_DIR/preview/... 만 사용
        resolve_base_from_live       # LIVE 기준 BASE_DIR, 없으면 preview skipped
        compute_preview              # dry-run only
        package_artifacts            # zip 경로 echo
        ok "Symlink preview completed (no deployment performed)"
      }

      main
    REMOTE_SH

      # ── 원격 실행 ─────────────────────────────────────
      log "▶ Executing symlink preview via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "SAFE_FILTER_MODE='$(shq "$SAFE_FILTER_MODE")'" \
        "PREDICTED_LIST_B64='$(shq "${PREDICTED_LIST_B64:-}")'" \
        'export REMOTE_DIR RELEASE_REPO_URL GROUP_ID ARTIFACT_ID COMMIT_TAG CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE SAFE_FILTER_MODE PREDICTED_LIST_B64; bash -s' \
        < "$remote_script" | tee /tmp/_symlink_preview_out.txt

      # ── 산출물 회수 ─────────────────────────────────── 
      remote_zip_path="$(
        sed -n 's#^\(/.*symlink-preview-artifacts\.zip\)$#\1#p' /tmp/_symlink_preview_out.txt | tail -n1
      )"

      if [ -z "$remote_zip_path" ]; then
        echo "[ERR] zip path not found in /tmp/_symlink_preview_out.txt"
        echo "--- preview output ---"
        cat /tmp/_symlink_preview_out.txt || true
        exit 1
      fi

      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      echo "[DEBUG] remote_zip_path=$remote_zip_path"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/"

      local_zip="$local_dir/$(basename "$remote_zip_path")"
      [ -s "$local_zip" ] || { echo "[ERR] not found: $local_zip"; ls -lAh "$local_dir"; exit 1; }


      ok "Symlink preview finished: $local_zip"

    }


# ────────────────────────────────────────────────
# 함수: fn_tomcat_symbolic_restore
#
# 목적:
#   - LIVE 심링크를 “이전 릴리스 디렉터리” 또는 지정 버전 디렉터리로 되돌려 롤백한다.
#   - (선택) 헬스체크 수행. 실패 시 실패로 종료(필요 시 한 단계 더 이전으로 수동 롤백).
#
# 동작 개요:
#
# 특징:
#   - diff(증분) 복원 방식이 아닌, “심링크 전환” 기반의 즉시 롤백
#   - 지정 버전으로의 직접 롤백이나 자동 이전 롤백 둘 다 지원
#   - Runner 아티팩트로 롤백 로그/메타 제공
#
# 생성/수정되는 리소스:
#   - 원격: LIVE 링크(<WEBAPPS_ROOT>/<APP_NAME>) → /opt/tomcat/releases/<APP>/<APP-<version>>
#   - 원격: <REMOTE_DIR>/artifacts/symlink-rollback-artifacts.zip
#   - 로컬(Runner): artifacts/symlink-rollback-artifacts.zip
#
# 실패 시나리오:
#   - 대상 디렉터리 부재(잘못된 버전 지정/보관정책으로 삭제됨) 시 실패
#   - 헬스체크 실패 시 실패(필요하면 한 단계 더 이전 버전으로 수동 재시도)
#
# 권장 전제조건:
#   - releases 디렉터리에 유효한 이전 버전 디렉터리 존재
#   - Tomcat 재적용(reload/restart) 권한 보유
# ────────────────────────────────────────────────
.fn_tomcat_symbolic_restore:
  script: |
    fn_tomcat_symbolic_restore() {
      set -eu

      # ── 필수 ──────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
      : "${WAS_URL:?WAS_URL is required}"

      # ── 선택 ──────────────────────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"
      rollback_to_version="${ROLLBACK_TO_VERSION:-}"   # 지정 시 해당 버전으로 롤백

      # Tomcat manager 옵션(핫리로드)
      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"

      # 헬스체크 정책
      health_mode="${HEALTH_MODE:-actuator}"           # actuator|page|none
      health_url_override="${HEALTH_URL_OVERRIDE:-}"
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      # 로그/산출물
      restore_log_name="${RESTORE_LOG_NAME:-symlink-rollback.log}"

      # ── 유틸 ──────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 원격 스크립트 생성 ───────────────────────────
      remote_script=$(mktemp /tmp/remote_symlink_rollback.XXXXXX)
      log "Created temporary symlink rollback script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      #!/usr/bin/env bash
      set -euo pipefail
      IFS=$'\n\t'

      # ──────────────────────────────────────────────────────────────
      # 유틸리티
      # ──────────────────────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }

      # sudo 기반 테스트(권한 문제 회피)
      is_link() { sudo test -L "$1"; }                            # 심볼릭 링크인가?
      is_dir()  { sudo test -d "$1"; }                            # 디렉터리인가?
      is_any()  { sudo test -e "$1" || sudo test -L "$1"; }       # 어떤 엔트리든 존재하는가?

      # ──────────────────────────────────────────────────────────────
      # 환경 변수 검증 및 기본값 설정
      # ──────────────────────────────────────────────────────────────
      require_env() {
        : "${CONTEXT_PATH:?CONTEXT_PATH 필요(예: /myapp)}"
        : "${WEBAPPS_ROOT:?WEBAPPS_ROOT 필요(예: /opt/tomcat/webapps)}"
        : "${RELEASES_BASE:?RELEASES_BASE 필요(예: /opt/tomcat/releases)}"
        : "${TOMCAT_SERVICE:?TOMCAT_SERVICE 필요(예: tomcat)}"

        : "${REMOTE_DIR:?REMOTE_DIR 필요(예: /var/tmp/deploy)}"
        : "${RESTORE_LOG_NAME:=symlink-rollback.log}"   # 출력 로그 파일명

        : "${HEALTH_MODE:=actuator}"                    # actuator|page|none
        : "${HEALTH_URL_OVERRIDE:=}"
        : "${HC_TIMEOUT:=60}"
        : "${HC_INTERVAL:=2}"
        : "${WAS_URL:?WAS_URL 필요(host:port)}"

        : "${HOT_RELOAD:=false}"                        # Tomcat manager reload 사용 여부
        : "${DEPLOY_USER:=}"                            # manager reload 계정
        : "${DEPLOY_PASS:=}"

        : "${ROLLBACK_TO_VERSION:=}"                    # 명시적 버전 롤백 시 사용(선택)
        : "${BAD_MARKER_NAME:=.bad}"                    # 불량 마커 파일명
        : "${MARK_BAD_ON_ROLLBACK:=true}"               # 롤백 성공 후 이전 CURRENT에 bad 마커 남길지

        APP_NAME="${CONTEXT_PATH#/}"                    # "/myapp" → "myapp"
        LIVE_LINK="${WEBAPPS_ROOT%/}/${APP_NAME}"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/${APP_NAME}"

        ART_DIR="${REMOTE_DIR%/}/artifacts"
        LOG="$ART_DIR/$RESTORE_LOG_NAME"
        OUT_ZIP="$ART_DIR/symlink-rollback-artifacts.zip"

        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
        # 로그 파일 초기화(root 소유여도 무방)
        sudo sh -c ": > \"$LOG\""
      }

      # ──────────────────────────────────────────────────────────────
      # 필요한 도구 확인(가능하면 설치) 및 최종 보증
      # ──────────────────────────────────────────────────────────────
      ensure_tools() {
        local pkgs=(ln readlink zip ls curl awk)

        for t in "${pkgs[@]}"; do
          if ! need "$t"; then
            if   need apk; then
              sudo apk add --no-cache "$t" || true
            elif need apt-get; then
              sudo apt-get update -y || true
              sudo apt-get install -y "$t" || true
            elif need dnf; then
              sudo dnf install -y "$t" || true
            elif need yum; then
              sudo yum install -y "$t" || true
            elif need zypper; then
              sudo zypper --non-interactive install "$t" || true
            else
              log "WARN: 패키지 매니저를 찾을 수 없어 '$t' 자동 설치 불가"
            fi
          fi
        done

        # 최종 확인(없으면 명확히 실패)
        for t in "${pkgs[@]}"; do
          need "$t" || fail "'$t' 사용 불가"
        done
      }

      # ──────────────────────────────────────────────────────────────
      # 심볼릭 링크 헬퍼
      # ──────────────────────────────────────────────────────────────
      ln_s_safe() {
        local tgt="$1" link="$2"
        link="${link%/}"
        sudo ln -sT "$tgt" "$link" 2>/dev/null || sudo ln -s "$tgt" "$link"
      }
      set_live_symlink() {
        local target_dir="$1"
        local tmp_link="${LIVE_LINK}.new.$(ts)"
        ln_s_safe "$target_dir" "$tmp_link"
        # 원자적 교체: mv -T(gnu) → 실패 시 수동 교체
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || {
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo mv "$tmp_link" "$LIVE_LINK"
        }
        log "LIVE -> $target_dir"
      }

      # ──────────────────────────────────────────────────────────────
      # 1회성 마이그레이션: LIVE가 심볼릭 링크가 아니면(디렉터리/파일) releases로 백업
      # ──────────────────────────────────────────────────────────────
      migrate_live_once() {
        local releases_base_dir="$1"
        sudo mkdir -p "$releases_base_dir"

        log "MIGRATE: probe $(sudo ls -ld "$LIVE_LINK" 2>/dev/null || echo '<not-found>')"

        if is_link "$LIVE_LINK"; then
          log "MIGRATE: 이미 심볼릭 링크 -> $(sudo readlink -f "$LIVE_LINK" 2>/dev/null || echo '<broken>')"
          return 0
        fi

        if is_dir "$LIVE_LINK"; then
          local legacy="${releases_base_dir}/${APP_NAME}-legacy-$(ts)"
          log "MIGRATE: LIVE 디렉터리를 legacy로 이동: $legacy"
          sudo mv "$LIVE_LINK" "$legacy"
          log "MIGRATE: 이동됨 -> $(sudo ls -ld "$legacy")"
        elif is_any "$LIVE_LINK"; then
          local legacy="${releases_base_dir}/${APP_NAME}-legacy-$(ts).file"
          log "MIGRATE: LIVE 파일을 legacy로 이동: $legacy"
          sudo mv "$LIVE_LINK" "$legacy"
          log "MIGRATE: 이동됨 -> $(sudo ls -l "$legacy")"
        else
          log "MIGRATE: 이동할 대상 없음(첫 심볼릭 전환 상황)"
        fi
      }

      # ──────────────────────────────────────────────────────────────
      # Tomcat reload/restart(Tomcat Manager reload 옵션 지원)
      # ──────────────────────────────────────────────────────────────
      tomcat_reload_or_restart() {
        if [ "$HOT_RELOAD" = "true" ] && [ -n "$DEPLOY_USER" ] && [ -n "$DEPLOY_PASS" ] && need curl; then
          curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://${WAS_URL}/manager/text/reload?path=/${APP_NAME}" \
            | sudo tee -a "$LOG" >/dev/null || true
          log "Tomcat manager reload 요청 완료"
          return 0
        fi
        if need systemctl; then
          if sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null; then
            log "Tomcat reload 성공"; return 0
          fi
          log "Reload 미지원 → restart 시도"
          sudo systemctl restart "$TOMCAT_SERVICE"
          log "Tomcat restart 성공"
        fi
      }

      # ──────────────────────────────────────────────────────────────
      # 헬스체크(URL 생성 + 대기)
      # ──────────────────────────────────────────────────────────────
      health_url_build() {
        if [ -n "$HEALTH_URL_OVERRIDE" ]; then
          printf '%s\n' "$HEALTH_URL_OVERRIDE"; return
        fi
        case "$HEALTH_MODE" in
          actuator) printf 'http://127.0.0.1:8080/%s/actuator/health\n' "$APP_NAME" ;;
          page)     printf 'http://127.0.0.1:8080/%s/\n' "$APP_NAME" ;;
          none)     printf '\n' ;;
          *)        printf 'http://127.0.0.1:8080/%s/actuator/health\n' "$APP_NAME" ;;
        esac
      }
      health_wait() {
        local url="$1" timeout="$2" interval="$3" elapsed=0
        while [ "$elapsed" -lt "$timeout" ]; do
          if curl -fsS --max-time 3 "$url" >/dev/null 2>&1; then
            log "Health OK: $url"
            return 0
          fi
          sleep "$interval"
          elapsed=$((elapsed+interval))
        done
        return 1
      }

      # ──────────────────────────────────────────────────────────────
      # live-pointer 헬퍼(CURRENT/PREV)
      # ──────────────────────────────────────────────────────────────
      read_live_pointer_prev() {
        # CURRENT/_logs/live-pointer.env 에서 PREV 읽기
        local current_real prev
        current_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        if [ -z "$current_real" ]; then
          return 1
        fi
        if sudo test -f "$current_real/_logs/live-pointer.env"; then
          prev="$(sudo awk -F= '/^PREV=/{print $2}' "$current_real/_logs/live-pointer.env" | tr -d '\r')"
          if [ -n "$prev" ] && sudo test -d "$prev"; then
            printf '%s\n' "$prev"
            return 0
          fi
        fi
        return 1
      }

      # ──────────────────────────────────────────────────────────────
      # 후보 릴리스 목록 생성(최신순), .bad 제외
      # ──────────────────────────────────────────────────────────────
      list_candidates() {
        # 최신 → 오래된 순서로 릴리스 디렉터리 출력, .bad 는 스킵
        sudo ls -1dt "${APP_RELEASES_DIR}/${APP_NAME}-"* 2>/dev/null \
        | while read -r d; do
            if sudo test -f "$d/$BAD_MARKER_NAME"; then
              continue
            fi
            printf "%s\n" "$d"
          done
      }

      # ──────────────────────────────────────────────────────────────
      # 롤백 대상 선택(안전 순서)
      # 1) ROLLBACK_TO_VERSION 이 지정되면 그 버전 사용(존재 & .bad 아님)
      # 2) live-pointer의 PREV 가 있으면 그 경로 사용
      # 3) 그렇지 않으면 CURRENT의 "직전(older sibling)" 1개 선택
      #    - CURRENT 자신 제외
      #    - .bad 제외
      # ──────────────────────────────────────────────────────────────
      choose_target() {
        local target="" current_real="" cand prev_hint="" rel
        local -a rels=()
        local i idx=-1

        # 1) 명시적 버전 우선
        if [ -n "$ROLLBACK_TO_VERSION" ]; then
          cand="${APP_RELEASES_DIR}/${APP_NAME}-${ROLLBACK_TO_VERSION}"
          if sudo test -d "$cand"; then
            if ! sudo test -f "$cand/$BAD_MARKER_NAME"; then
              printf '%s\n' "$cand"; return 0
            else
              fail "명시 대상에 BAD 마커 존재: $cand/$BAD_MARKER_NAME"
            fi
          else
            fail "명시 대상 버전을 찾을 수 없음: $cand"
          fi
        fi

        # LIVE가 심볼릭이 아니면 1회 마이그레이션
        if ! is_link "$LIVE_LINK"; then
          migrate_live_once "$APP_RELEASES_DIR"
        fi

        # CURRENT(실경로)
        current_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        printf 'CURRENT=%s\n' "${current_real:-}" | sudo tee -a "$LOG" >/dev/null

        # 2) live-pointer PREV 우선 시도
        if prev_hint="$(read_live_pointer_prev)"; then
          printf '%s\n' "$prev_hint"; return 0
        fi

        # 3) 후보 목록에서 CURRENT의 바로 이전 선택
        mapfile -t rels < <(list_candidates)
        # 후보가 하나도 없으면 실패
        [ "${#rels[@]}" -gt 0 ] || return 1

        # 후보 목록에서 CURRENT의 인덱스 찾기
        if [ -n "$current_real" ]; then
          for i in "${!rels[@]}"; do
            if [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo "${rels[$i]}")" = "$current_real" ]; then
              idx="$i"; break
            fi
          done
        fi

        # CURRENT를 찾았으면 그 다음(오래된 것) 반환
        if [ "$idx" -ge 0 ]; then
          for (( i=idx+1; i<${#rels[@]}; i++ )); do
            rel="${rels[$i]}"
            sudo test -d "$rel" || continue
            printf '%s\n' "$rel"; return 0
          done
          # CURRENT가 가장 오래된 항목이라면 롤백 불가
          return 1
        fi

        # CURRENT를 목록에서 못 찾은 경우(엣지): CURRENT와 다른 최신 후보 반환
        for rel in "${rels[@]}"; do
          [ -n "$current_real" ] && [ "$(sudo readlink -f "$rel" 2>/dev/null || echo "$rel")" = "$current_real" ] && continue
          printf '%s\n' "$rel"; return 0
        done

        return 1
      }

      # ──────────────────────────────────────────────────────────────
      # 전환 후 헬스체크(wrapper)
      # ──────────────────────────────────────────────────────────────
      post_switch_health_or_fail() {
        local hc_url
        hc_url="$(health_url_build)"
        if [ -z "$hc_url" ] || ! need curl; then
          log "헬스체크 생략"
          return 0
        fi
        log "헬스 대기: $hc_url (timeout=${HC_TIMEOUT}s, mode=${HEALTH_MODE})"
        health_wait "$hc_url" "$HC_TIMEOUT" "$HC_INTERVAL" || fail "롤백 후 헬스 실패: $hc_url"
      }

      # ──────────────────────────────────────────────────────────────
      # 이전 CURRENT에 BAD 마커 생성(롤백 성공 이후만)
      # ──────────────────────────────────────────────────────────────
      mark_previous_current_bad() {
        local previous_current="$1"
        if [ -n "$previous_current" ] && sudo test -d "$previous_current" && [ "$MARK_BAD_ON_ROLLBACK" = "true" ]; then
          sudo sh -c "printf 'marked bad on %s\n' \"$(date -Ins)\" > '$previous_current/$BAD_MARKER_NAME'"
        fi
      }

      # ──────────────────────────────────────────────────────────────
      # 산출물 패키징(zip)
      # ──────────────────────────────────────────────────────────────
      package_artifacts() {
        local target="$1"
        sudo sh -c "printf 'ROLLED_BACK_TO=%s\nLIVE_LINK=%s\n' \
          \"$target\" \"$LIVE_LINK\" > \"$ART_DIR/.env\""
        sudo sh -c "(cd \"$ART_DIR\" && zip -r \"$(basename "$OUT_ZIP")\" \"$(basename "$LOG")\" .env >/dev/null 2>&1) || true"
        ok "Artifacts packaged: $OUT_ZIP"
        echo "$OUT_ZIP"
      }

      # ──────────────────────────────────────────────────────────────
      # 메인
      # ──────────────────────────────────────────────────────────────
      main() {
        require_env
        ensure_tools

        # 전환 전 CURRENT 기록(디버그용)
        local current_real=""
        if is_link "$LIVE_LINK"; then
          current_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        fi
        printf 'CURRENT(before)=%s\n' "${current_real:-}" | sudo tee -a "$LOG" >/dev/null

        # 롤백 대상 결정
        local target=""
        if ! target="$(choose_target)"; then
          # 디버그를 위해 사용 가능한 릴리스 나열
          echo "AVAILABLE_RELEASES:" | sudo tee -a "$LOG" >/dev/null
          list_candidates | sed 's/^/ - /' | sudo tee -a "$LOG" >/dev/null || true
          fail "롤백 대상을 결정할 수 없습니다"
        fi
        printf 'TARGET=%s\n' "$target" | sudo tee -a "$LOG" >/dev/null

        # LIVE → target 전환
        set_live_symlink "$target"

        # Tomcat reload/restart 적용
        tomcat_reload_or_restart

        # 헬스체크(설정된 경우)
        post_switch_health_or_fail

        # 롤백 성공 후 이전 CURRENT에 BAD 마커 표시(옵션)
        mark_previous_current_bad "$current_real"

        # 산출물 패키징
        package_artifacts "$target"

        ok "Symlink rollback completed"
      }

      main "$@"




    REMOTE_SH

      # ── 원격 실행 ─────────────────────────────────────
      log "▶ Executing symlink rollback via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "ROLLBACK_TO_VERSION='$(shq "$rollback_to_version")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "RESTORE_LOG_NAME='$(shq "$restore_log_name")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "MARK_BAD_ON_ROLLBACK='$(shq "${MARK_BAD_ON_ROLLBACK:-true}")'" \
        "BAD_MARKER_NAME='$(shq "${BAD_MARKER_NAME:-.bad}")'" \
        'export REMOTE_DIR CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE TOMCAT_SERVICE ROLLBACK_TO_VERSION HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL RESTORE_LOG_NAME HOT_RELOAD DEPLOY_USER DEPLOY_PASS WAS_URL MARK_BAD_ON_ROLLBACK BAD_MARKER_NAME; bash -s' \
        < "$remote_script" | tee /tmp/_symlink_rollback_out.txt

      # ── 산출물 회수 ───────────────────────────────────
      remote_zip_path="$(tail -n1 /tmp/_symlink_rollback_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/symlink-rollback-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_symlink_rollback_out.txt || true
      ok "Symlink rollback finished"
    }
