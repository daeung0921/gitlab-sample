# ────────────────────────────────────────────────
# fn_mvn_build 함수
#   원격 서버(REMOTE_DEPLOY_HOST)에 SSH 접속하여 Maven 빌드 수행 후 산출물(zip) 다운로드
#
# ▶ 사용 방법:
#   script:
#     - !reference [.fn_mvn_build, script]
#     - fn_mvn_build
#
# ▶ 제어용 환경 변수 목록:
#   - REMOTE_DEPLOY_HOST   (필수) SSH 대상 서버 IP 또는 호스트명
#   - REMOTE_DEPLOY_USER   (필수) SSH 접속 계정
#   - REMOTE_DIR           (필수) 원격 빌드 작업 디렉토리 (/tmp/gitlab-build-$CI_PIPELINE_ID 등)
#   - REMOTE_DEPLOY_PORT   (선택) SSH 포트, 기본값 22
#   - REMOTE_SETTINGS      (선택) 원격 Maven settings.xml 경로
#   - MAVEN_CLI_OPTS       (선택) Maven 옵션, 기본값 "-B"
#                            예: "-B -DskipTests" 또는 "-B -Dmaven.test.skip=true"
#   - BUILD_DIR            (선택) Maven 산출물 디렉토리, 기본값 "target"
#   - ZIP_FILE             (선택) 원격 zip 파일명, 기본값 "build-artifact.zip"
#   - LOCAL_ZIP_OUT        (선택) 로컬에 다운로드할 zip 파일명
#   - CI_PROJECT_DIR       (선택) 로컬 소스 루트 (기본값 ".")
#   - SSH_PRIVATE_KEY      (필수, Runner에 따라) SSH 개인키 (before_script에서 등록)
#
# ▶ 예시 (GitLab CI):
#   variables:
#     REMOTE_DEPLOY_HOST: "13.124.131.170"
#     REMOTE_DEPLOY_USER: "gitlab-runner-user"
#     REMOTE_DIR: "/tmp/gitlab-build-${CI_PIPELINE_ID}"
#     MAVEN_CLI_OPTS: "-B -DskipTests=false"
#   script:
#     - !reference [.fn_mvn_build, script]
#     - fn_mvn_build
# ────────────────────────────────────────────────
.fn_mvn_build:
  script: |
    fn_mvn_build() {
      set -eu

      ###############################################################
      # 기본 설정
      # - 이 함수는 로컬 CI 컨테이너 내에서 실행되어 원격 서버에
      #   소스를 전송하고 SSH로 Maven 빌드를 수행한 뒤 산출물을 가져온다.
      # - rsync가 양쪽 모두 설치되어 있으면 rsync 방식,
      #   없으면 tar+ssh 스트리밍 폴백.
      ###############################################################

      # ──  환경 변수 초기화 (필요 시 CI/CD 변수로 override 가능) ─────────────────────────────────────────────
      maven_cli_opts="${MAVEN_CLI_OPTS:-"-B"}"            # mvn 옵션 (기본: batch 모드)
      build_dir="${BUILD_DIR:-"target"}"                  # 원격 빌드 결과 디렉토리 (예: target)
      zip_file="${ZIP_FILE:-"build-artifact.zip"}"        # 원격 zip 파일명
      remote_dir="${REMOTE_DIR:?REMOTE_DIR is required}"  # 원격 빌드 작업 디렉토리 (필수)
      remote_port="${REMOTE_DEPLOY_PORT:-22}"             # SSH 포트 (기본 22)
      remote_settings="${REMOTE_SETTINGS:-""}"            # Maven settings.xml 경로 (옵션)
      src_dir="${CI_PROJECT_DIR:-.}"                      # 로컬 소스 루트 경로

      # ── SSH 접속 정보 확인 ─────────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"

      # ── 내부 헬퍼 함수 ─────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq() { printf "%s" "$1" | sed "s/'/'\\\\''/g"; } # shell-safe quoting for SSH (Alpine BusyBox 호환)

      # ── 소스 동기화 (rsync 우선, 없으면 tar 스트리밍) ─────────────────────────────────────────────
      log "▶ Sync sources to remote: $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir"
      if command -v rsync >/dev/null 2>&1 && \
         ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" 'command -v rsync >/dev/null 2>&1'
      then
        RSYNC_EXCLUDES="--exclude=.git --exclude=.m2 --exclude=target --exclude=node_modules --exclude=.gradle"
        log "Using rsync for efficient incremental sync"
        rsync -az --delete \
          -e "ssh -p $remote_port" \
          --rsync-path="mkdir -p '$remote_dir' && rsync" \
          $RSYNC_EXCLUDES \
          "$src_dir/" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir/"
      else
        log "rsync not available, falling back to tar streaming"
        tar -C "$src_dir" \
            --exclude=".git" --exclude=".m2" --exclude="target" \
            --exclude="node_modules" --exclude=".gradle" \
            -czf - . \
          | ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "mkdir -p '$remote_dir' && tar -xzf - -C '$remote_dir'"
      fi

      # ── 원격 빌드 스크립트 생성 ─────────────────────────────────────────────
      remote_script=$(mktemp -t remote_build.XXXXXX)
      log "Created temporary remote build script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${BUILD_DIR:?BUILD_DIR is required}"
      : "${ZIP_FILE:?ZIP_FILE is required}"
      : "${MVN_OPTS:?MVN_OPTS is required}"

      log "Starting remote Maven build in $REMOTE_DIR"

      # 1> 작업 디렉토리 준비
      mkdir -p "$REMOTE_DIR"
      cd "$REMOTE_DIR"

      # 2> Maven 프로젝트 유효성 확인
      [ -f "pom.xml" ] || fail "pom.xml not found in $REMOTE_DIR (check source sync)"

      # 3> zip 유틸 설치 (가능한 경우만 시도)
      if ! command -v zip >/dev/null 2>&1; then
        log "zip not found, attempting install..."
        if command -v apk >/dev/null 2>&1; then sudo apk add --no-cache zip || true
        elif command -v apt-get >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y zip || true
        elif command -v dnf >/dev/null 2>&1; then sudo dnf install -y zip || true
        fi
      fi

      # 4> Maven 실행 준비
      command -v mvn >/dev/null 2>&1 || fail "Maven not installed or not in PATH"
      log "Using Maven: $(command -v mvn)"
      log "Options    : $MVN_OPTS"
      log "Remote dir : $REMOTE_DIR"

      # 5> Maven 빌드 수행
      log "▶ Running Maven build..."
      if [ -n "${SETTINGS_XML:-}" ]; then
        mvn $MVN_OPTS -s "$SETTINGS_XML" clean package
      else
        mvn $MVN_OPTS clean package
      fi

      [ -d "$BUILD_DIR" ] || fail "Build directory $BUILD_DIR not found after mvn package"
      ok "Maven build success"

      # 6> 산출물 패키징
      ARTIFACT_DIR="$REMOTE_DIR/artifacts"
      mkdir -p "$ARTIFACT_DIR"
      rm -f "$ARTIFACT_DIR/$ZIP_FILE"

      log "▶ Packaging artifacts..."
      zip -r "$ARTIFACT_DIR/$ZIP_FILE" "$BUILD_DIR" >/dev/null || true

      [ -s "$ARTIFACT_DIR/$ZIP_FILE" ] || fail "Artifact zip creation failed"
      ok "Packaged: $ARTIFACT_DIR/$ZIP_FILE"
    REMOTE_SH

      # ── 원격 빌드 실행 ─────────────────────────────────────────────
      log "▶ Executing remote build via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      #ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
      #  REMOTE_DIR="$remote_dir" \
      #  BUILD_DIR="$build_dir" \
      #  ZIP_FILE="$zip_file" \
      #  MVN_OPTS='$maven_cli_opts' \
      #  SETTINGS_XML="$remote_settings" \
      #  'sh -s' < "$remote_script"

      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$remote_dir")'" \
        "BUILD_DIR='$(shq "$build_dir")'" \
        "ZIP_FILE='$(shq "$zip_file")'" \
        "MVN_OPTS='$(shq "$maven_cli_opts")'" \
        "SETTINGS_XML='$(shq "$remote_settings")'" \
        'export REMOTE_DIR BUILD_DIR ZIP_FILE MVN_OPTS SETTINGS_XML; sh -s' \
        < "$remote_script"

      # ── 산출물 다운로드 ─────────────────────────────────────────────
      remote_zip="${remote_dir}/artifacts/${zip_file}"
      local_zip="${LOCAL_ZIP_OUT:-$zip_file}"

      log "▶ Downloading artifact: $remote_zip -> $local_zip"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_zip"

      ok "Done: artifact retrieved successfully ($local_zip)"

      # ── 임시 파일 정리 ─────────────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"

      # ── 원격 디렉토리 정리 (옵션) ─────────────────────────────────────────────
      # ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" "rm -rf '$remote_dir'" || true
    }

# ────────────────────────────────────────────────
# fn_mvn_test 함수
#   원격 서버(REMOTE_DEPLOY_HOST)에 SSH 접속하여 Maven 테스트 수행 후
#   Surefire + JaCoCo 리포트를 zip 형태로 다운로드
#
# ▶ 사용 방법:
#   script:
#     - !reference [.fn_mvn_test, script]
#     - fn_mvn_test
#
# ▶ 제어용 환경 변수 목록:
#   - REMOTE_DEPLOY_HOST   (필수) SSH 대상 서버 IP 또는 호스트명
#   - REMOTE_DEPLOY_USER   (필수) SSH 접속 계정
#   - REMOTE_DIR           (필수) 원격 작업 디렉토리 (/tmp/gitlab-test-$CI_PIPELINE_ID 등)
#   - REMOTE_DEPLOY_PORT   (선택) SSH 포트, 기본값 22
#   - REMOTE_SETTINGS      (선택) Maven settings.xml 경로
#   - MAVEN_CLI_OPTS       (선택) Maven 옵션, 기본값 "-B"
#   - REPORT_DIR           (선택) Surefire 리포트 경로, 기본값 "target/surefire-reports"
#   - JACOCO_DIR           (선택) JaCoCo 리포트 경로, 기본값 "target/site/jacoco"
#   - ZIP_FILE             (선택) zip 파일명, 기본값 "test-reports.zip"
#   - ARTIFACT_DIR         (선택) 로컬에 저장할 디렉토리, 기본값 "$CI_PROJECT_DIR/artifacts"
#   - SSH_PRIVATE_KEY      (필수, Runner에 따라) SSH 개인키 (before_script에서 등록)
#
# ▶ 예시 (GitLab CI):
#   variables:
#     REMOTE_DEPLOY_HOST: "13.124.131.170"
#     REMOTE_DEPLOY_USER: "gitlab-runner-user"
#     REMOTE_DIR: "/tmp/gitlab-test-${CI_PIPELINE_ID}"
#     MAVEN_CLI_OPTS: "-B"
#   script:
#     - !reference [.fn_mvn_test, script]
#     - fn_mvn_test
# ────────────────────────────────────────────────
.fn_mvn_test:
  script: |
    fn_mvn_test() {
      set -eu

      maven_cli_opts="${MAVEN_CLI_OPTS:-"-B"}"
      report_dir="${REPORT_DIR:-"target/surefire-reports"}"
      jacoco_dir="${JACOCO_DIR:-"target/site/jacoco"}"
      artifact_dir="${ARTIFACT_DIR:-"$CI_PROJECT_DIR/artifacts"}"
      zip_file="${ZIP_FILE:-"test-reports.zip"}"
      remote_dir="${REMOTE_DIR:?REMOTE_DIR is required}"
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      remote_settings="${REMOTE_SETTINGS:-""}"
      src_dir="${CI_PROJECT_DIR:-.}"

      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"

      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq() { printf "%s" "$1" | sed "s/'/'\\\\''/g"; } # shell-safe quoting for SSH (Alpine BusyBox 호환)

      log "▶ Syncing sources to remote: $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir"
      if command -v rsync >/dev/null 2>&1 && \
         ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" 'command -v rsync >/dev/null 2>&1'
      then
        RSYNC_EXCLUDES="--exclude=.git --exclude=.m2 --exclude=target --exclude=node_modules --exclude=.gradle"
        rsync -az --delete \
          -e "ssh -p $remote_port" \
          --rsync-path="mkdir -p '$remote_dir' && rsync" \
          $RSYNC_EXCLUDES \
          "$src_dir/" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir/"
      else
        tar -C "$src_dir" \
            --exclude=".git" --exclude=".m2" --exclude="target" \
            --exclude="node_modules" --exclude=".gradle" \
            -czf - . \
          | ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "mkdir -p '$remote_dir' && tar -xzf - -C '$remote_dir'"
      fi

      remote_script=$(mktemp -t remote_test.XXXXXX)
      log "Created temporary remote test script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${REPORT_DIR:?REPORT_DIR is required}"
      : "${JACOCO_DIR:?JACOCO_DIR is required}"
      : "${ZIP_FILE:?ZIP_FILE is required}"
      : "${MVN_OPTS:?MVN_OPTS is required}"

      mkdir -p "$REMOTE_DIR"
      cd "$REMOTE_DIR"
      [ -f "pom.xml" ] || fail "pom.xml not found"

      command -v mvn >/dev/null 2>&1 || fail "Maven not installed"
      log "Using Maven: $(command -v mvn)"
      log "Options: $MVN_OPTS"

      if [ -n "${SETTINGS_XML:-}" ]; then
        mvn $MVN_OPTS -s "$SETTINGS_XML" test
      else
        mvn $MVN_OPTS test
      fi
      ok "Maven tests completed"

      ARTIFACT_DIR="$REMOTE_DIR/artifacts"
      mkdir -p "$ARTIFACT_DIR"
      rm -f "$ARTIFACT_DIR/$ZIP_FILE"
      zip -r "$ARTIFACT_DIR/$ZIP_FILE" "$REPORT_DIR" "$JACOCO_DIR" >/dev/null 2>&1 || true
      [ -s "$ARTIFACT_DIR/$ZIP_FILE" ] || fail "Report zip creation failed"
      ok "Packaged reports: $ARTIFACT_DIR/$ZIP_FILE"
    REMOTE_SH

      log "▶ Executing remote test via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$remote_dir")'" \
        "REPORT_DIR='$(shq "$report_dir")'" \
        "JACOCO_DIR='$(shq "$jacoco_dir")'" \
        "ZIP_FILE='$(shq "$zip_file")'" \
        "MVN_OPTS='$(shq "$maven_cli_opts")'" \
        "SETTINGS_XML='$(shq "$remote_settings")'" \
        'export REMOTE_DIR REPORT_DIR JACOCO_DIR ZIP_FILE MVN_OPTS SETTINGS_XML; sh -s' \
        < "$remote_script"

      remote_zip="${remote_dir}/artifacts/${zip_file}"
      local_zip="${artifact_dir}/${zip_file}"
      mkdir -p "$artifact_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_zip"
      ok "Reports downloaded successfully: $local_zip"

      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }

# ────────────────────────────────────────────────
# fn_mvn_deploy_snapshot
#   원격 서버에서 mvn clean deploy (snapshot) 실행 후
#   배포 로그 + 산출물(WAR/JAR)을 zip으로 묶어 로컬로 다운로드
#
# ▶ 필요 변수
#   - REMOTE_DEPLOY_HOST   (필수)
#   - REMOTE_DEPLOY_USER   (필수)
#   - REMOTE_DIR           (필수) 예: /tmp/gitlab-deploy-${CI_PIPELINE_ID}
#   - SNAPSHOT_REPO_URL    (필수) 예: https://nexus.../maven-devops-snapshots/
#   - REMOTE_DEPLOY_PORT   (선택, 기본 22)
#   - MAVEN_CLI_OPTS       (선택, 기본 "-B")
#   - REMOTE_SETTINGS      (선택) 원격 settings.xml 경로
#   - CI_PROJECT_DIR       (선택, 기본 .) 로컬 소스 루트
#
# ▶ 결과물
#   - 로컬: artifacts/deploy-snapshot-artifacts.zip
# ────────────────────────────────────────────────
.fn_mvn_deploy_snapshot:
  script: |
    fn_mvn_deploy_snapshot() {
      set -eu

      # ── 환경값 초기화 ─────────────────────────────────────────────
      maven_cli_opts="${MAVEN_CLI_OPTS:-"-B"}"
      remote_dir="${REMOTE_DIR:?REMOTE_DIR is required}"
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      remote_settings="${REMOTE_SETTINGS:-""}"
      src_dir="${CI_PROJECT_DIR:-.}"
      snapshot_repo_url="${SNAPSHOT_REPO_URL:?SNAPSHOT_REPO_URL is required}"

      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"

      # ── 유틸/로깅 ─────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      # BusyBox/Alpine 호환 shell-quoting
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 1) 소스 동기화 ─────────────────────────────────────────────
      log "▶ Sync sources to remote: $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir"
      if command -v rsync >/dev/null 2>&1 && \
         ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" 'command -v rsync >/dev/null 2>&1'
      then
        RSYNC_EXCLUDES="--exclude=.git --exclude=.m2 --exclude=target --exclude=node_modules --exclude=.gradle"
        rsync -az --delete \
          -e "ssh -p $remote_port" \
          --rsync-path="mkdir -p '$remote_dir' && rsync" \
          $RSYNC_EXCLUDES \
          "$src_dir/" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_dir/"
      else
        tar -C "$src_dir" \
            --exclude=".git" --exclude=".m2" --exclude="target" \
            --exclude="node_modules" --exclude=".gradle" \
            -czf - . \
          | ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "mkdir -p '$remote_dir' && tar -xzf - -C '$remote_dir'"
      fi

      # ── 2) 원격 스크립트 생성 ─────────────────────────────────────────────
      remote_script=$(mktemp /tmp/remote_deploy.XXXXXX)
      log "Created temporary remote deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${MVN_OPTS:?MVN_OPTS is required}"
      : "${SNAPSHOT_REPO_URL:?SNAPSHOT_REPO_URL is required}"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      DEPLOY_LOG="$ARTIFACTS_DIR/deploy-snapshot.log"

      # 준비
      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"
      [ -f "pom.xml" ] || fail "pom.xml not found in $REMOTE_DIR"

      # mvn 체크
      command -v mvn >/dev/null 2>&1 || fail "Maven not installed"
      log "Using Maven: $(command -v mvn)"
      log "Options    : $MVN_OPTS"
      log "Repo URL   : $SNAPSHOT_REPO_URL"

      # 배포 실행
      log "▶ Maven Deploy Snapshot"
      if [ -n "${SETTINGS_XML:-}" ]; then
        if ! mvn $MVN_OPTS -s "$SETTINGS_XML" clean deploy \
              -DaltDeploymentRepository=nexus-snapshots::default::"$SNAPSHOT_REPO_URL" 2>&1 | tee "$DEPLOY_LOG"; then
          fail "Maven deploy failed (see $DEPLOY_LOG)"
        fi
      else
        if ! mvn $MVN_OPTS clean deploy \
              -DaltDeploymentRepository=nexus-snapshots::default::"$SNAPSHOT_REPO_URL" 2>&1 | tee "$DEPLOY_LOG"; then
          fail "Maven deploy failed (see $DEPLOY_LOG)"
        fi
      fi
      ok "Maven snapshot deploy finished"

      # 산출물 압축 (WAR/JAR + 로그)
      OUT_ZIP="$ARTIFACTS_DIR/deploy-snapshot-artifacts.zip"
      rm -f "$OUT_ZIP"
      log "▶ Archiving deployed artifacts"
      # glob이 비어도 실패하지 않도록 || true
      zip -r "$OUT_ZIP" target/*.war target/*.jar "$DEPLOY_LOG" >/dev/null 2>&1 || true

      [ -s "$OUT_ZIP" ] || fail "No deployment artifacts were archived"
      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      # ── 3) 원격 배포 실행 (환경변수 안전 전달) ─────────────────────────────────────────────
      log "▶ Executing remote deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$remote_dir")'" \
        "MVN_OPTS='$(shq "$maven_cli_opts")'" \
        "SNAPSHOT_REPO_URL='$(shq "$snapshot_repo_url")'" \
        "SETTINGS_XML='$(shq "$remote_settings")'" \
        'export REMOTE_DIR MVN_OPTS SNAPSHOT_REPO_URL SETTINGS_XML; sh -s' \
        < "$remote_script"

      # ── 4) 산출물 다운로드 ─────────────────────────────────────────────
      remote_zip="${remote_dir}/artifacts/deploy-snapshot-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      log "▶ Downloading artifact: $remote_zip -> $local_dir/"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_dir/"

      ok "Done: $local_dir/$(basename "$remote_zip")"

      # ── 5) 임시 파일 정리 ─────────────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }

# ────────────────────────────────────────────────
# fn_mvn_deploy_release
#   Git 태그(COMMIT_TAG)로 버전 설정 후,
#   원격에서 Maven Release 배포 → zip 산출물 scp 회수
#
# ▶ 필수 변수
#   - COMMIT_TAG            : 예) v1.2.3  (v 접두어 자동 제거)
#   - RELEASE_REPO_URL      : 예) https://nexus.../repository/maven-devops-releases/
#   - REMOTE_DEPLOY_HOST    : 원격 호스트
#   - REMOTE_DEPLOY_USER    : 원격 계정
#   - REMOTE_DIR            : 원격 작업 디렉토리
#
# ▶ 선택 변수
#   - MAVEN_CLI_OPTS        : 기본 "-B"
#   - REMOTE_DEPLOY_PORT    : 기본 22
#   - REMOTE_SETTINGS       : 원격 settings.xml 경로(인증/미러 등)
#   - CI_PROJECT_DIR        : 로컬 소스 루트(기본 .)
# ────────────────────────────────────────────────
.fn_mvn_deploy_release:
  script: |
    fn_mvn_deploy_release() {
      set -eu

      # ── 필수값 강제 ─────────────────────────────────────────────
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"

      # ── 기본값 ────────────────────────────────────────────────
      maven_cli_opts="${MAVEN_CLI_OPTS:-"-B"}"
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      remote_settings="${REMOTE_SETTINGS:-""}"
      src_dir="${CI_PROJECT_DIR:-.}"

      # ── 유틸 ─────────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      # Alpine BusyBox 호환, 작은따옴표 안전 이스케이프
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 1) 소스 동기화 (rsync → tar 폴백) ─────────────────────
      log "▶ Sync sources to remote: $REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$REMOTE_DIR"
      if command -v rsync >/dev/null 2>&1 && \
         ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" 'command -v rsync >/dev/null 2>&1'
      then
        rsync -az --delete \
          -e "ssh -p $remote_port" \
          --rsync-path="mkdir -p '$REMOTE_DIR' && rsync" \
          --exclude=.git --exclude=.m2 --exclude=target --exclude=node_modules --exclude=.gradle \
          "$src_dir/" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$REMOTE_DIR/"
      else
        tar -C "$src_dir" \
            --exclude=".git" --exclude=".m2" --exclude="target" \
            --exclude="node_modules" --exclude=".gradle" \
            -czf - . \
          | ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
              "mkdir -p '$REMOTE_DIR' && tar -xzf - -C '$REMOTE_DIR'"
      fi

      # ── 2) 원격 실행 스크립트 생성 ────────────────────────────
      remote_script=$(mktemp /tmp/remote_release.XXXXXX)
      log "Created temporary remote release script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${MVN_OPTS:?MVN_OPTS is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      DEPLOY_LOG="$ARTIFACTS_DIR/deploy-release.log"

      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"
      [ -f "pom.xml" ] || fail "pom.xml not found in $REMOTE_DIR"

      command -v mvn >/dev/null 2>&1 || fail "Maven not installed"
      log "Using Maven : $(command -v mvn)"
      log "MVN_OPTS   : $MVN_OPTS"
      log "Release URL: $RELEASE_REPO_URL"
      log "COMMIT_TAG : $COMMIT_TAG"

      # 2-1) 태그 → 버전 (v 접두어 제거)
      NEW_VERSION="${COMMIT_TAG#v}"
      [ -n "$NEW_VERSION" ] || fail "Resolved NEW_VERSION is empty"

      log "▶ Setting version to $NEW_VERSION"
      if [ -n "${SETTINGS_XML:-}" ]; then
        mvn $MVN_OPTS -s "$SETTINGS_XML" versions:set -DnewVersion="$NEW_VERSION" -DgenerateBackupPoms=false 2>&1 | tee -a "$DEPLOY_LOG"
      else
        mvn $MVN_OPTS versions:set -DnewVersion="$NEW_VERSION" -DgenerateBackupPoms=false 2>&1 | tee -a "$DEPLOY_LOG"
      fi

      # 2-2) Release Deploy (신문법: id::url)
      log "▶ Maven Deploy Release"
      if [ -n "${SETTINGS_XML:-}" ]; then
        mvn $MVN_OPTS -s "$SETTINGS_XML" clean deploy \
          -DaltDeploymentRepository="nexus-releases::${RELEASE_REPO_URL}" 2>&1 | tee -a "$DEPLOY_LOG"
      else
        mvn $MVN_OPTS clean deploy \
          -DaltDeploymentRepository="nexus-releases::${RELEASE_REPO_URL}" 2>&1 | tee -a "$DEPLOY_LOG"
      fi
      ok "Maven release deploy finished"

      # 2-3) 산출물 압축 (WAR/JAR + 로그)
      OUT_ZIP="$ARTIFACTS_DIR/deploy-release-artifacts.zip"
      rm -f "$OUT_ZIP"
      zip -r "$OUT_ZIP" target/*.war target/*.jar "$DEPLOY_LOG" >/dev/null 2>&1 || true
      [ -s "$OUT_ZIP" ] || fail "No deployment artifacts were archived"
      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      # ── 3) 원격 실행 (환경 안전 전달) ─────────────────────────
      log "▶ Executing remote release via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "MVN_OPTS='$(shq "$maven_cli_opts")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "SETTINGS_XML='$(shq "$remote_settings")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        'export REMOTE_DIR MVN_OPTS RELEASE_REPO_URL SETTINGS_XML COMMIT_TAG; sh -s' \
        < "$remote_script"

      # ── 4) 산출물 다운로드 (파일 경로 명시) ────────────────────
      remote_zip="${REMOTE_DIR}/artifacts/deploy-release-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      local_file="$local_dir/$(basename "$remote_zip")"

      log "▶ Downloading artifact: $remote_zip -> $local_file"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_file"
      ok "Done: $local_file"

      # ── 5) 임시 파일 정리 ──────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }

# ────────────────────────────────────────────────
# fn_tomcat_deploy_war
#   Nexus Releases에서 WAR 다운로드 → Tomcat Manager로 배포를
#   "원격 서버(SSH)"에서 수행하고, 로그 zip을 Runner로 회수
#
# ▶ 필수 변수
#   - REMOTE_DEPLOY_HOST      : SSH 대상 (배포 실행 호스트)  ex) 13.124.131.170
#   - REMOTE_DEPLOY_USER      : SSH 계정                     ex) gitlab-runner-user
#   - REMOTE_DIR              : 원격 작업 디렉토리           ex) /tmp/gitlab-prod-${CI_PIPELINE_ID}
#   - RELEASE_REPO_URL        : Nexus Release repo base URL  ex) https://nexus.../repository/maven-devops-releases
#   - GROUP_ID                : GAV groupId                  ex) com.example
#   - ARTIFACT_ID             : GAV artifactId               ex) devops
#   - COMMIT_TAG              : 태그(필수, v1.2.3 형식 가능)
#   - WAS_URL                 : Tomcat Manager가 떠있는 호스트/IP (HTTP 베이스)
#   - NEXUS_USER / NEXUS_PASS : Nexus 다운로드 계정
#   - DEPLOY_USER/DEPLOY_PASS : Tomcat Manager 계정(배포 권한)
#
# ▶ 선택 변수
#   - MAVEN_CLI_OPTS          : 미사용(참고용), 통일성 위해 남김
#   - REMOTE_DEPLOY_PORT      : SSH 포트 (기본 22)
#   - CONTEXT_PATH            : Tomcat context path (기본 /devops)
# ────────────────────────────────────────────────
.fn_tomcat_deploy_war:
  script: |
    fn_tomcat_deploy_war() {
      set -eu

      # ── 필수값 강제 ─────────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"

      # ── 기본값 ────────────────────────────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      context_path="${CONTEXT_PATH:-/devops}"

      # ── 유틸 ─────────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      # Alpine BusyBox 호환, 작은따옴표 안전 이스케이프
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 1) 원격 스크립트 생성 ─────────────────────────────────
      remote_script=$(mktemp /tmp/remote_deploy_prod.XXXXXX)
      log "Created temporary remote prod deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      DEPLOY_LOG="$ARTIFACTS_DIR/deploy-prod.log"

      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"

      # v 접두어 제거한 버전
      VERSION="${COMMIT_TAG#v}"
      [ -n "$VERSION" ] || fail "Resolved VERSION is empty"

      WAR_FILE="${ARTIFACT_ID}-${VERSION}.war"
      # groupId 의 점(.)을 / 로 치환
      WAR_PATH="${GROUP_ID//.//}/${ARTIFACT_ID}/${VERSION}/${WAR_FILE}"

      # RELEASE_REPO_URL 끝 슬래시 제거 후 구성
      BASE="${RELEASE_REPO_URL%/}"
      URL="${BASE}/${WAR_PATH}"

      log "▶ Downloading WAR (artifact): ${ARTIFACT_ID}:${VERSION}"
      # 민감정보는 로그에 직접 출력하지 않음
      if ! curl -fsS --retry 3 -u "$NEXUS_USER:$NEXUS_PASS" -o "$WAR_FILE" "$URL" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Failed to download WAR from $URL"
      fi
      [ -s "$WAR_FILE" ] || fail "Downloaded WAR is empty: $WAR_FILE"

      log "▶ Deploying WAR to Tomcat PROD: http://$WAS_URL (context=$CONTEXT_PATH)"
      # Tomcat Manager text API 사용, update=true
      # ※ 로그에 자격증명 노출되지 않도록 주의 (curl 내부에서만 사용)
      if ! curl -fsS --retry 3 -u "$DEPLOY_USER:$DEPLOY_PASS" \
          -T "$WAR_FILE" \
          "http://$WAS_URL/manager/text/deploy?path=$CONTEXT_PATH&update=true" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Failed to deploy WAR to Tomcat Manager"
      fi

      ok "Tomcat deploy success"

      # 로그만 압축(대형 WAR 회수는 불필요/비효율)
      OUT_ZIP="$ARTIFACTS_DIR/deploy-war-artifacts.zip"
      rm -f "$OUT_ZIP"
      zip -r "$OUT_ZIP" "$DEPLOY_LOG" >/dev/null 2>&1 || true
      [ -s "$OUT_ZIP" ] || fail "No deployment logs were archived"
      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      # ── 2) 원격 실행 (환경 안전 전달) ─────────────────────────
      log "▶ Executing prod deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "DEPLOY_USER='$(shq "$DEPLOY_USER")'" \
        "DEPLOY_PASS='$(shq "$DEPLOY_PASS")'" \
        "CONTEXT_PATH='$(shq "$context_path")'" \
        'export REMOTE_DIR RELEASE_REPO_URL GROUP_ID ARTIFACT_ID COMMIT_TAG WAS_URL NEXUS_USER NEXUS_PASS DEPLOY_USER DEPLOY_PASS CONTEXT_PATH; sh -s' \
        < "$remote_script"

      # ── 3) 산출물 다운로드 (파일 경로 명시) ────────────────────
      remote_zip="${REMOTE_DIR}/artifacts/deploy-war-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      local_file="$local_dir/$(basename "$remote_zip")"

      log "▶ Downloading artifact: $remote_zip -> $local_file"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_file"
      ok "Done: $local_file"

      # ── 4) 임시 파일 정리 ──────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }

# ────────────────────────────────────────────────
# 함수: fn_tomcat_deploy_snapshot_war
#
# 목적:
#   - Nexus Snapshot 리포지토리에서 최신 SNAPSHOT WAR를 찾아
#     Tomcat Manager API(update=true)로 스테이징/개발 서버에 “통배포”한다.
#
# 동작 개요:
#   1) maven-metadata.xml(artifact 루트)에서 가장 최신 SNAPSHOT base 버전 선택 (예: 1.2.4-SNAPSHOT)
#   2) 해당 버전 디렉토리의 maven-metadata.xml에서 snapshotVersions 중 확장자가 war인 최신 항목 선택
#      - timestamped 네이밍(artifactId-1.2.4-20251016.090501-3.war) 지원
#      - 없으면 non-unique 스냅샷(artifactId-1.2.4-SNAPSHOT.war)로 폴백
#   3) WAR 다운로드 후 Tomcat Manager에 update=true로 배포
#   4) 배포 로그를 zip으로 패키징하여 Runner로 회수
#
# 특징:
#   - COMMIT_TAG 불필요 → 브랜치/MR 파이프라인에서 사용 용이
#   - SNAPSHOT_VERSION 변수를 주면 해당 SNAPSHOT(base) 버전 강제 사용 가능 (예: 1.2.4-SNAPSHOT)
#   - timestamped/ non-unique 모두 대응
#
# 필수 변수:
#   REMOTE_DEPLOY_HOST, REMOTE_DEPLOY_USER, REMOTE_DIR,
#   SNAPSHOT_REPO_URL, GROUP_ID, ARTIFACT_ID,
#   WAS_URL, NEXUS_USER, NEXUS_PASS, DEPLOY_USER, DEPLOY_PASS
#
# 선택 변수:
#   REMOTE_DEPLOY_PORT(기본 22), CONTEXT_PATH(기본 /devops),
#   SNAPSHOT_VERSION(강제 base SNAPSHOT, 예: 1.2.4-SNAPSHOT)
#
# 아티팩트:
#   artifacts/deploy-snapshot-war-artifacts.zip
#     └─ deploy-snapshot.log
# ────────────────────────────────────────────────
.fn_tomcat_deploy_snapshot_war:
  script: |
    fn_tomcat_deploy_snapshot_war() {
      set -eu

      # ── 필수값 ───────────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${SNAPSHOT_REPO_URL:?SNAPSHOT_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"

      # ── 기본값 ───────────────────────────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      context_path="${CONTEXT_PATH:-/devops}"

      # ── 유틸 ────────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 원격 실행 스크립트 생성 ─────────────────────────────
      remote_script=$(mktemp /tmp/remote_deploy_snapshot.XXXXXX)
      log "Created temporary snapshot deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${SNAPSHOT_REPO_URL:?SNAPSHOT_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

      # 도구 준비
      for t in curl xmllint zip; do
        if ! need "$t"; then
          if   need apk; then sudo apk add --no-cache $t libxml2-utils || true
          elif need apt-get; then sudo apt-get update -y && sudo apt-get install -y $t || true
          elif need dnf; then sudo dnf install -y $t libxml2 || true
          fi
        fi
      done
      need curl || fail "curl not available"
      need zip  || fail "zip not available"
      need xmllint || fail "xmllint not available"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      DEPLOY_LOG="$ARTIFACTS_DIR/deploy-snapshot.log"
      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"

      BASE="${SNAPSHOT_REPO_URL%/}/${GROUP_ID//.//}/${ARTIFACT_ID}"

      # 1) base SNAPSHOT 버전 결정 (우선순위: SNAPSHOT_VERSION 변수 → metadata 최신)
      BASE_SNAP="${SNAPSHOT_VERSION:-}"
      if [ -z "$BASE_SNAP" ]; then
        log "Resolve latest SNAPSHOT base version from artifact metadata"
        tmp_meta="$(mktemp)"
        if ! curl -fsS --insecure -u "$NEXUS_USER:$NEXUS_PASS" -o "$tmp_meta" "$BASE/maven-metadata.xml" 2>&1 | tee -a "$DEPLOY_LOG"; then
          fail "Failed to fetch artifact metadata"
        fi
        # versions 목록 중 -SNAPSHOT 로 끝나는 것 중 최댓값 선택
        BASE_SNAP="$(xmllint --xpath "string(//versioning/versions/version[contains(., '-SNAPSHOT')][last()])" "$tmp_meta" 2>>"$DEPLOY_LOG" || true)"
        rm -f "$tmp_meta"
        [ -n "$BASE_SNAP" ] || fail "No SNAPSHOT versions found in metadata"
      fi
      log "BASE_SNAPSHOT=$BASE_SNAP" | tee -a "$DEPLOY_LOG"

      # 2) version 디렉토리 메타에서 timestamped snapshot WAR 탐색
      ver_meta="$(mktemp)"
      if ! curl -fsS --insecure -u "$NEXUS_USER:$NEXUS_PASS" -o "$ver_meta" "$BASE/$BASE_SNAP/maven-metadata.xml" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Failed to fetch version metadata for $BASE_SNAP"
      fi

      # snapshotVersions 섹션에서 extension='war'인 최신 값을 찾는다
      SNAP_NAME="$(xmllint --xpath "string(//snapshotVersions/snapshotVersion[extension='war']/value[last()])" "$ver_meta" 2>>"$DEPLOY_LOG" || true)"
      rm -f "$ver_meta"

      WAR_URL=""
      WAR_FILE=""

      if [ -n "$SNAP_NAME" ]; then
        # timestamped 네이밍 (ex: devops-1.2.4-20251016.090501-3.war)
        WAR_FILE="${ARTIFACT_ID}-${SNAP_NAME}.war"
        WAR_URL="${BASE}/${BASE_SNAP}/${WAR_FILE}"
        log "Resolved timestamped snapshot: $WAR_FILE" | tee -a "$DEPLOY_LOG"
      else
        # non-unique 스냅샷으로 폴백 (ex: devops-1.2.4-SNAPSHOT.war)
        WAR_FILE="${ARTIFACT_ID}-${BASE_SNAP}.war"
        WAR_URL="${BASE}/${BASE_SNAP}/${WAR_FILE}"
        log "No snapshotVersions entry; fallback to non-unique: $WAR_FILE" | tee -a "$DEPLOY_LOG"
      fi

      log "▶ Downloading SNAPSHOT WAR: $WAR_URL"
      if ! curl -fsS --insecure --retry 3 -u "$NEXUS_USER:$NEXUS_PASS" -o "$WAR_FILE" "$WAR_URL" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Failed to download WAR"
      fi
      [ -s "$WAR_FILE" ] || fail "Downloaded WAR is empty"

      log "▶ Deploying to Tomcat: http://$WAS_URL (context=$CONTEXT_PATH)"
      if ! curl -fsS --insecure --retry 3 -u "$DEPLOY_USER:$DEPLOY_PASS" \
            -T "$WAR_FILE" \
            "http://$WAS_URL/manager/text/deploy?path=$CONTEXT_PATH&update=true" 2>&1 | tee -a "$DEPLOY_LOG"; then
        fail "Tomcat deploy failed"
      fi
      ok "Tomcat snapshot deploy success"

      # 로그 압축
      OUT_ZIP="$ARTIFACTS_DIR/deploy-snapshot-war-artifacts.zip"
      rm -f "$OUT_ZIP"
      zip -r "$OUT_ZIP" "$DEPLOY_LOG" >/dev/null 2>&1 || true
      [ -s "$OUT_ZIP" ] || fail "No deployment logs were archived"
      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      # ── 원격 실행 ────────────────────────────────────────────
      log "▶ Executing snapshot deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "SNAPSHOT_REPO_URL='$(shq "$SNAPSHOT_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "DEPLOY_USER='$(shq "$DEPLOY_USER")'" \
        "DEPLOY_PASS='$(shq "$DEPLOY_PASS")'" \
        "CONTEXT_PATH='$(shq "$context_path")'" \
        "SNAPSHOT_VERSION='$(shq "${SNAPSHOT_VERSION:-}")'" \
        'export REMOTE_DIR SNAPSHOT_REPO_URL GROUP_ID ARTIFACT_ID WAS_URL NEXUS_USER NEXUS_PASS DEPLOY_USER DEPLOY_PASS CONTEXT_PATH SNAPSHOT_VERSION; sh -s' \
        < "$remote_script"

      # ── 산출물 다운로드 ──────────────────────────────────────
      remote_zip="${REMOTE_DIR}/artifacts/deploy-snapshot-war-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_dir/"
      ok "Done: $local_dir/$(basename "$remote_zip")"

      # ── 정리 ─────────────────────────────────────────────────
      rm -f "$remote_script" || true
      log "Temporary script cleaned up: $remote_script"
    }
 
# ────────────────────────────────────────────────
# fn_tomcat_rollback_war
#   현재 태그(CI_COMMIT_TAG 또는 COMMIT_TAG)의 "직전 릴리즈 버전"을
#   Nexus metadata로 조회 → 원격에서 WAR 다운로드 → Tomcat War 롤백 배포
#
# ▶ 필수 변수
#   - REMOTE_DEPLOY_HOST   : SSH 대상 원격 호스트
#   - REMOTE_DEPLOY_USER   : SSH 계정
#   - REMOTE_DIR           : 원격 작업 디렉토리 (/tmp/gitlab-rollback-${CI_PIPELINE_ID} 등)
#   - RELEASE_REPO_URL     : Nexus Releases base URL (예: https://nexus.../repository/maven-devops-releases)
#   - GROUP_ID             : 예) com.example
#   - ARTIFACT_ID          : 예) devops
#   - COMMIT_TAG           : 현재 배포 태그 (예: v1.2.3)  ※ v 접두어는 원격에서 제거
#   - WAS_URL            : Tomcat Manager 호스트:포트  (예: prod.example.com:8080)
#   - NEXUS_USER / NEXUS_PASS : Nexus 접근 계정
#   - DEPLOY_USER / DEPLOY_PASS : Tomcat Manager 배포 계정
#
# ▶ 선택 변수
#   - REMOTE_DEPLOY_PORT   : 기본 22
#   - CONTEXT_PATH         : 기본 "/devops"
# ────────────────────────────────────────────────
.fn_tomcat_rollback_war:
  script: |
    fn_tomcat_rollback_war() {
      set -eu

      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"

      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      context_path="${CONTEXT_PATH:-/devops}"

      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      remote_script=$(mktemp /tmp/remote_rollback_prod.XXXXXX)
      log "Created temporary remote rollback script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      set -eu
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }

      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${DEPLOY_USER:?DEPLOY_USER is required}"
      : "${DEPLOY_PASS:?DEPLOY_PASS is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

      ARTIFACTS_DIR="$REMOTE_DIR/artifacts"
      ROLLBACK_LOG="$ARTIFACTS_DIR/rollback-prod.log"

      mkdir -p "$REMOTE_DIR" "$ARTIFACTS_DIR"
      cd "$REMOTE_DIR"

      # ── 도구 준비 ─────────────────────────────────────────────────
      need() { command -v "$1" >/dev/null 2>&1; }
      if ! need curl; then
        if   need apk;      then sudo apk add --no-cache curl || true
        elif need apt-get;  then sudo apt-get update -y && sudo apt-get install -y curl || true
        elif need dnf;      then sudo dnf install -y curl || true
        fi
      fi
      if ! need xmllint; then
        if   need apk;      then sudo apk add --no-cache libxml2-utils || true
        elif need apt-get;  then sudo apt-get update -y && sudo apt-get install -y libxml2-utils || true
        elif need dnf;      then sudo dnf install -y libxml2 || true
        fi
      fi
      if ! need zip; then
        if   need apk;      then sudo apk add --no-cache zip || true
        elif need apt-get;  then sudo apt-get update -y && sudo apt-get install -y zip || true
        elif need dnf;      then sudo dnf install -y zip || true
        fi
      fi
      command -v curl >/dev/null 2>&1    || fail "curl not available"
      command -v xmllint >/dev/null 2>&1 || fail "xmllint not available"
      command -v zip >/dev/null 2>&1     || fail "zip not available"

      CUR_VERSION="${COMMIT_TAG#v}"
      [ -n "$CUR_VERSION" ] || fail "Resolved version from COMMIT_TAG is empty"

      META_URL="${RELEASE_REPO_URL%/}/${GROUP_ID//.//}/${ARTIFACT_ID}/maven-metadata.xml"

      # 숫자 비교 (a<b:-1, a==b:0, a>b:1)
      ver_cmp() {
        awk -v A="$1" -v B="$2" '
        function splitv(s, arr,   n,i) {
          n=split(s, arr, ".")
          for(i=1;i<=n;i++) if (arr[i] ~ /^[0-9]+$/) arr[i]+=0; else arr[i]=0
          return n
        }
        BEGIN{
          na=splitv(A, a); nb=splitv(B, b);
          n = (na>nb?na:nb)
          for(i=1;i<=n;i++){
            va = (i<=na)?a[i]:0
            vb = (i<=nb)?b[i]:0
            if (va<vb){print -1; exit}
            if (va>vb){print 1;  exit}
          }
          print 0
        }'
      }

      # prev 버전 해석 함수 (stdout에는 버전 1줄만)
      resolve_prev_version() {
        tmpfile="$(mktemp)"
        versions_tmp="$(mktemp)"
        trap 'rm -f "$tmpfile" "$versions_tmp"' RETURN

        # 로그는 stderr와 파일로만 남김
        log "▶ Fetching metadata: $META_URL" >&2
        if ! curl -fsS -u "$NEXUS_USER:$NEXUS_PASS" "$META_URL" -o "$tmpfile" >>"$ROLLBACK_LOG" 2>&1; then
          return 1
        fi

        if ! xmllint --xpath "//versioning/versions/version" "$tmpfile" 2>>"$ROLLBACK_LOG" \
          | sed -E 's#<version>#\n#g; s#</version>##g' \
          | sed '/^\s*$/d' \
          | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' > "$versions_tmp"; then
          return 1
        fi

        log "Available versions (as-is order):" >&2
        sed 's/^/  - /' "$versions_tmp" >&2

        # 1) 정확 일치 시 직전 항목 선택
        prev=""
        last=""
        found=0
        while IFS= read -r v; do
          [ -n "$v" ] || continue
          if [ "$v" = "$CUR_VERSION" ]; then
            found=1
            [ -n "$last" ] && prev="$last"
            break
          fi
          last="$v"
        done < "$versions_tmp"

        # 2) 매칭 실패 시, CUR_VERSION 보다 작은 값 중 최댓값 선택
        if [ "$found" -ne 1 ] || [ -z "$prev" ]; then
          prev=""
          while IFS= read -r v; do
            [ -n "$v" ] || continue
            cmp_cur="$(ver_cmp "$v" "$CUR_VERSION")"   # v ? cur
            if [ "$cmp_cur" -lt 0 ]; then              # v < cur
              if [ -z "$prev" ]; then
                prev="$v"
              else
                cmp_prev="$(ver_cmp "$v" "$prev")"
                [ "$cmp_prev" -gt 0 ] && prev="$v"     # v > prev
              fi
            fi
          done < "$versions_tmp"
        fi

        [ -n "$prev" ] || return 1
        printf '%s\n' "$prev"   # stdout에는 버전만 1줄
      }

      # ── 재시도 루프: 30초 간격, 최대 5회 ───────────────────────────
      attempt=1
      max_attempts=5
      sleep_secs=30
      RESOLVED_PREV=""

      while [ $attempt -le $max_attempts ]; do
        log "▶ Resolve previous version (attempt $attempt/$max_attempts)"
        RESOLVED_PREV="$(resolve_prev_version 2>>"$ROLLBACK_LOG" | head -n1 | tr -d ' \t\r')"
        if [ -n "$RESOLVED_PREV" ]; then
          # 숫자.점 이외 문자가 섞였는지 방어
          case "$RESOLVED_PREV" in
            ''|*[!0-9.]*)
              log "Resolved previous version looks invalid: '$RESOLVED_PREV'" >&2
              RESOLVED_PREV=""
              ;;
          esac
        fi
        if [ -n "$RESOLVED_PREV" ]; then
          log "▶ Previous version resolved: $RESOLVED_PREV"
          break
        fi
        if [ $attempt -lt $max_attempts ]; then
          log "Previous version not found yet. Retry in ${sleep_secs}s..."
          sleep $sleep_secs
        fi
        attempt=$((attempt+1))
      done

      [ -n "$RESOLVED_PREV" ] || fail "No previous version could be resolved after $max_attempts attempts"

      # ── WAR 다운로드 및 배포 ───────────────────────────────────────
      WAR_FILE="${ARTIFACT_ID}-${RESOLVED_PREV}.war"
      WAR_PATH="${GROUP_ID//.//}/${ARTIFACT_ID}/${RESOLVED_PREV}/${WAR_FILE}"
      BASE="${RELEASE_REPO_URL%/}"
      WAR_URL="${BASE}/${WAR_PATH}"

      log "▶ Downloading WAR: ${ARTIFACT_ID}:${RESOLVED_PREV}"
      if ! curl -fsS --retry 3 -u "$NEXUS_USER:$NEXUS_PASS" -o "$WAR_FILE" "$WAR_URL" >>"$ROLLBACK_LOG" 2>&1; then
        fail "Failed to download WAR from $WAR_URL"
      fi
      [ -s "$WAR_FILE" ] || fail "Downloaded WAR is empty: $WAR_FILE"

      log "▶ Deploying WAR to Tomcat PROD: http://$WAS_URL (context=$CONTEXT_PATH)"
      if ! curl -fsS --retry 3 -u "$DEPLOY_USER:$DEPLOY_PASS" \
          -T "$WAR_FILE" \
          "http://$WAS_URL/manager/text/deploy?path=$CONTEXT_PATH&update=true" >>"$ROLLBACK_LOG" 2>&1; then
        fail "Failed to deploy WAR to Tomcat Manager"
      fi

      ok "Rollback deploy success"

      OUT_ZIP="$ARTIFACTS_DIR/rollback-prod-artifacts.zip"
      rm -f "$OUT_ZIP"
      zip -r "$OUT_ZIP" "$ROLLBACK_LOG" >/dev/null 2>&1 || true
      [ -s "$OUT_ZIP" ] || fail "No rollback logs were archived"
      ok "Packaged: $OUT_ZIP"
    REMOTE_SH

      log "▶ Executing rollback via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "DEPLOY_USER='$(shq "$DEPLOY_USER")'" \
        "DEPLOY_PASS='$(shq "$DEPLOY_PASS")'" \
        "CONTEXT_PATH='$(shq "$context_path")'" \
        'export REMOTE_DIR RELEASE_REPO_URL GROUP_ID ARTIFACT_ID COMMIT_TAG WAS_URL NEXUS_USER NEXUS_PASS DEPLOY_USER DEPLOY_PASS CONTEXT_PATH; sh -s' \
        < "$remote_script"

      remote_zip="${REMOTE_DIR}/artifacts/rollback-prod-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip" "$local_dir/"

      rm -f "$remote_script" || true
      ok "Rollback finished"
    }


# ───────────────────────────────────────────────────────────────────────────────
# 함수: fn_tomcat_diff_deploy
#
# 목적:
#   - 기존 LIVE 심볼릭 링크를 기준으로 이전 버전 디렉터리를 식별하고,
#     새 버전(WAR 기반)을 비교(diff)하여 변경/삭제된 파일만 증분 반영.
#   - Tomcat 서비스의 무중단(or 최소중단) 배포를 수행.
#   - 배포 후 헬스체크(healthcheck) 및 이전 릴리스 보존 정책 적용.
#
# 사용 시나리오:
#   GitLab CI/CD 파이프라인에서, release/deploy 단계에서 호출.
#   신규 WAR 업로드 시, 전체 배포 대신 차분만 적용.
#
# 디렉터리 구조 예시 (/opt/tomcat 기준)
# ├── webapps/
# │   ├── devops -> ../releases/devops/diff-devops-22.3.1-20251021183055   ← LIVE 심볼릭 링크
# │   ├── ROOT/
# │   └── ...
# ├── releases/
# │   └── devops/
# │       ├── diff-devops-22.3.0-20251020175644/
# │       │   ├── WEB-INF/
# │       │   ├── static/
# │       │   └── _logs/
# │       │       ├── changed-files.txt
# │       │       ├── deleted-files.txt
# │       │       ├── diff-base.env
# │       │       └── live-pointer.env       ← CURRENT, PREV 기록
# │       └── diff-devops-22.3.1-20251021183055/    ← 신규 대상
# ├── artifacts/
# │   └── devops/
# │       └── devops-22.3.1/
# │           ├── WEB-INF/
# │           └── static/
# └── logs/
#
# 주요 경로(코드 기본값):
#   WEBAPPS_ROOT   : /opt/tomcat/webapps
#   RELEASES_BASE  : /opt/tomcat/releases
#   ARTIFACTS_BASE : /opt/tomcat/artifacts
#   LIVE_LINK      : <WEBAPPS_ROOT>/<app>
#   TARGET/_logs   : 스냅샷별 로그/메타 저장 위치(배포/복구 시 rsync 제외)
#
# 산출물(원격에 생성):
#   $REMOTE_DIR/artifacts/
#     ├── diff-deploy-artifacts.zip
#     ├── changed-files.txt
#     ├── deleted-files.txt
#     ├── diff-base.env             (BASE_DIR=<직전 운영 스냅샷>)
#     └── live-pointer.env          (CURRENT=<이번 운영>, PREV=<직전 운영>)
#
# 필수 환경변수(외부 래퍼/CI에서 주입):
#   REMOTE_DEPLOY_HOST, REMOTE_DEPLOY_USER, REMOTE_DIR,
#   COMMIT_TAG, CONTEXT_PATH,
#   NEXUS_USER, NEXUS_PASS, RELEASE_REPO_URL, GROUP_ID, ARTIFACT_ID
#
# 내부 스크립트가 요구하는 추가 변수(함수에서 기본값 제공/전달):
#   WEBAPPS_ROOT=/opt/tomcat/webapps
#   RELEASES_BASE=/opt/tomcat/releases
#   ARTIFACTS_BASE=/opt/tomcat/artifacts
#   TOMCAT_SERVICE=tomcat
#   KEEP_RELEASES=15
#   HEALTH_MODE=page | actuator | none
#   HEALTH_URL_OVERRIDE=""
#   HEALTHCHECK_TIMEOUT=60
#   HEALTHCHECK_INTERVAL=2
#   HOT_RELOAD=false
#   DEPLOY_USER=""
#   DEPLOY_PASS=""
#   WAS_URL=127.0.0.1:8080
#
# SSH 접속후 실행되는 REMOTE_SH 의 주요 디렉토리 정리 
#   LIVE_LINK : /opt/tomcat/webapps/<context>
#    - Tomcat이 실제 서비스로 사용하는 경로 (항상 이 링크를 바라봄)
#    - diff 배포 후 여기의 심링크가 TARGET 으로 교체됨
#
#   BASE_DIR : LIVE_LINK 이 가리키는 실제 디렉터리 경로
#    - diff 비교의 기준(old)으로 사용됨
#    - 이전 버전의 배포본
#
#   TARGET : /opt/tomcat/releases/<app>/diff-<app>-<ver>-<ts>
#    - 새로 배포될 버전 (NEW 기준으로 변경/삭제 반영 후 LIVE 로 전환)
#    - 배포 완료 후 LIVE_LINK → TARGET 으로 심링크 변경
#
#   NEW_DIR : /opt/tomcat/artifacts/<app>/<app>-<ver>
#    - Nexus에서 WAR를 받아 unzip한 결과물
#    - diff 비교의 기준(new)으로 사용
#
#   APP_RELEASES_DIR: /opt/tomcat/releases/<app>
#    - 모든 diff-* 스냅샷(TARGET/BASE) 저장소
#    - prune_releases()가 KEEP_RELEASES 기준으로 오래된 버전 정리
#
#   ARTIFACTS_BASE : /opt/tomcat/artifacts
#    - NEW_DIR들이 모여있는 워크 디렉터리
#    - 용량 관리 필요(장기 보존 불필요)
#
#   REMOTE_DIR : /tmp/gitlab-build-$CI_PIPELINE_ID
#    - 원격 임시 작업 디렉터리 (SSH 배포 시 임시 ZIP·로그 보관)
#    - Runner 수집 후 삭제 가능
#
#   _logs (LOG_DIR) : <TARGET>/_logs
#    - diff 결과 및 메타데이터 기록
#     · diff-base.env         : BASE_DIR 정보
#     · changed-files.txt     : 변경 목록
#     · deleted-files.txt     : 삭제 목록
#     · live-pointer.env      : CURRENT / PREV 릴리스 포인터
#    - 첫 배포(비교 대상 없음) 시 생성 생략 가능
#
# 주의사항(코드 반영됨):
#   - 모든 파일 생성/이동/삭제/링크는 sudo 사용.
#   - rsync 비교·복사 시 _logs/** 및 잡파일을 제외하여 노이즈/재배포를 방지.
#   - ln -sT + mv -Tf 조합으로 원자적 전환, 실패 시 rm → mv 폴백 처리.
#   - NEW_DIR 자동 생성 실패 시(다운로드/무결성 에러/디스크 부족) 즉시 실패(fail-fast).
# ───────────────────────────────────────────────────────────────────────────────
.fn_tomcat_diff_deploy:
  script: |
    fn_tomcat_diff_deploy() {
      set -eu

      # ── 필수 입력 ─────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"

      # ── 선택 입력(기본값) ───────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      artifacts_base="${TOMCAT_ARTIFACTS_DIR:-/opt/tomcat/artifacts}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"
      keep_releases="${KEEP_RELEASES:-15}"

      # 헬스체크
      health_mode="${HEALTH_MODE:-page}"           # actuator|page|none
      health_url_override="${HEALTH_URL_OVERRIDE:-}"
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      # Tomcat manager(핫리로드)
      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"
      was_url="${WAS_URL:-127.0.0.1:8080}"

      auto_fetch_on_missing="true"                 # NEW_DIR 없으면 Nexus에서 내려받아 생성

      # GitLab 산출물 파일명(로컬 Runner 수집용)
      deploy_log_name="deploy.log"                 # 산출물로 복사되는 이름

      # ── 유틸 ─────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      remote_script=$(mktemp /tmp/remote_diff_deploy.XXXXXX)
      log "Created temporary diff deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'

      #!/usr/bin/env bash
      set -eu

      # ───────────────────────────────────────────────
      # 공통 유틸 함수
      # ───────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }

      # 파일 타입 검사 도우미
      is_link() { sudo test -L "$1"; }
      is_dir()  { sudo test -d "$1"; }
      # -o 대신 안전하게 두 번 검사
      is_any()  { sudo test -e "$1" || sudo test -L "$1"; }

      # ───────────────────────────────────────────────
      # require_envs()
      # 환경 변수 필수값 확인
      # ───────────────────────────────────────────────
      require_envs() {
        : "${REMOTE_DIR:?REMOTE_DIR is required}"
        : "${COMMIT_TAG:?COMMIT_TAG is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
        : "${WEBAPPS_ROOT:?WEBAPPS_ROOT is required}"
        : "${RELEASES_BASE:?RELEASES_BASE is required}"
        : "${ARTIFACTS_BASE:?ARTIFACTS_BASE is required}"
        : "${TOMCAT_SERVICE:?TOMCAT_SERVICE is required}"
        : "${KEEP_RELEASES:?KEEP_RELEASES is required}"
        : "${HEALTH_MODE:?HEALTH_MODE is required}"
        : "${HC_TIMEOUT:?HC_TIMEOUT is required}"
        : "${HC_INTERVAL:?HC_INTERVAL is required}"
        : "${NEXUS_USER:?NEXUS_USER is required}"
        : "${NEXUS_PASS:?NEXUS_PASS is required}"
        : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
        : "${GROUP_ID:?GROUP_ID is required}"
        : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      }

      # ───────────────────────────────────────────────
      # ensure_tools()
      # 필수 도구 설치 확인 (rsync, unzip 등)
      # ───────────────────────────────────────────────
      ensure_tools() {
        for t in rsync ln readlink zip awk sed grep sort uniq curl unzip mktemp df ls tee realpath; do
          if ! need "$t"; then
            if   need apk; then
              sudo apk add --no-cache coreutils "$t" || true
            elif need apt-get; then
              sudo apt-get update -y && sudo apt-get install -y "$t" || true
            elif need dnf; then
              sudo dnf install -y "$t" || true
            fi
          fi
        done
      }

      # ───────────────────────────────────────────────
      # setup_context()
      # 디렉터리 및 배포 경로 설정
      # ───────────────────────────────────────────────
      setup_context() {
        APP_NAME="${CONTEXT_PATH#/}"
        DEPLOY_VERSION="${COMMIT_TAG#v}"

        LIVE_LINK="${WEBAPPS_ROOT%/}/$APP_NAME"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/$APP_NAME"
        NEW_DIR="${ARTIFACTS_BASE%/}/$APP_NAME/$APP_NAME-$DEPLOY_VERSION"

        ART_DIR="$REMOTE_DIR/artifacts"
        OUT_ZIP="$ART_DIR/diff-deploy-artifacts.zip"

        uid="$(id -u)"; gid="$(id -g)"
        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
        sudo chown -R "$uid:$gid" "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
      }

      # ───────────────────────────────────────────────
      # maybe_fetch_new_dir()
      # NEW_DIR이 없을 경우 Nexus에서 WAR 자동 다운로드 및 unzip
      # ───────────────────────────────────────────────
      maybe_fetch_new_dir() {
        if [ -d "$NEW_DIR" ]; then
          log "기존 NEW_DIR 사용: $NEW_DIR"
          return
        fi
        log "NEW_DIR 없음 → Nexus에서 자동 생성"
        APP_PATH="${GROUP_ID//.//}/${ARTIFACT_ID}/${DEPLOY_VERSION}"
        NEW_WAR="${ARTIFACT_ID}-${DEPLOY_VERSION}.war"
        NEW_URL="${RELEASE_REPO_URL%/}/${APP_PATH}/${NEW_WAR}"
        TMP_DIR=$(sudo mktemp -d /tmp/${APP_NAME}-${DEPLOY_VERSION}-fetch.XXXXXX)

        sudo curl -fsSL -u "$NEXUS_USER:$NEXUS_PASS" -o "$TMP_DIR/$NEW_WAR" "$NEW_URL"
        sudo unzip -q "$TMP_DIR/$NEW_WAR" -d "$TMP_DIR/unzip"
        sudo test -d "$TMP_DIR/unzip/WEB-INF" || fail "WAR 구조 이상"
        sudo mkdir -p "$(dirname "$NEW_DIR")"
        sudo rm -rf "$NEW_DIR"
        sudo mv "$TMP_DIR/unzip" "$NEW_DIR"
        sudo rm -rf "$TMP_DIR"
        ok "NEW_DIR 생성 완료: $NEW_DIR"
      }

      # ───────────────────────────────────────────────
      # resolve_base_from_live()
      # LIVE 심볼릭 링크에서 BASE_DIR 추출 또는 초기화
      # ───────────────────────────────────────────────
      resolve_base_from_live() {
        prev_target=""
        if is_link "$LIVE_LINK"; then
          prev_target="$(sudo readlink -f "$LIVE_LINK" || true)"
        elif is_dir "$LIVE_LINK"; then
          seed="${APP_RELEASES_DIR}/diff-legacy-backup-$(ts)"
          log "LIVE_DIR 기반 초기 백업 생성 → $seed"
          sudo rsync -a --delete --exclude='_logs/**' "${LIVE_LINK%/}/" "${seed%/}/" || true
          prev_target="$seed"
          sudo ln -sT "$seed" "$LIVE_LINK" || true
        else
          log "LIVE_LINK가 없음 → 신규 서비스로 간주, 초기화 모드 실행"
          seed="${APP_RELEASES_DIR}/diff-initial-${APP_NAME}-$(ts)"
          sudo mkdir -p "$seed"
          sudo cp -a "${NEW_DIR%/}/." "$seed/"
          prev_target="$seed"
          sudo ln -sT "$seed" "$LIVE_LINK"
          ok "신규 서비스 초기화 완료: $seed"
        fi

        BASE_DIR="$(sudo readlink -f "$LIVE_LINK" || true)"
        [ -n "$BASE_DIR" ] || fail "BASE_DIR 확인 실패"
        [ -n "$prev_target" ] || prev_target="$BASE_DIR"
      }

      # ───────────────────────────────────────────────
      # prepare_target_from_prev()
      # 이전 릴리스 복제 후 TARGET 디렉터리 생성
      # ───────────────────────────────────────────────
      prepare_target_from_prev() {
        stamp="$(ts)"
        TARGET="${APP_RELEASES_DIR}/diff-${APP_NAME}-${DEPLOY_VERSION}-${stamp}"
        log "새 TARGET 생성: $TARGET"
        sudo mkdir -p "$TARGET"
        sudo rsync -a --delete  --exclude='_logs/**' "${prev_target%/}/" "${TARGET%/}/" || true

        LOG_DIR="${TARGET%/}/_logs"
        sudo rm -rf "$LOG_DIR"
        sudo mkdir -p "$LOG_DIR"
        sudo chown -R "$uid:$gid" "$LOG_DIR"

        DIFF_BASE_FILE="$LOG_DIR/diff-base.env"
        LIVE_POINTER_FILE="$LOG_DIR/live-pointer.env"
        CHANGED_LIST="$LOG_DIR/changed-files.txt"
        DELETE_LIST="$LOG_DIR/deleted-files.txt"
        : > "$CHANGED_LIST"; : > "$DELETE_LIST"
        printf 'BASE_DIR=%s\n' "$BASE_DIR" > "$DIFF_BASE_FILE"
      }

      # ───────────────────────────────────────────────
      # compute_diff_lists()
      # rsync dry-run 결과를 기반으로 변경/삭제 파일 목록 계산
      # ───────────────────────────────────────────────
      compute_diff_lists() {
        log "Rsync dry-run 실행 중 (NEW vs BASE)"
        mapfile -t lines < <(sudo rsync -ai --delete --dry-run --out-format='%i %n' \
          --exclude='_logs/**' --exclude='*.bad' --exclude='*.tmp' \
          --exclude='*.bak' --exclude='*.swp' --exclude='*.log' \
          "${NEW_DIR%/}/" "${BASE_DIR%/}/")

        for ln in "${lines[@]}"; do
          if printf '%s\n' "$ln" | grep -q '^\*deleting '; then
            f="${ln#*deleting }"
            echo "$f" >> "$DELETE_LIST"
          elif printf '%s\n' "$ln" | grep -qE '^(>f|\.f\+|>d)'; then
            f="$(printf '%s' "$ln" | sed 's/^[^ ]\+ //')"
            [[ "$f" == */ ]] && continue
            echo "$f" >> "$CHANGED_LIST"
          fi
        done
      }

      # ───────────────────────────────────────────────
      # apply_deletions()
      # DELETE_LIST 기반 안전 삭제 (심볼릭 링크는 링크 자체만 제거)
      # ───────────────────────────────────────────────
      apply_deletions() {
        local target="$1" list="$2"
        rp_tgt="$(realpath -m -- "$target")"
        pushd "$rp_tgt" >/dev/null

        while IFS= read -r rel || [[ -n "${rel:-}" ]]; do
          [[ -z "$rel" ]] && continue
          if [[ "$rel" = /* || "$rel" = *".."* ]]; then
            echo "[SKIP] 위험 경로: $rel"
            continue
          fi
          if [[ -L "$rel" ]]; then
            echo "[DEL] (symlink) $rel"
            sudo rm -f -- "$rel"
          elif [[ -e "$rel" ]]; then
            echo "[DEL] $rel"
            sudo rm -rf --one-file-system -- "$rel"
          fi
        done < "$list"

        popd >/dev/null
      }

      # ───────────────────────────────────────────────
      # apply_changes()
      # CHANGED_LIST 기반으로 변경 파일만 복사
      # ───────────────────────────────────────────────
      apply_changes() {
        if [ -s "$CHANGED_LIST" ]; then
          sudo rsync -a --files-from="$CHANGED_LIST" "${NEW_DIR%/}/" "${TARGET%/}/"
        fi
      }

      # ───────────────────────────────────────────────
      # switch_live_symlink()
      # LIVE 심볼릭 링크를 새 TARGET으로 전환
      # ───────────────────────────────────────────────
      switch_live_symlink() {
        tmp_link="${LIVE_LINK}.new.$(ts)"
        sudo ln -sT "$TARGET" "$tmp_link" || sudo ln -s "$TARGET" "$tmp_link"
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || {
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo mv "$tmp_link" "$LIVE_LINK"
        }
        log "LIVE → $TARGET 전환 완료"
      }

      # ───────────────────────────────────────────────
      # update_live_pointer()
      # 심링크 교체후에 라이브 포인터 정보 재기록
      # ───────────────────────────────────────────────
      update_live_pointer() {
        # 현재(LIVE)는 이제 TARGET, 이전은 prev_target (혹은 BASE_DIR)로 기록
        local current="$TARGET"
        local prev="$prev_target"   # BASE_DIR을 쓰고 싶다면 prev="$BASE_DIR"
        sudo sh -c "printf 'CURRENT=%s\nPREV=%s\n' '$current' '${prev:-}' > '$TARGET/_logs/live-pointer.env'"
      }

      # ───────────────────────────────────────────────
      # reload_or_restart_tomcat()
      # Tomcat 핫리로드 or 재기동 처리
      # ───────────────────────────────────────────────
      reload_or_restart_tomcat() {
        if [ "$HOT_RELOAD" = "true" ] && [ -n "$DEPLOY_USER" ]; then
          sudo curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://$WAS_URL/manager/text/reload?path=/${APP_NAME}" || true
        else
          sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null || sudo systemctl restart "$TOMCAT_SERVICE"
        fi
      }

      # ───────────────────────────────────────────────
      # do_healthcheck()
      # 배포 후 서비스 정상 응답 확인
      # ───────────────────────────────────────────────
      do_healthcheck() {
        case "$HEALTH_MODE" in
          actuator) hc_url="http://127.0.0.1:8080/${APP_NAME}/actuator/health" ;;
          page)     hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
          none)     return ;;
          *)        hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
        esac

        elapsed=0
        while [ "$elapsed" -lt "$HC_TIMEOUT" ]; do
          if sudo curl -fsS --max-time 3 "$hc_url" >/dev/null 2>&1; then
            ok "헬스체크 성공: $hc_url"
            return
          fi
          sleep "$HC_INTERVAL"; elapsed=$((elapsed+HC_INTERVAL))
        done
        fail "헬스체크 실패: $hc_url"
      }

      # ───────────────────────────────────────────────
      # prune_releases()
      # KEEP_RELEASES 초과 버전 정리
      # ───────────────────────────────────────────────
      prune_releases() {
        mapfile -t snaps < <(sudo ls -1dt "${APP_RELEASES_DIR}/diff-${APP_NAME}-"* 2>/dev/null || true)
        if [ "${#snaps[@]}" -gt "$KEEP_RELEASES" ]; then
          for ((i=KEEP_RELEASES; i<${#snaps[@]}; i++)); do
            [ "${snaps[$i]}" = "$TARGET" ] && continue
            sudo rm -rf --one-file-system "${snaps[$i]}" || true
          done
        fi
      }

      # ───────────────────────────────────────────────
      # package_artifacts()
      # 로그, 목록 파일 등을 ZIP으로 압축
      # ───────────────────────────────────────────────
      package_artifacts() {
        sudo cp -f "$DIFF_BASE_FILE" "$ART_DIR/diff-base.env" || true
        sudo cp -f "$CHANGED_LIST" "$ART_DIR/changed-files.txt" || true
        sudo cp -f "$DELETE_LIST" "$ART_DIR/deleted-files.txt" || true

        {
          echo "DEPLOYED_VERSION=$DEPLOY_VERSION"
          echo "LIVE_LINK=$LIVE_LINK"
          echo "TARGET=$TARGET"
          echo "BASE_DIR=$BASE_DIR"
        } > "$ART_DIR/.env"

        ( cd "$ART_DIR" && zip -r "$(basename "$OUT_ZIP")" .env *.txt >/dev/null 2>&1 )
        ok "배포 로그 ZIP 생성 완료"
        echo "$OUT_ZIP"
      }

      # ───────────────────────────────────────────────
      # main
      # ───────────────────────────────────────────────
      main() {
        require_envs
        ensure_tools
        setup_context
        maybe_fetch_new_dir
        resolve_base_from_live
        prepare_target_from_prev
        compute_diff_lists
        apply_deletions "$TARGET" "$DELETE_LIST"
        apply_changes
        switch_live_symlink
        reload_or_restart_tomcat
        do_healthcheck
        prune_releases
        package_artifacts
      }

      main "$@"

    REMOTE_SH

      log "▶ Executing diff deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "ARTIFACTS_BASE='$(shq "$artifacts_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "KEEP_RELEASES='$(shq "$keep_releases")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "WAS_URL='$(shq "$was_url")'" \
        "AUTO_FETCH_ON_MISSING='$(shq "$auto_fetch_on_missing")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        'export REMOTE_DIR COMMIT_TAG CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE ARTIFACTS_BASE TOMCAT_SERVICE KEEP_RELEASES HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL HOT_RELOAD DEPLOY_USER DEPLOY_PASS WAS_URL AUTO_FETCH_ON_MISSING NEXUS_USER NEXUS_PASS RELEASE_REPO_URL GROUP_ID ARTIFACT_ID; bash -s' \
        < "$remote_script" | tee /tmp/_diff_deploy_out.txt

      remote_zip_path="$(tail -n1 /tmp/_diff_deploy_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/diff-deploy-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_diff_deploy_out.txt || true
      ok "Diff deploy finished"
    }

# ───────────────────────────────────────────────────────────────────────────────
# 함수: fn_tomcat_diff_restore
#
# 목적:
#   - /opt/tomcat/releases/<app>/ 아래의 diff 스냅샷(diff-<app>-<ver>-<ts>) 중
#     지정 대상(이름 또는 버전)이나 “현재보다 한 단계 이전” 스냅샷으로
#     LIVE 심링크를 원자적으로 되돌리고 Tomcat 반영 및 헬스체크를 수행한다.
#
# 작동 개요(코드 기준):
#   1) 현재 LIVE 대상 파악:
#      - LIVE_LINK = <WEBAPPS_ROOT>/<app>, current = readlink -f(LIVE_LINK)
#      - LIVE가 심링크가 아니면(레거시) releases/<app>로 마이그레이션 수행(1회)
#   2) 후보 조회(최신순):
#      - /opt/tomcat/releases/<app>/diff-<app>-* 디렉터리
#      - 디렉터리 내 .bad 마커가 있으면 후보에서 제외(자동화 안정성)
#   3) 대상 선택 우선순위:
#      - ROLLBACK_TO_NAME(정확한 디렉터리명) >
#        ROLLBACK_TO_VERSION(버전 일치) >
#        현재 타깃의 _logs/diff-base.env 의 BASE_DIR 값(직전 운영) >
#        “현재보다 한 단계 이전”(없으면 최신/유일 후보)
#      - 자기 자신(current)으로 선택되는 경우는 다음 적합 후보로 대체
#   4) LIVE 전환(원자적):
#      - ln -sT target <tmp link> → mv -Tf 로 LIVE_LINK 교체(폴백 처리 포함)
#      - 대상 스냅샷의 _logs/live-pointer.env 에 CURRENT=target, PREV=<이전 current> 기록
#   5) Tomcat 적용:
#      - HOT_RELOAD=true & DEPLOY_USER/PASS 있으면 manager reload 호출
#      - 아니면 systemctl reload 실패 시 restart
#   6) 헬스체크:
#      - HEALTH_URL_OVERRIDE 우선, 없으면 mode에 따라 기본 URL 구성
#      - 실패 시 fail
#   7) 마커 처리:
#      - 성공 롤백 후, 이전 current 디렉터리에 .bad 마커를 기록(옵션)
#   8) 산출물 zip 반환:
#      - 원격: $REMOTE_DIR/artifacts/diff-restore-artifacts.zip
#
# 주요 경로(코드 기본값):
#   WEBAPPS_ROOT  : /opt/tomcat/webapps
#   RELEASES_BASE : /opt/tomcat/releases
#   LIVE_LINK     : <WEBAPPS_ROOT>/<app>
#   SNAPSHOTS     : <RELEASES_BASE>/<app>/diff-<app>-*
#   LOGS PER SNAP : <SNAPSHOT>/_logs/{diff-base.env, live-pointer.env, ...}
#   BAD_MARKER    : .bad (변수 BAD_MARKER_NAME)
#
# 산출물(원격에 생성):
#   $REMOTE_DIR/artifacts/
#     ├── diff-restore-artifacts.zip
#     ├── diff-restore.log             (RESTORE_LOG_NAME, 기본 diff-restore.log)
#     └── .env
#         - ROLLED_BACK_FROM=<이전 current>
#         - ROLLED_BACK_TO=<target dir>
#         - LIVE_LINK=<LIVE_LINK>
#         - RESOLVED_BY=override:name|override:version|diff-base.env|list:*
#
# 필수 환경변수(외부 래퍼/CI에서 주입):
#   REMOTE_DEPLOY_HOST, REMOTE_DEPLOY_USER, REMOTE_DIR, CONTEXT_PATH
#
# 내부 스크립트가 요구하는 추가 변수(함수에서 기본값 제공/전달):
#   WEBAPPS_ROOT=/opt/tomcat/webapps
#   RELEASES_BASE=/opt/tomcat/releases
#   TOMCAT_SERVICE=tomcat
#   WAS_URL=127.0.0.1:8080
#   ROLLBACK_TO_NAME=""                # 예: diff-devops-1.4.0-20251019101822
#   ROLLBACK_TO_VERSION=""             # 예: 1.4.0
#   HEALTH_MODE=page | actuator | none
#   HEALTH_URL_OVERRIDE=""
#   HEALTHCHECK_TIMEOUT=60
#   HEALTHCHECK_INTERVAL=2
#   HOT_RELOAD=false
#   DEPLOY_USER=""
#   DEPLOY_PASS=""
#   RESTORE_LOG_NAME=diff-restore.log
#   MARK_BAD_ON_ROLLBACK=true
#   BAD_MARKER_NAME=.bad
#
# 주의사항(코드 반영됨):
#   - 후보 목록은 최신순이며, .bad 마커가 있는 스냅샷은 자동 제외.
#   - 현재 대상(current)과 동일한 스냅샷으로의 전환을 회피하도록 보호 로직 포함.
#   - ln -sT + mv -Tf 조합으로 원자적 전환, 실패 시 rm → mv 폴백 처리.
# ───────────────────────────────────────────────────────────────────────────────
.fn_tomcat_diff_restore:
  script: |
    fn_tomcat_diff_restore() {
      set -eu

      # ── 필수 ──────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"

      # ── 선택 ──────────────────────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"
      was_url="${WAS_URL:-127.0.0.1:8080}"

      rollback_to_name="${ROLLBACK_TO_NAME:-}"           # 예: diff-devops-1.4.0-20251019101822
      rollback_to_version="${ROLLBACK_TO_VERSION:-}"     # 예: 1.4.0

      mark_bad_on_rollback="${MARK_BAD_ON_ROLLBACK:-true}"
      bad_marker_name="${BAD_MARKER_NAME:-.bad}"

      health_mode="${HEALTH_MODE:-page}"
      health_url_override="${HEALTH_URL_OVERRIDE:-}"
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"

      restore_log_name="${RESTORE_LOG_NAME:-diff-restore.log}"

      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      remote_script=$(mktemp /tmp/remote_diff_restore.XXXXXX)
      log "Created temporary diff restore script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH' 
      #!/usr/bin/env bash
      set -eu

      # ── 공통 유틸 ───────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }
      is_link() { sudo test -L "$1"; }
      is_dir()  { sudo test -d "$1"; }

      # ── 입력 검증 ───────────────────────────────────────
      require_envs() {
        : "${REMOTE_DIR:?}"
        : "${CONTEXT_PATH:?}"
        : "${WEBAPPS_ROOT:?}"
        : "${RELEASES_BASE:?}"
        : "${TOMCAT_SERVICE:?}"
        : "${WAS_URL:?}"
        : "${ROLLBACK_TO_NAME:-}"
        : "${ROLLBACK_TO_VERSION:-}"
        : "${HEALTH_MODE:?}"
        : "${HEALTH_URL_OVERRIDE:-}"
        : "${HC_TIMEOUT:?}"
        : "${HC_INTERVAL:?}"
        : "${HOT_RELOAD:?}"
        : "${DEPLOY_USER:-}"
        : "${DEPLOY_PASS:-}"
        : "${RESTORE_LOG_NAME:?}"
        : "${MARK_BAD_ON_ROLLBACK:?}"
        : "${BAD_MARKER_NAME:?}"
      }

      # ── 도구 확인/설치 ─────────────────────────────────
      ensure_tools() {
        local tools="ln readlink zip ls grep awk sed curl"
        for t in $tools; do
          if ! need "$t"; then
            if   need apk;     then sudo apk add --no-cache "$t" || true
            elif need apt-get; then sudo apt-get update -y && sudo apt-get install -y "$t" || true
            elif need dnf;     then sudo dnf install -y "$t" || true
            fi
          fi
        done
        # systemctl은 선택
      }

      # ── 컨텍스트 구성 ───────────────────────────────────
      setup_context() {
        APP_NAME="${CONTEXT_PATH#/}"
        LIVE_LINK="${WEBAPPS_ROOT%/}/${APP_NAME}"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/${APP_NAME}"

        ART_DIR="$REMOTE_DIR/artifacts"
        LOG="$ART_DIR/$RESTORE_LOG_NAME"
        OUT_ZIP="$ART_DIR/diff-restore-artifacts.zip"

        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
        : > "$LOG"
      }

      # ── 현재 LIVE 대상 확인 ────────────────────────────
      get_current_live() {
        CURRENT=""
        if is_link "$LIVE_LINK"; then
          CURRENT="$(sudo readlink -f "$LIVE_LINK" || true)"
        fi
        echo "CURRENT=$CURRENT" | tee -a "$LOG"
      }

      # ── 후보 스냅샷 수집 (최신순, BAD 제외) ─────────────
      collect_candidates() {
        local list
        mapfile -t list < <(
          ls -1dt "${APP_RELEASES_DIR}/diff-${APP_NAME}-"* 2>/dev/null \
          | while read -r d; do
              if sudo test -f "$d/$BAD_MARKER_NAME"; then
                continue
              fi
              printf "%s\n" "$d"
            done
        )
        CANDIDATES=("${list[@]}")
      }

      # ── 후보 결정 1: 이름 강제 ──────────────────────────
      resolve_by_name() {
        [ -n "${ROLLBACK_TO_NAME:-}" ] || return 1
        local cand="${APP_RELEASES_DIR}/${ROLLBACK_TO_NAME}"
        [ -d "$cand" ] || fail "rollback target not found: $cand"
        TARGET="$cand"; RESOLVED_BY="override:name"
        return 0
      }

      # ── 후보 결정 2: 버전 강제 ───────────────────────────
      resolve_by_version() {
        [ -n "${ROLLBACK_TO_VERSION:-}" ] || return 1
        [ "${#CANDIDATES[@]}" -ge 1 ] || fail "no diff snapshots found"
        local d base ver
        for d in "${CANDIDATES[@]}"; do
          base="$(basename "$d")"
          ver="$(printf "%s" "$base" | sed -E "s/^diff-${APP_NAME}-([^-]+)-.*/\1/")"
          if [ "$ver" = "$ROLLBACK_TO_VERSION" ]; then
            TARGET="$d"; RESOLVED_BY="override:version"; return 0
          fi
        done
        fail "no snapshot found for version: $ROLLBACK_TO_VERSION"
      }

      # ── 후보 결정 3: diff-base.env 기반 ─────────────────
      resolve_by_diffbase() {
        [ -n "${CURRENT:-}" ] && [ -d "${CURRENT:-}" ] || return 1
        local dbase lp base_dir cur_in_log
        dbase="$CURRENT/_logs/diff-base.env"
        lp="$CURRENT/_logs/live-pointer.env"
        if sudo test -f "$lp"; then
          cur_in_log="$(sudo awk -F= '/^CURRENT=/{print $2}' "$lp" 2>/dev/null || true)"
          echo "CHECK live-pointer CURRENT=$cur_in_log" | tee -a "$LOG"
        fi
        if sudo test -f "$dbase"; then
          base_dir="$(sudo awk -F= '/^BASE_DIR=/{print $2}' "$dbase" 2>/dev/null || true)"
          if [ -n "$base_dir" ] && [ -d "$base_dir" ]; then
            TARGET="$base_dir"; RESOLVED_BY="diff-base.env"; return 0
          fi
        fi
        return 1
      }

      # ── 후보 결정 4: 목록 폴백(현재 이전/세컨드 최신 등) ─
      resolve_by_list() {
        [ "${#CANDIDATES[@]}" -ge 1 ] || fail "no diff snapshots found"

        if [ -n "${CURRENT:-}" ]; then
          local found=0 idx=0 i
          for ((i=0; i<${#CANDIDATES[@]}; i++)); do
            [ "$(sudo readlink -f "${CANDIDATES[$i]}")" = "$CURRENT" ] && { found=1; idx=$i; break; }
          done
          if [ "$found" = 1 ] && [ $((idx+1)) -lt ${#CANDIDATES[@]} ]; then
            TARGET="${CANDIDATES[$((idx+1))]}"; RESOLVED_BY="list:prev-of-current"; return 0
          fi
        fi

        if [ "${#CANDIDATES[@]}" -ge 2 ]; then
          TARGET="${CANDIDATES[1]}"; RESOLVED_BY="list:second-latest"
        else
          TARGET="${CANDIDATES[0]}"; RESOLVED_BY="list:latest"
        fi
        return 0
      }

      # ── LIVE 링크 전환 ──────────────────────────────────
      switch_live() {
        [ -n "${TARGET:-}" ] && [ -d "$TARGET" ] || fail "rollback target invalid"
        echo "TARGET=$TARGET (resolved_by=$RESOLVED_BY)" | tee -a "$LOG"

        local tmp_link="${LIVE_LINK}.new.$(ts)"
        sudo ln -sT "$TARGET" "$tmp_link" 2>/dev/null || sudo ln -s "$TARGET" "$tmp_link"
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || {
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo mv "$tmp_link" "$LIVE_LINK"
        }
        log "LIVE -> $TARGET"
      }

      # ── Tomcat 반영(핫리로드/재로드/재시작) ──────────────
      apply_tomcat() {
        if [ "$HOT_RELOAD" = "true" ] && [ -n "${DEPLOY_USER:-}" ] && [ -n "${DEPLOY_PASS:-}" ] && need curl; then
          curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://$WAS_URL/manager/text/reload?path=/${APP_NAME}" >>"$LOG" 2>&1 || true
        else
          if need systemctl; then
            if sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null; then
              :
            else
              sudo systemctl restart "$TOMCAT_SERVICE"
            fi
          fi
        fi
      }

      # ── Healthcheck ─────────────────────────────────────
      healthcheck() {
        local hc_url=""
        if [ -n "${HEALTH_URL_OVERRIDE:-}" ]; then
          hc_url="$HEALTH_URL_OVERRIDE"
        else
          case "$HEALTH_MODE" in
            actuator) hc_url="http://127.0.0.1:8080/${APP_NAME}/actuator/health" ;;
            page)     hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
            none)     hc_url="" ;;
            *)        hc_url="http://127.0.0.1:8080/${APP_NAME}/" ;;
          esac
        fi

        [ -n "$hc_url" ] || return 0
        need curl || return 0

        local elapsed=0 ok_flag=0
        while [ "$elapsed" -lt "$HC_TIMEOUT" ]; do
          if curl -fsS --max-time 3 "$hc_url" >/dev/null 2>&1; then ok_flag=1; break; fi
          sleep "$HC_INTERVAL"; elapsed=$((elapsed+HC_INTERVAL))
        done
        [ "$ok_flag" = 1 ] || fail "rollback health failed: $hc_url"
      }

      # ── BAD 마커 처리 ───────────────────────────────────
      mark_bad_if_needed() {
        if [ -n "${CURRENT:-}" ] && [ -d "${CURRENT:-}" ] && [ "$MARK_BAD_ON_ROLLBACK" = "true" ]; then
          sudo sh -c "printf 'marked bad on %s\n' \"$(date -Ins)\" > '$CURRENT/$BAD_MARKER_NAME'"
        fi
      }

      # ── live-pointer.env 업데이트 ────────────────────────
      update_live_pointer() {
        if [ -d "$TARGET/_logs" ]; then
          sudo sh -c "printf 'CURRENT=%s\nPREV=%s\n' '$TARGET' '${CURRENT:-}' > '$TARGET/_logs/live-pointer.env'" || true
        fi
      }

      # ── 산출물 패키징 ───────────────────────────────────
      package_artifacts() {
        {
          echo "ROLLED_BACK_FROM=${CURRENT:-}"
          echo "ROLLED_BACK_TO=$TARGET"
          echo "LIVE_LINK=$LIVE_LINK"
          echo "RESOLVED_BY=$RESOLVED_BY"
        } > "$ART_DIR/.env"

        sudo rm -f "$OUT_ZIP"
        ( cd "$ART_DIR" && zip -r "$(basename "$OUT_ZIP")" "$(basename "$LOG")" ".env" >/dev/null 2>&1 || true )
        ok "Diff restore completed"
        echo "$OUT_ZIP"
      }

      # ── 후보 결정 파이프라인 ────────────────────────────
      choose_target() {
        TARGET=""; RESOLVED_BY=""
        resolve_by_name     && return 0
        resolve_by_version  && return 0
        resolve_by_diffbase && return 0
        resolve_by_list     && return 0
        fail "no rollback target could be resolved"
      }

      # ── main ────────────────────────────────────────────
      main() {
        require_envs
        ensure_tools
        setup_context
        get_current_live
        collect_candidates
        choose_target
        switch_live
        apply_tomcat
        healthcheck
        mark_bad_if_needed
        update_live_pointer
        package_artifacts
      }
      main "$@"

    REMOTE_SH

      log "▶ Executing diff restore via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "WAS_URL='$(shq "$was_url")'" \
        "ROLLBACK_TO_NAME='$(shq "$rollback_to_name")'" \
        "ROLLBACK_TO_VERSION='$(shq "$rollback_to_version")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "RESTORE_LOG_NAME='$(shq "$restore_log_name")'" \
        "MARK_BAD_ON_ROLLBACK='$(shq "$mark_bad_on_rollback")'" \
        "BAD_MARKER_NAME='$(shq "$bad_marker_name")'" \
        'export REMOTE_DIR CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE TOMCAT_SERVICE WAS_URL ROLLBACK_TO_NAME ROLLBACK_TO_VERSION HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL HOT_RELOAD DEPLOY_USER DEPLOY_PASS RESTORE_LOG_NAME MARK_BAD_ON_ROLLBACK BAD_MARKER_NAME; bash -s' \
        < "$remote_script" | tee /tmp/_diff_restore_out.txt

      remote_zip_path="$(tail -n1 /tmp/_diff_restore_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/diff-restore-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_diff_restore_out.txt || true
      ok "Diff restore finished"
    }

# ────────────────────────────────────────────────
# 함수: fn_tomcat_symbolic_deploy
#
# 목적:
#   - Tomcat 운영 서버에 "심링크 전환 방식"으로 새 버전을 배포한다.
#   - LIVE 링크(webapps/<APP_NAME>)를 /opt/tomcat/releases/<APP_NAME>/<APP_NAME>-<version> 로 전환.
#   - 헬스체크 실패 시, 직전 타깃 디렉터리로 자동 롤백한다.
#
# 동작 개요:
#   1) Runner → SSH 접속 → 원격 임시 스크립트 생성
#   2) Nexus에서 NEW WAR 다운로드 및 검사/압축해제
#   3) releases/<APP>/<APP-<version>> 디렉터리 생성 후 WAR unzip 결과 반영
#   4) LIVE 링크를 심링크로 보정(최초 1회, 디렉터리→심링크 마이그레이션)
#   5) LIVE 링크를 새 버전 디렉터리로 원자적 전환 (ln -sfn)
#   6) Tomcat reload 시도(불가 시 restart)
#   7) 헬스체크(HEALTH_MODE 또는 --health-url 대체); 실패 시 자동 롤백
#   8) 보관정책(KEEP_RELEASES) 적용: 오래된 릴리스 디렉터리 삭제
#   9) 로그/메타(.env)를 zip으로 묶어 Runner 아티팩트로 회수
#
# 특징:
#   - 원격 SSH 실행/정리/아티팩트 회수 플로우는 기존과 동일
#   - LIVE가 디렉터리인 레거시 환경을 자동으로 심링크로 전환
#   - Nexus 인증 기반 다운로드(유저/패스), 필요한 툴은 OS별 설치 시도
#   - HOT_RELOAD=true & Tomcat Manager 계정이 있으면 컨텍스트 reload 시도
#   - 실패 시 직전 타깃(심링크의 이전 대상)으로 즉시 되돌림
#
# 생성/수정되는 리소스:
#   - 원격: /opt/tomcat/releases/<APP_NAME>/<APP_NAME>-<version> (새 버전)
#   - 원격: <WEBAPPS_ROOT>/<APP_NAME> (LIVE 심링크)
#   - 원격: <REMOTE_DIR>/artifacts/{symlink-deploy-artifacts.zip, .env, 로그}
#   - 로컬(Runner): artifacts/symlink-deploy-artifacts.zip (회수)
#
# 종료/실패 시나리오:
#   - 헬스체크 실패 시: 라이브 링크를 직전 타깃으로 되돌리고 종료(비정상 종료)
#   - 이전 타깃 부재 시: 롤백 불가로 실패 처리
#
# 권장 전제조건:
#   - Tomcat 서비스명이 정확(TOMCAT_SERVICE), manager(reload) 권한은 선택
#   - releases, webapps 경로에 쓰기 가능(권한/SELinux 정책 환경에 맞춰 운영)
#   - Nexus에 해당 버전 WAR가 존재하고 접근 가능
# ────────────────────────────────────────────────
.fn_tomcat_symbolic_deploy:
  script: |
    fn_tomcat_symbolic_deploy() {
      set -eu

      # ── 필수 입력 ─────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
      : "${GROUP_ID:?GROUP_ID is required}"
      : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
      : "${COMMIT_TAG:?COMMIT_TAG is required}"
      : "${WAS_URL:?WAS_URL is required}"
      : "${NEXUS_USER:?NEXUS_USER is required}"
      : "${NEXUS_PASS:?NEXUS_PASS is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"   # 예: /devops

      # ── 선택 입력(기본값) ───────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"         # tomcat|tomcat9|tomcat10 등
      keep_releases="${KEEP_RELEASES:-5}"

      # 헬스체크 정책
      health_mode="${HEALTH_MODE:-actuator}"             # actuator|page|none
      health_url_override="${HEALTH_URL_OVERRIDE:-}"     # 지정 시 최우선
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      # Tomcat manager 옵션(핫리로드)
      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"

      # 로그/산출물
      deploy_log_name="${DEPLOY_LOG_NAME:-symlink-deploy.log}"

      # ── 유틸 ─────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 원격 스크립트 생성 ───────────────────────────
      remote_script=$(mktemp /tmp/remote_symlink_deploy.XXXXXX)
      log "Created temporary symlink deploy script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      #!/usr/bin/env bash
      set -euo pipefail
      IFS=$'\n\t'

      # ── 유틸 ─────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }

      # sudo 기반 탐지 (권한 문제 회피)
      is_link() { sudo test -L "$1"; }                 # 심링크?
      is_dir()  { sudo test -d "$1"; }                 # 디렉터리?
      is_any()  { sudo test -e "$1" || sudo test -L "$1"; } # 어떤 엔트리든 존재?

      # ── ENV 검증/기본값 ─────────────────────────────────
      require_env() {
        : "${REMOTE_DIR:?REMOTE_DIR is required}"
        : "${RELEASE_REPO_URL:?RELEASE_REPO_URL is required}"
        : "${GROUP_ID:?GROUP_ID is required}"
        : "${ARTIFACT_ID:?ARTIFACT_ID is required}"
        : "${COMMIT_TAG:?COMMIT_TAG is required}"
        : "${WAS_URL:?WAS_URL is required}"
        : "${NEXUS_USER:?NEXUS_USER is required}"
        : "${NEXUS_PASS:?NEXUS_PASS is required}"
        : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
        : "${WEBAPPS_ROOT:?WEBAPPS_ROOT is required}"
        : "${RELEASES_BASE:?RELEASES_BASE is required}"
        : "${TOMCAT_SERVICE:?TOMCAT_SERVICE is required}"
        : "${KEEP_RELEASES:?KEEP_RELEASES is required}"

        : "${HEALTH_MODE:=actuator}"      # actuator|page|none
        : "${HEALTH_URL_OVERRIDE:=}"      # 지정 시 최우선
        : "${HC_TIMEOUT:=60}"
        : "${HC_INTERVAL:=2}"

        : "${HOT_RELOAD:=false}"
        : "${DEPLOY_USER:=}"
        : "${DEPLOY_PASS:=}"

        : "${DEPLOY_LOG_NAME:=symlink-deploy.log}"
        : "${BAD_MARKER_NAME:=.bad}"
        : "${MARK_BAD_ON_ROLLBACK:=true}"

        APP_NAME="${CONTEXT_PATH#/}"                       # "/devops" → "devops"
        LIVE_LINK="${WEBAPPS_ROOT%/}/${APP_NAME}"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/${APP_NAME}"
        ART_DIR="$REMOTE_DIR/artifacts"
        LOG="$ART_DIR/$DEPLOY_LOG_NAME"
        OUT_ZIP="$ART_DIR/symlink-deploy-artifacts.zip"

        NEW_VERSION="${COMMIT_TAG#v}"
        BASE_URL="${RELEASE_REPO_URL%/}/${GROUP_ID//.//}/${ARTIFACT_ID}"
        NEW_WAR="${ARTIFACT_ID}-${NEW_VERSION}.war"
        NEW_URL="${BASE_URL}/${NEW_VERSION}/${NEW_WAR}"

        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
        # 로그 파일 생성/초기화도 sudo로
        sudo sh -c ": > \"$LOG\""
      }

      # ── 도구 보장 ───────────────────────────────────────
      ensure_tools() {
        local pkgs=(curl unzip zip ln readlink)

        for t in "${pkgs[@]}"; do
          if ! need "$t"; then
            if   need apk; then
              sudo apk add --no-cache "$t" || true
            elif need apt-get; then
              sudo apt-get update -y || true
              sudo apt-get install -y "$t" || true
            elif need dnf; then
              sudo dnf install -y "$t" || true
            elif need yum; then
              sudo yum install -y "$t" || true
            elif need zypper; then
              sudo zypper --non-interactive install "$t" || true
            else
              log "WARN: unknown package manager; cannot auto-install '$t'"
            fi
          fi
        done

        # 최종 확인
        for t in "${pkgs[@]}"; do
          need "$t" || fail "'$t' not available"
        done
      }

      # ── NEW(=새 릴리스) 준비 ────────────────────────────
      prepare_new_version() {
        new_dir="${APP_RELEASES_DIR}/${APP_NAME}-${NEW_VERSION}"
        tmp_dir="${new_dir}.tmp.$$"

        log "Download NEW: $NEW_URL"
        sudo mkdir -p "$tmp_dir"
        sudo curl -fsS -u "$NEXUS_USER:$NEXUS_PASS" -o "$tmp_dir/$NEW_WAR" "$NEW_URL" | sudo tee -a "$LOG" >/dev/null || true

        sudo unzip -q "$tmp_dir/$NEW_WAR" -d "$tmp_dir/unzip"
        sudo test -d "$tmp_dir/unzip/WEB-INF" || fail "WAR structure invalid (no WEB-INF)"

        sudo rm -rf "$new_dir"
        sudo mv "$tmp_dir/unzip" "$new_dir"
        sudo rm -rf "$tmp_dir" || true

        printf 'NEW_VERSION=%s\n' "$NEW_VERSION" | sudo tee -a "$LOG" >/dev/null
        printf 'NEW_DIR=%s\n' "$new_dir" | sudo tee -a "$LOG" >/dev/null
      }

      # ── 기존 LIVE → 릴리스로 1회 이관(최초 배포 포함) ─────────
      migrate_live_once() {
        prev_target=""

        log "MIGRATE: probe $(sudo ls -ld "$LIVE_LINK" 2>/dev/null || echo '<not-found>')"

        if is_link "$LIVE_LINK"; then
          prev_target="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
          log "MIGRATE: already symlink -> ${prev_target:-<broken>}"
          return 0
        fi

        if is_dir "$LIVE_LINK"; then
          local legacy="${APP_RELEASES_DIR}/${APP_NAME}-legacy-$(ts)"
          log "MIGRATE: moving DIR to legacy: $legacy"
          sudo mv "$LIVE_LINK" "$legacy"
          prev_target="$legacy"
        elif is_any "$LIVE_LINK"; then
          local legacy="${APP_RELEASES_DIR}/${APP_NAME}-legacy-$(ts).file"
          log "MIGRATE: moving FILE to legacy: $legacy"
          sudo mv "$LIVE_LINK" "$legacy"
        else
          log "MIGRATE: nothing to move (first deploy likely)"
        fi
      }

      # ── 심링크 전환 ─────────────────────────────────────
      ln_s_safe() {
        local tgt="$1" link="$2"
        link="${link%/}"
        sudo ln -sT "$tgt" "$link" 2>/dev/null || sudo ln -s "$tgt" "$link"
      }
      set_live_symlink() {
        local target_dir="$1"
        local tmp_link="${LIVE_LINK}.new.$(ts)"
        ln_s_safe "$target_dir" "$tmp_link"
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || { sudo rm -rf --one-file-system "$LIVE_LINK"; sudo mv "$tmp_link" "$LIVE_LINK"; }
        log "LIVE -> $target_dir"
      }

      # ── 서비스 갱신 ────────────────────────────────────
      tomcat_reload_or_restart() {
        if [ "${HOT_RELOAD}" = "true" ] && [ -n "${DEPLOY_USER}" ] && [ -n "${DEPLOY_PASS}" ] && need curl; then
          curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://${WAS_URL}/manager/text/reload?path=/${APP_NAME}" | sudo tee -a "$LOG" >/dev/null || true
          log "Tomcat manager reload attempted"
          return 0
        fi
        if need systemctl; then
          if sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null; then
            log "Tomcat reload ok"; return 0
          fi
          log "Reload unsupported → restart"
          sudo systemctl restart "$TOMCAT_SERVICE"
          log "Tomcat restart ok"
        fi
      }

      # ── 헬스체크 (URL 생성/대기) ─────────────────────────
      health_url_build() {
        if [ -n "$HEALTH_URL_OVERRIDE" ]; then
          printf '%s\n' "$HEALTH_URL_OVERRIDE"; return
        fi
        case "$HEALTH_MODE" in
          actuator) printf 'http://127.0.0.1:8080/%s/actuator/health\n' "$APP_NAME" ;;
          page)     printf 'http://127.0.0.1:8080/%s/\n' "$APP_NAME" ;;
          none)     printf '\n' ;;
          *)        printf 'http://127.0.0.1:8080/%s/actuator/health\n' "$APP_NAME" ;;
        esac
      }

      health_wait() {
        local url="$1" timeout="$2" interval="$3" elapsed=0
        while [ "$elapsed" -lt "$timeout" ]; do
          if curl -fsS --max-time 3 "$url" >/dev/null 2>&1; then
            log "Health OK: $url"
            return 0
          fi
          sleep "$interval"
          elapsed=$((elapsed+interval))
        done
        return 1
      }

      # ── live-pointer 기록/활용 ──────────────────────────
      ensure_logs_dir() { sudo mkdir -p "$1/_logs"; }

      write_live_pointer() {
        ## $1=current_release_dir, $2=prev_release_dir
        local current="$1" prev="${2:-}"

        # PREV 유효할 때만 기록 (sudo로 검사)
        if [ -z "$prev" ] || ! sudo test -d "$prev"; then
          log "live-pointer: skip write (no valid PREV)"
          return 0
        fi

        ensure_logs_dir "$current"

        sudo sh -c \
          "printf 'CURRENT=%s\nPREV=%s\n' \
            \"\$(readlink -f \"$current\" 2>/dev/null || echo \"$current\")\" \
            \"\$(readlink -f \"$prev\" 2>/dev/null || echo '')\" \
            > \"$current/_logs/live-pointer.env\""

        log "live-pointer.env updated (CURRENT=$(sudo readlink -f "$current" 2>/dev/null || echo "$current"), PREV=$(sudo readlink -f "$prev" 2>/dev/null || echo "$prev"))"
      }

      # 안전한 롤백 후보 탐색
      resolve_prev_for_rollback() {
        local new="$1" prev_hint="${2:-}"
        local live_real="" prev="" rels=() i idx=-1 cand=""

        live_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"

        # 1) 현재 LIVE의 live-pointer.env
        if [ -n "$live_real" ] && sudo test -f "$live_real/_logs/live-pointer.env"; then
          prev="$(sudo awk -F= '/^PREV=/{print $2}' "$live_real/_logs/live-pointer.env" | tr -d '\r')"
          if [ -n "$prev" ] && sudo test -d "$prev" && ! sudo test -f "$prev/$BAD_MARKER_NAME"; then
            printf '%s\n' "$prev"; return 0
          fi
        fi

        # 2) prev_hint (배포 직전 LIVE)
        if [ -n "$prev_hint" ] && sudo test -d "$prev_hint" && ! sudo test -f "$prev_hint/$BAD_MARKER_NAME"; then
          printf '%s\n' "$prev_hint"; return 0
        fi

        # 3) 릴리스 목록에서 new의 바로 이전(older sibling)
        mapfile -t rels < <(sudo ls -1dt "${APP_RELEASES_DIR}/${APP_NAME}-"* 2>/dev/null || true)

        # new 위치
        for i in "${!rels[@]}"; do
          if [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo "${rels[$i]}")" = "$(sudo readlink -f "$new" 2>/dev/null || echo "$new")" ]; then
            idx="$i"; break
          fi
        done
        # 없으면 live_real 기준
        if [ "$idx" -lt 0 ] && [ -n "$live_real" ]; then
          for i in "${!rels[@]}"; do
            if [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo "${rels[$i]}")" = "$live_real" ]; then
              idx="$i"; break
            fi
          done
        fi

        if [ "$idx" -ge 0 ]; then
          for (( i=idx+1; i<${#rels[@]}; i++ )); do
            cand="${rels[$i]}"
            # 자기 자신/현재 LIVE 제외
            [ "$(sudo readlink -f "$cand" 2>/dev/null || echo "$cand")" = "$(sudo readlink -f "$new" 2>/dev/null || echo "$new")" ] && continue
            [ -n "$live_real" ] && [ "$(sudo readlink -f "$cand" 2>/dev/null || echo "$cand")" = "$live_real" ] && continue
            # 유효성 및 .bad 제외
            sudo test -d "$cand" || continue
            sudo test -f "$cand/$BAD_MARKER_NAME" && continue
            printf '%s\n' "$cand"; return 0
          done
        fi

        return 1
      }

      # ── 헬스체크 후 실패 시 롤백 ─────────────────────────
      healthcheck_or_rollback() {
        local hc_url="$1" new="$2" prev_hint="${3:-}"

        if [ -z "$hc_url" ]; then
          log "Health check skipped (mode=none)"; return 0
        fi

        log "Health wait: $hc_url (timeout=${HC_TIMEOUT}s, mode=${HEALTH_MODE})"
        if health_wait "$hc_url" "$HC_TIMEOUT" "$HC_INTERVAL"; then
          return 0
        fi

        echo "[WARN] Health failed → rollback procedure" | sudo tee -a "$LOG" >/dev/null

        # 실패 마킹(옵션)
        if [ "$MARK_BAD_ON_ROLLBACK" = "true" ]; then
          sudo sh -c "printf 'marked bad on %s\n' \"$(date -Ins)\" > '$new/$BAD_MARKER_NAME'"
        fi

        # 안전한 순서로 롤백 대상 탐색
        local prev=""
        if prev="$(resolve_prev_for_rollback "$new" "$prev_hint")"; then
          set_live_symlink "$prev"
          tomcat_reload_or_restart
          health_wait "$hc_url" "$HC_TIMEOUT" "$HC_INTERVAL" || true
          fail "Deploy failed. Rolled back to: $prev"
        fi

        fail "Deploy failed and no previous target to rollback"
      }

      # ── 보존 정책 ───────────────────────────────────────
      prune_releases() {
        mapfile -t rels < <(sudo ls -1dt "${APP_RELEASES_DIR}/${APP_NAME}-"* 2>/dev/null || true)
        [ "${#rels[@]}" -le "$KEEP_RELEASES" ] && { log "Keep-policy: nothing to prune"; return 0; }

        for ((i=KEEP_RELEASES; i<${#rels[@]}; i++)); do
          [ -n "${new_dir:-}" ]     && [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo x)" = "$(sudo readlink -f "$new_dir" 2>/dev/null || echo y)" ] && continue
          [ -n "${prev_target:-}" ] && [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo x)" = "$(sudo readlink -f "$prev_target" 2>/dev/null || echo y)" ] && continue
          base="$(basename "${rels[$i]}")"
          [[ "$base" == "${APP_NAME}-legacy-"* ]] && continue  # 최초 이관 백업 보호
          log "Keep-policy: remove ${rels[$i]}"
          sudo rm -rf --one-file-system "${rels[$i]}" || true
        done
      }

      # ── 산출물 ZIP ─────────────────────────────────────
      package_artifacts() {
        # .env 생성
        sudo sh -c "printf 'NEW_VERSION=%s\nNEW_DIR=%s\nPREV_DIR=%s\nLIVE_LINK=%s\n' \
          \"$NEW_VERSION\" \"$new_dir\" \"${prev_target:-}\" \"$LIVE_LINK\" > \"$ART_DIR/.env\""

        # zip 생성
        sudo sh -c "(cd \"$ART_DIR\" && zip -r \"$(basename "$OUT_ZIP")\" \"$(basename "$LOG")\" .env >/dev/null 2>&1) || true"

        ok "Artifacts packaged: $OUT_ZIP"
        echo "$OUT_ZIP"
      }

      # ── 메인 ───────────────────────────────────────────
      main() {
        require_env
        ensure_tools

        prepare_new_version           # 새 릴리스 디렉터리 생성
        migrate_live_once             # 기존 LIVE 이관/탐지 (최초 배포면 prev_target 없음)
        set_live_symlink "$new_dir"   # LIVE → 새 버전 전환
        tomcat_reload_or_restart

        hc_url="$(health_url_build)"
        healthcheck_or_rollback "$hc_url" "$new_dir" "${prev_target:-}"  # 실패 시 내부에서 롤백/종료

        # 헬스 성공 시: 두 번째 배포부터 live-pointer 기록 (조건은 함수 내부에 포함)
        write_live_pointer "$new_dir" "${prev_target:-}"

        prune_releases
        package_artifacts             # 마지막 줄에 ZIP 경로 echo
      }

      main "$@"

    REMOTE_SH

      # ── 원격 실행 ─────────────────────────────────────
      log "▶ Executing symlink deploy via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "RELEASE_REPO_URL='$(shq "$RELEASE_REPO_URL")'" \
        "GROUP_ID='$(shq "$GROUP_ID")'" \
        "ARTIFACT_ID='$(shq "$ARTIFACT_ID")'" \
        "COMMIT_TAG='$(shq "$COMMIT_TAG")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "NEXUS_USER='$(shq "$NEXUS_USER")'" \
        "NEXUS_PASS='$(shq "$NEXUS_PASS")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "KEEP_RELEASES='$(shq "$keep_releases")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "DEPLOY_LOG_NAME='$(shq "$deploy_log_name")'" \
        "MARK_BAD_ON_ROLLBACK='$(shq "${MARK_BAD_ON_ROLLBACK:-true}")'" \
        "BAD_MARKER_NAME='$(shq "${BAD_MARKER_NAME:-.bad}")'" \
        'export REMOTE_DIR RELEASE_REPO_URL GROUP_ID ARTIFACT_ID COMMIT_TAG WAS_URL NEXUS_USER NEXUS_PASS CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE TOMCAT_SERVICE KEEP_RELEASES HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL HOT_RELOAD DEPLOY_USER DEPLOY_PASS DEPLOY_LOG_NAME MARK_BAD_ON_ROLLBACK BAD_MARKER_NAME; bash -s' \
        < "$remote_script" | tee /tmp/_symlink_deploy_out.txt

      # 산출물 회수
      remote_zip_path="$(tail -n1 /tmp/_symlink_deploy_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/symlink-deploy-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_symlink_deploy_out.txt || true
      ok "Symlink deploy finished"
    }

 
# ────────────────────────────────────────────────
# 함수: fn_tomcat_symbolic_restore
#
# 목적:
#   - LIVE 심링크를 “이전 릴리스 디렉터리” 또는 지정 버전 디렉터리로 되돌려 롤백한다.
#   - (선택) 헬스체크 수행. 실패 시 실패로 종료(필요 시 한 단계 더 이전으로 수동 롤백).
#
# 동작 개요:

# GitLab Runner
#    │
#    ├─ SSH 접속
#    │
#    ▼
# Tomcat Server
#   (/opt/tomcat/webapps/<APP>, /opt/tomcat/releases/<APP>/)
#    │
#    ├─ (1) Nexus에서 NEW WAR 다운로드 (HTTPS, curl -u)
#    │       BASE = <RELEASE_REPO_URL>/<GROUP_ID>/<ARTIFACT_ID>/
#    │       NEW  = <ARTIFACT_ID>-<NEW_VERSION>.war
#    │       TMP  = /opt/tomcat/releases/<APP>/<APP>-<ver>.tmp.$$
#    │            → unzip →  TMP/unzip/
#    │            → mv TMP/unzip  ⇒  /opt/tomcat/releases/<APP>/<APP>-<ver> (new_dir)
#    │            → rm -rf TMP
#    │
#    ├─ (2) LIVE 링크 교정(최초 1회만)
#    │       LIVE_LINK = /opt/tomcat/webapps/<APP>
#    │       - LIVE가 디렉터리면:
#    │           • 백업 디렉터리 생성: /opt/tomcat/releases/<APP>/<APP>-legacy-<ts>/
#    │           • LIVE/* → legacy 로 이동 후 LIVE 제거
#    │           • ln -s <new_dir>  LIVE_LINK
#    │       - LIVE가 파일/깨진 링크면 제거 후 신규 심링크 생성
#    │       - 이미 심링크면 통과
#    │
#    ├─ (3) LIVE 전환 (원자적 심링크 스위치)
#    │       ln -sfn <new_dir>  <LIVE_LINK>
#    │       (이전 대상은 readlink -f <LIVE_LINK>로 prev_target 확보)
#    │
#    ├─ (4) Tomcat 적용
#    │       - HOT_RELOAD=true & manager 계정 있으면:
#    │           http://<WAS_URL>/manager/text/reload?path=/<APP>
#    │       - 아니면: systemctl reload 실패 시 restart
#    │
#    ├─ (5) 헬스체크 (선택)
#    │       - HEALTH_URL_OVERRIDE 지정 시 해당 URL
#    │       - 아니면 모드별:
#    │           actuator: http://127.0.0.1:8080/<APP>/actuator/health
#    │           page:     http://127.0.0.1:8080/<APP>/
#    │           none:     스킵
#    │       - 실패 시:
#    │           ln -sfn <prev_target>  <LIVE_LINK>   # 즉시 롤백
#    │           Tomcat reload/restart 후 종료(실패)
#    │
#    ├─ (6) 보관정책(KEEP_RELEASES)
#    │       /opt/tomcat/releases/<APP>/<APP>-* 를 최신순 정렬
#    │       → 최신 N개 남기고 나머지 삭제(이때 prev_target 은 삭제 제외)
#    │
#    └─ (7) 결과 산출물(zip)
#            <REMOTE_DIR>/artifacts/symlink-deploy-artifacts.zip
#              ├── symlink-deploy.log
#              └── .env (CHANGED, NEW_DIR, PREV_DIR, LIVE_LINK)
#
# 특징:
#   - diff(증분) 복원 방식이 아닌, “심링크 전환” 기반의 즉시 롤백
#   - 지정 버전으로의 직접 롤백이나 자동 이전 롤백 둘 다 지원
#   - Runner 아티팩트로 롤백 로그/메타 제공
#
# 생성/수정되는 리소스:
#   - 원격: LIVE 링크(<WEBAPPS_ROOT>/<APP_NAME>) → /opt/tomcat/releases/<APP>/<APP-<version>>
#   - 원격: <REMOTE_DIR>/artifacts/symlink-rollback-artifacts.zip
#   - 로컬(Runner): artifacts/symlink-rollback-artifacts.zip
#
# 실패 시나리오:
#   - 대상 디렉터리 부재(잘못된 버전 지정/보관정책으로 삭제됨) 시 실패
#   - 헬스체크 실패 시 실패(필요하면 한 단계 더 이전 버전으로 수동 재시도)
#
# 권장 전제조건:
#   - releases 디렉터리에 유효한 이전 버전 디렉터리 존재
#   - Tomcat 재적용(reload/restart) 권한 보유
# ────────────────────────────────────────────────
.fn_tomcat_symbolic_restore:
  script: |
    fn_tomcat_symbolic_restore() {
      set -eu

      # ── 필수 ──────────────────────────────────────────
      : "${REMOTE_DEPLOY_HOST:?REMOTE_DEPLOY_HOST is required}"
      : "${REMOTE_DEPLOY_USER:?REMOTE_DEPLOY_USER is required}"
      : "${REMOTE_DIR:?REMOTE_DIR is required}"
      : "${CONTEXT_PATH:?CONTEXT_PATH is required}"
      : "${WAS_URL:?WAS_URL is required}"

      # ── 선택 ──────────────────────────────────────────
      remote_port="${REMOTE_DEPLOY_PORT:-22}"
      webapps_root="${TOMCAT_WEBAPPS_DIR:-/opt/tomcat/webapps}"
      releases_base="${RELEASES_BASE:-/opt/tomcat/releases}"
      tomcat_service="${TOMCAT_SERVICE:-tomcat}"
      rollback_to_version="${ROLLBACK_TO_VERSION:-}"   # 지정 시 해당 버전으로 롤백

      # Tomcat manager 옵션(핫리로드)
      hot_reload="${HOT_RELOAD:-false}"
      deploy_user="${DEPLOY_USER:-}"
      deploy_pass="${DEPLOY_PASS:-}"

      # 헬스체크 정책
      health_mode="${HEALTH_MODE:-actuator}"           # actuator|page|none
      health_url_override="${HEALTH_URL_OVERRIDE:-}"
      hc_timeout="${HEALTHCHECK_TIMEOUT:-60}"
      hc_interval="${HEALTHCHECK_INTERVAL:-2}"

      # 로그/산출물
      restore_log_name="${RESTORE_LOG_NAME:-symlink-rollback.log}"

      # ── 유틸 ──────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      shq()  { printf "%s" "$1" | sed "s/'/'\\\\''/g"; }

      # ── 원격 스크립트 생성 ───────────────────────────
      remote_script=$(mktemp /tmp/remote_symlink_rollback.XXXXXX)
      log "Created temporary symlink rollback script: $remote_script"

      cat > "$remote_script" <<'REMOTE_SH'
      #!/usr/bin/env bash
      set -euo pipefail
      IFS=$'\n\t'

      # ──────────────────────────────────────────────────────────────
      # 유틸리티
      # ──────────────────────────────────────────────────────────────
      log()  { printf '[INFO] %s\n' "$*"; }
      ok()   { printf '[OK]   %s\n' "$*"; }
      fail() { printf '[ERR]  %s\n' "$*" >&2; exit 1; }
      need() { command -v "$1" >/dev/null 2>&1; }
      ts()   { date +%Y%m%d%H%M%S; }

      # sudo 기반 테스트(권한 문제 회피)
      is_link() { sudo test -L "$1"; }                            # 심볼릭 링크인가?
      is_dir()  { sudo test -d "$1"; }                            # 디렉터리인가?
      is_any()  { sudo test -e "$1" || sudo test -L "$1"; }       # 어떤 엔트리든 존재하는가?

      # ──────────────────────────────────────────────────────────────
      # 환경 변수 검증 및 기본값 설정
      # ──────────────────────────────────────────────────────────────
      require_env() {
        : "${CONTEXT_PATH:?CONTEXT_PATH 필요(예: /myapp)}"
        : "${WEBAPPS_ROOT:?WEBAPPS_ROOT 필요(예: /opt/tomcat/webapps)}"
        : "${RELEASES_BASE:?RELEASES_BASE 필요(예: /opt/tomcat/releases)}"
        : "${TOMCAT_SERVICE:?TOMCAT_SERVICE 필요(예: tomcat)}"

        : "${REMOTE_DIR:?REMOTE_DIR 필요(예: /var/tmp/deploy)}"
        : "${RESTORE_LOG_NAME:=symlink-rollback.log}"   # 출력 로그 파일명

        : "${HEALTH_MODE:=actuator}"                    # actuator|page|none
        : "${HEALTH_URL_OVERRIDE:=}"
        : "${HC_TIMEOUT:=60}"
        : "${HC_INTERVAL:=2}"
        : "${WAS_URL:?WAS_URL 필요(host:port)}"

        : "${HOT_RELOAD:=false}"                        # Tomcat manager reload 사용 여부
        : "${DEPLOY_USER:=}"                            # manager reload 계정
        : "${DEPLOY_PASS:=}"

        : "${ROLLBACK_TO_VERSION:=}"                    # 명시적 버전 롤백 시 사용(선택)
        : "${BAD_MARKER_NAME:=.bad}"                    # 불량 마커 파일명
        : "${MARK_BAD_ON_ROLLBACK:=true}"               # 롤백 성공 후 이전 CURRENT에 bad 마커 남길지

        APP_NAME="${CONTEXT_PATH#/}"                    # "/myapp" → "myapp"
        LIVE_LINK="${WEBAPPS_ROOT%/}/${APP_NAME}"
        APP_RELEASES_DIR="${RELEASES_BASE%/}/${APP_NAME}"

        ART_DIR="${REMOTE_DIR%/}/artifacts"
        LOG="$ART_DIR/$RESTORE_LOG_NAME"
        OUT_ZIP="$ART_DIR/symlink-rollback-artifacts.zip"

        sudo mkdir -p "$REMOTE_DIR" "$ART_DIR" "$APP_RELEASES_DIR"
        # 로그 파일 초기화(root 소유여도 무방)
        sudo sh -c ": > \"$LOG\""
      }

      # ──────────────────────────────────────────────────────────────
      # 필요한 도구 확인(가능하면 설치) 및 최종 보증
      # ──────────────────────────────────────────────────────────────
      ensure_tools() {
        local pkgs=(ln readlink zip ls curl awk)

        for t in "${pkgs[@]}"; do
          if ! need "$t"; then
            if   need apk; then
              sudo apk add --no-cache "$t" || true
            elif need apt-get; then
              sudo apt-get update -y || true
              sudo apt-get install -y "$t" || true
            elif need dnf; then
              sudo dnf install -y "$t" || true
            elif need yum; then
              sudo yum install -y "$t" || true
            elif need zypper; then
              sudo zypper --non-interactive install "$t" || true
            else
              log "WARN: 패키지 매니저를 찾을 수 없어 '$t' 자동 설치 불가"
            fi
          fi
        done

        # 최종 확인(없으면 명확히 실패)
        for t in "${pkgs[@]}"; do
          need "$t" || fail "'$t' 사용 불가"
        done
      }

      # ──────────────────────────────────────────────────────────────
      # 심볼릭 링크 헬퍼
      # ──────────────────────────────────────────────────────────────
      ln_s_safe() {
        local tgt="$1" link="$2"
        link="${link%/}"
        sudo ln -sT "$tgt" "$link" 2>/dev/null || sudo ln -s "$tgt" "$link"
      }
      set_live_symlink() {
        local target_dir="$1"
        local tmp_link="${LIVE_LINK}.new.$(ts)"
        ln_s_safe "$target_dir" "$tmp_link"
        # 원자적 교체: mv -T(gnu) → 실패 시 수동 교체
        sudo mv -Tf "$tmp_link" "$LIVE_LINK" 2>/dev/null || {
          sudo rm -rf --one-file-system "$LIVE_LINK"
          sudo mv "$tmp_link" "$LIVE_LINK"
        }
        log "LIVE -> $target_dir"
      }

      # ──────────────────────────────────────────────────────────────
      # 1회성 마이그레이션: LIVE가 심볼릭 링크가 아니면(디렉터리/파일) releases로 백업
      # ──────────────────────────────────────────────────────────────
      migrate_live_once() {
        local releases_base_dir="$1"
        sudo mkdir -p "$releases_base_dir"

        log "MIGRATE: probe $(sudo ls -ld "$LIVE_LINK" 2>/dev/null || echo '<not-found>')"

        if is_link "$LIVE_LINK"; then
          log "MIGRATE: 이미 심볼릭 링크 -> $(sudo readlink -f "$LIVE_LINK" 2>/dev/null || echo '<broken>')"
          return 0
        fi

        if is_dir "$LIVE_LINK"; then
          local legacy="${releases_base_dir}/${APP_NAME}-legacy-$(ts)"
          log "MIGRATE: LIVE 디렉터리를 legacy로 이동: $legacy"
          sudo mv "$LIVE_LINK" "$legacy"
          log "MIGRATE: 이동됨 -> $(sudo ls -ld "$legacy")"
        elif is_any "$LIVE_LINK"; then
          local legacy="${releases_base_dir}/${APP_NAME}-legacy-$(ts).file"
          log "MIGRATE: LIVE 파일을 legacy로 이동: $legacy"
          sudo mv "$LIVE_LINK" "$legacy"
          log "MIGRATE: 이동됨 -> $(sudo ls -l "$legacy")"
        else
          log "MIGRATE: 이동할 대상 없음(첫 심볼릭 전환 상황)"
        fi
      }

      # ──────────────────────────────────────────────────────────────
      # Tomcat reload/restart(Tomcat Manager reload 옵션 지원)
      # ──────────────────────────────────────────────────────────────
      tomcat_reload_or_restart() {
        if [ "$HOT_RELOAD" = "true" ] && [ -n "$DEPLOY_USER" ] && [ -n "$DEPLOY_PASS" ] && need curl; then
          curl -fsS -u "$DEPLOY_USER:$DEPLOY_PASS" "http://${WAS_URL}/manager/text/reload?path=/${APP_NAME}" \
            | sudo tee -a "$LOG" >/dev/null || true
          log "Tomcat manager reload 요청 완료"
          return 0
        fi
        if need systemctl; then
          if sudo systemctl reload "$TOMCAT_SERVICE" 2>/dev/null; then
            log "Tomcat reload 성공"; return 0
          fi
          log "Reload 미지원 → restart 시도"
          sudo systemctl restart "$TOMCAT_SERVICE"
          log "Tomcat restart 성공"
        fi
      }

      # ──────────────────────────────────────────────────────────────
      # 헬스체크(URL 생성 + 대기)
      # ──────────────────────────────────────────────────────────────
      health_url_build() {
        if [ -n "$HEALTH_URL_OVERRIDE" ]; then
          printf '%s\n' "$HEALTH_URL_OVERRIDE"; return
        fi
        case "$HEALTH_MODE" in
          actuator) printf 'http://127.0.0.1:8080/%s/actuator/health\n' "$APP_NAME" ;;
          page)     printf 'http://127.0.0.1:8080/%s/\n' "$APP_NAME" ;;
          none)     printf '\n' ;;
          *)        printf 'http://127.0.0.1:8080/%s/actuator/health\n' "$APP_NAME" ;;
        esac
      }
      health_wait() {
        local url="$1" timeout="$2" interval="$3" elapsed=0
        while [ "$elapsed" -lt "$timeout" ]; do
          if curl -fsS --max-time 3 "$url" >/dev/null 2>&1; then
            log "Health OK: $url"
            return 0
          fi
          sleep "$interval"
          elapsed=$((elapsed+interval))
        done
        return 1
      }

      # ──────────────────────────────────────────────────────────────
      # live-pointer 헬퍼(CURRENT/PREV)
      # ──────────────────────────────────────────────────────────────
      read_live_pointer_prev() {
        # CURRENT/_logs/live-pointer.env 에서 PREV 읽기
        local current_real prev
        current_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        if [ -z "$current_real" ]; then
          return 1
        fi
        if sudo test -f "$current_real/_logs/live-pointer.env"; then
          prev="$(sudo awk -F= '/^PREV=/{print $2}' "$current_real/_logs/live-pointer.env" | tr -d '\r')"
          if [ -n "$prev" ] && sudo test -d "$prev"; then
            printf '%s\n' "$prev"
            return 0
          fi
        fi
        return 1
      }

      # ──────────────────────────────────────────────────────────────
      # 후보 릴리스 목록 생성(최신순), .bad 제외
      # ──────────────────────────────────────────────────────────────
      list_candidates() {
        # 최신 → 오래된 순서로 릴리스 디렉터리 출력, .bad 는 스킵
        sudo ls -1dt "${APP_RELEASES_DIR}/${APP_NAME}-"* 2>/dev/null \
        | while read -r d; do
            if sudo test -f "$d/$BAD_MARKER_NAME"; then
              continue
            fi
            printf "%s\n" "$d"
          done
      }

      # ──────────────────────────────────────────────────────────────
      # 롤백 대상 선택(안전 순서)
      # 1) ROLLBACK_TO_VERSION 이 지정되면 그 버전 사용(존재 & .bad 아님)
      # 2) live-pointer의 PREV 가 있으면 그 경로 사용
      # 3) 그렇지 않으면 CURRENT의 "직전(older sibling)" 1개 선택
      #    - CURRENT 자신 제외
      #    - .bad 제외
      # ──────────────────────────────────────────────────────────────
      choose_target() {
        local target="" current_real="" cand prev_hint="" rel
        local -a rels=()
        local i idx=-1

        # 1) 명시적 버전 우선
        if [ -n "$ROLLBACK_TO_VERSION" ]; then
          cand="${APP_RELEASES_DIR}/${APP_NAME}-${ROLLBACK_TO_VERSION}"
          if sudo test -d "$cand"; then
            if ! sudo test -f "$cand/$BAD_MARKER_NAME"; then
              printf '%s\n' "$cand"; return 0
            else
              fail "명시 대상에 BAD 마커 존재: $cand/$BAD_MARKER_NAME"
            fi
          else
            fail "명시 대상 버전을 찾을 수 없음: $cand"
          fi
        fi

        # LIVE가 심볼릭이 아니면 1회 마이그레이션
        if ! is_link "$LIVE_LINK"; then
          migrate_live_once "$APP_RELEASES_DIR"
        fi

        # CURRENT(실경로)
        current_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        printf 'CURRENT=%s\n' "${current_real:-}" | sudo tee -a "$LOG" >/dev/null

        # 2) live-pointer PREV 우선 시도
        if prev_hint="$(read_live_pointer_prev)"; then
          printf '%s\n' "$prev_hint"; return 0
        fi

        # 3) 후보 목록에서 CURRENT의 바로 이전 선택
        mapfile -t rels < <(list_candidates)
        # 후보가 하나도 없으면 실패
        [ "${#rels[@]}" -gt 0 ] || return 1

        # 후보 목록에서 CURRENT의 인덱스 찾기
        if [ -n "$current_real" ]; then
          for i in "${!rels[@]}"; do
            if [ "$(sudo readlink -f "${rels[$i]}" 2>/dev/null || echo "${rels[$i]}")" = "$current_real" ]; then
              idx="$i"; break
            fi
          done
        fi

        # CURRENT를 찾았으면 그 다음(오래된 것) 반환
        if [ "$idx" -ge 0 ]; then
          for (( i=idx+1; i<${#rels[@]}; i++ )); do
            rel="${rels[$i]}"
            sudo test -d "$rel" || continue
            printf '%s\n' "$rel"; return 0
          done
          # CURRENT가 가장 오래된 항목이라면 롤백 불가
          return 1
        fi

        # CURRENT를 목록에서 못 찾은 경우(엣지): CURRENT와 다른 최신 후보 반환
        for rel in "${rels[@]}"; do
          [ -n "$current_real" ] && [ "$(sudo readlink -f "$rel" 2>/dev/null || echo "$rel")" = "$current_real" ] && continue
          printf '%s\n' "$rel"; return 0
        done

        return 1
      }

      # ──────────────────────────────────────────────────────────────
      # 전환 후 헬스체크(wrapper)
      # ──────────────────────────────────────────────────────────────
      post_switch_health_or_fail() {
        local hc_url
        hc_url="$(health_url_build)"
        if [ -z "$hc_url" ] || ! need curl; then
          log "헬스체크 생략"
          return 0
        fi
        log "헬스 대기: $hc_url (timeout=${HC_TIMEOUT}s, mode=${HEALTH_MODE})"
        health_wait "$hc_url" "$HC_TIMEOUT" "$HC_INTERVAL" || fail "롤백 후 헬스 실패: $hc_url"
      }

      # ──────────────────────────────────────────────────────────────
      # 이전 CURRENT에 BAD 마커 생성(롤백 성공 이후만)
      # ──────────────────────────────────────────────────────────────
      mark_previous_current_bad() {
        local previous_current="$1"
        if [ -n "$previous_current" ] && sudo test -d "$previous_current" && [ "$MARK_BAD_ON_ROLLBACK" = "true" ]; then
          sudo sh -c "printf 'marked bad on %s\n' \"$(date -Ins)\" > '$previous_current/$BAD_MARKER_NAME'"
        fi
      }

      # ──────────────────────────────────────────────────────────────
      # 산출물 패키징(zip)
      # ──────────────────────────────────────────────────────────────
      package_artifacts() {
        local target="$1"
        sudo sh -c "printf 'ROLLED_BACK_TO=%s\nLIVE_LINK=%s\n' \
          \"$target\" \"$LIVE_LINK\" > \"$ART_DIR/.env\""
        sudo sh -c "(cd \"$ART_DIR\" && zip -r \"$(basename "$OUT_ZIP")\" \"$(basename "$LOG")\" .env >/dev/null 2>&1) || true"
        ok "Artifacts packaged: $OUT_ZIP"
        echo "$OUT_ZIP"
      }

      # ──────────────────────────────────────────────────────────────
      # 메인
      # ──────────────────────────────────────────────────────────────
      main() {
        require_env
        ensure_tools

        # 전환 전 CURRENT 기록(디버그용)
        local current_real=""
        if is_link "$LIVE_LINK"; then
          current_real="$(sudo readlink -f "$LIVE_LINK" 2>/dev/null || true)"
        fi
        printf 'CURRENT(before)=%s\n' "${current_real:-}" | sudo tee -a "$LOG" >/dev/null

        # 롤백 대상 결정
        local target=""
        if ! target="$(choose_target)"; then
          # 디버그를 위해 사용 가능한 릴리스 나열
          echo "AVAILABLE_RELEASES:" | sudo tee -a "$LOG" >/dev/null
          list_candidates | sed 's/^/ - /' | sudo tee -a "$LOG" >/dev/null || true
          fail "롤백 대상을 결정할 수 없습니다"
        fi
        printf 'TARGET=%s\n' "$target" | sudo tee -a "$LOG" >/dev/null

        # LIVE → target 전환
        set_live_symlink "$target"

        # Tomcat reload/restart 적용
        tomcat_reload_or_restart

        # 헬스체크(설정된 경우)
        post_switch_health_or_fail

        # 롤백 성공 후 이전 CURRENT에 BAD 마커 표시(옵션)
        mark_previous_current_bad "$current_real"

        # 산출물 패키징
        package_artifacts "$target"

        ok "Symlink rollback completed"
      }

      main "$@"




    REMOTE_SH

      # ── 원격 실행 ─────────────────────────────────────
      log "▶ Executing symlink rollback via SSH: ${REMOTE_DEPLOY_USER}@${REMOTE_DEPLOY_HOST}:${remote_port}"
      ssh -p "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST" \
        "REMOTE_DIR='$(shq "$REMOTE_DIR")'" \
        "CONTEXT_PATH='$(shq "$CONTEXT_PATH")'" \
        "WEBAPPS_ROOT='$(shq "$webapps_root")'" \
        "RELEASES_BASE='$(shq "$releases_base")'" \
        "TOMCAT_SERVICE='$(shq "$tomcat_service")'" \
        "ROLLBACK_TO_VERSION='$(shq "$rollback_to_version")'" \
        "HEALTH_MODE='$(shq "$health_mode")'" \
        "HEALTH_URL_OVERRIDE='$(shq "$health_url_override")'" \
        "HC_TIMEOUT='$(shq "$hc_timeout")'" \
        "HC_INTERVAL='$(shq "$hc_interval")'" \
        "RESTORE_LOG_NAME='$(shq "$restore_log_name")'" \
        "HOT_RELOAD='$(shq "$hot_reload")'" \
        "DEPLOY_USER='$(shq "$deploy_user")'" \
        "DEPLOY_PASS='$(shq "$deploy_pass")'" \
        "WAS_URL='$(shq "$WAS_URL")'" \
        "MARK_BAD_ON_ROLLBACK='$(shq "${MARK_BAD_ON_ROLLBACK:-true}")'" \
        "BAD_MARKER_NAME='$(shq "${BAD_MARKER_NAME:-.bad}")'" \
        'export REMOTE_DIR CONTEXT_PATH WEBAPPS_ROOT RELEASES_BASE TOMCAT_SERVICE ROLLBACK_TO_VERSION HEALTH_MODE HEALTH_URL_OVERRIDE HC_TIMEOUT HC_INTERVAL RESTORE_LOG_NAME HOT_RELOAD DEPLOY_USER DEPLOY_PASS WAS_URL MARK_BAD_ON_ROLLBACK BAD_MARKER_NAME; bash -s' \
        < "$remote_script" | tee /tmp/_symlink_rollback_out.txt

      # ── 산출물 회수 ───────────────────────────────────
      remote_zip_path="$(tail -n1 /tmp/_symlink_rollback_out.txt || true)"
      [ -z "$remote_zip_path" ] && remote_zip_path="${REMOTE_DIR}/artifacts/symlink-rollback-artifacts.zip"
      local_dir="${CI_PROJECT_DIR:-.}/artifacts"
      mkdir -p "$local_dir"
      scp -P "$remote_port" "$REMOTE_DEPLOY_USER@$REMOTE_DEPLOY_HOST:$remote_zip_path" "$local_dir/" || true

      rm -f "$remote_script" /tmp/_symlink_rollback_out.txt || true
      ok "Symlink rollback finished"
    }
